<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, August 27, 2015, 11:10 AM -->
<!-- MuClient version 4.93 -->

<!-- Plugin "Masaki_Mob_Counter" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Masaki_Mob_Counter"
   author="BluMalice"
   id="dd2557ecf27843fd3aef5d33"
   language="Lua"
   purpose="Blacksmith exclusive plugin that shows number of mobs currently engaged with"
   save_state="y"
   date_written="2015-08-27 11:09:05"
   requires="4.63"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
<trigger
	enabled="n"
	match="^\[\d+\] Your swing (misses|tickles|bruises|scratches|grazes|nicks|scars|hits|injures|wounds|mauls|maims|mangles|mars|LACERATES|DECIMATES|DEVASTATES|ERADICATES|OBLITERATES|EXTIRPATES|INCINERATES|MUTILATES|DISEMBOWELS|MASSACRES|DISMEMBERS|RENDS|- BLASTS -|-= DEMOLISHES =-|\*\* SHREDS \*\*|\*\*\*\* DESTROYS \*\*\*\*|\*\*\*\*\* PULVERIZES \*\*\*\*\*|-=- VAPORIZES -=-|\<-==-\> ATOMIZES \<-==-\>|\<-:-\> ASPHYXIATES \<-:-\>|\<-\*-\> RAVAGES \<-\*-\>|\<\>\*\<\> FISSURES \<\>\*\<\>|\<\*\>\<\*\> LIQUIDATES \<\*\>\<\*\>|\<\*\>\<\*\>\<\*\> EVAPORATES \<\*\>\<\*\>\<\*\>|\<-=-\> SUNDERS \<-=-\>|\<=-=\>\<=-=\> TEARS INTO \<=-=\>\<=-=\>|\<-\>\*\<=\> WASTES \<=\>\*\<-\>|\<-\+-\>\<-\*-\> CREMATES \<-\*-\>\<-\+-\>|\<\*\>\<\*\>\<\*\>\<\*\> ANNIHILATES \<\*\>\<\*\>\<\*\>\<\*\>|\<--\*--\>\<--\*--\> IMPLODES \<--\*--\>\<--\*--\>|\<-\>\<-=-\>\<-\> EXTERMINATES \<-\>\<-=-\>\<-\>|\<-==-\>\<-==-\> SHATTERS \<-==-\>\<-==-\>|\<\*\>\<-:-\>\<\*\> SLAUGHTERS \<\*\>\<-:-\>\<\*\>|\<-\*-\>\<-\>\<-\*-\> RUPTURES \<-\*-\>\<-\>\<-\*-\>|\<-\*-\>\<\*\>\<-\*-\> NUKES \<-\*-\>\<\*\>\<-\*-\>|-\<\[=-\+-=\]\<:::\<\>:::\> GLACIATES \<:::\<\>:::\>\[=-\+-=\]\>-|\<-=-\>\<-:-\*-:-\>\<\*--\*\> METEORITES \<\*--\*\>\<-:-\*-:-\>\<-=-\>|\<-:-\>\<-:-\*-:-\>\<-\*-\> SUPERNOVAS \<-\*-\>\<-:-\*-:-\>\<-:-\>|does UNSPEAKABLE things to|does UNTHINKABLE things to|does UNIMAGINABLE things to|does UNBELIEVABLE things to) (.+). \[\d+\]$"
	regexp="y"
	sequence="100"
	group="count"
	send_to="12">
	<send>
		if first then
			mobs = {}
			first = false
		end
		table.insert(mobs, "%2")
	</send>
</trigger>
<trigger
	enabled="n"
	match="(^&lt;)|^$"
	regexp="y"
	sequence="100"
	send_to="12"
	group="count">
	<send>
		first = true
		drawDefaults()
	</send>
</trigger>
</triggers>

<!--  Aliases  -->

<aliases>
<alias
	match="^mcounter show$"
	enabled="y"
	regexp="y"
	send_to="10"
	ignore_case="y"
	sequence="100"
	script="closeToggle">
</alias>
</aliases>
<script>
<![CDATA[

require "serialize"

win = "Masaki_Mob_Counter_" .. GetPluginID()
vars = {}
icon = GetPluginInfo(GetPluginID(), 20) .. "Masaki2.png"

-- Saved variables
vars.defaultFont = "defaultFont"
vars.defaultFontFamily = "Consolas"
vars.header = {}
vars.winLeft = 0
vars.winTop = 0
vars.winRight = 200
vars.winBottom = 200
vars.winHeight = 2
vars.pos_x = 495
vars.pos_y = 322
vars.show = true
vars.minimize = false

dragSpot = nil
mobs  = {}
fighting = ""
first = true
displayText = ""

function OnPluginInstall()
	-- Restore saved states
	assert(loadstring(GetVariable("vars") or ""))()
	vars = vars or {}
	
	-- too lazy to do this the right way
	vars.fontSize = 9
	vars.fontHeight = 9
	
	-- Prepare miniwin header
	vars.header = {}
	
	-- Load miniwin and its properties
	WindowCreate(win, vars.winLeft, vars.winTop, vars.winRight, vars.winBottom, miniwin.pos_center_all, miniwin.create_keep_hotspots, ColourNameToRGB("black"))
	WindowFont(win, vars.defaultFont, vars.defaultFontFamily, vars.fontSize, false, false, false, false, 1, 0)
	WindowLoadImage(win, "icon", icon)
	
	-- Draw basic miniwin
	vars.fontHeight = WindowFontInfo(win, vars.defaultFont, 1)
	vars.winRight = textWidth("::: Mobs - ") + vars.fontSize * 2 + 5
	resize()
	WindowSetZOrder(win, 500)
	drawDefaults()
	WindowShow(win, vars.show)
	WindowPosition(win, vars.pos_x, vars.pos_y, 
                 miniwin.pos_stretch_to_view, 
                 miniwin.create_absolute_location)
	
	Note("                 +--------------------+")
	Note("                 | Type mcounter show |")
	Note("                 |   to hide/unhide   |")
	Note("                 |    Mobs miniwin    |")
	Note("                 | Assure damage isn't|")
	Note("                 | damage 5 by typing |")
	Note("                 |      damage #      |")
	Note("                 +--------------------+")
end

function OnPluginSaveState()
	SetVariable("vars", serialize.save("vars"))
end

function dragmove(flags, hotspot_id)

	local previousX, previousY = vars.pos_x, vars.pos_y
	
	if not dragSpot then
		vars.pos_x, vars.pos_y = WindowInfo (win, 17) - WindowInfo(win, 14), WindowInfo (win, 18) - 5
		dragSpot = WindowInfo(win, 14)
	else
		vars.pos_x, vars.pos_y = WindowInfo (win, 17) - dragSpot, WindowInfo (win, 18) - 5
	end
	
	local changedX, changedY = vars.pos_x - previousX, vars.pos_y - previousY
	snap(win, changedX, changedY, vars)

	WindowPosition(win, vars.pos_x, vars.pos_y, 
				   miniwin.pos_stretch_to_view, 
                   miniwin.create_absolute_location)
end -- dragmove

function dragrelease(flags, hotspot_id)
	-- Note ("moved to position " .. tostring(potvars.pos_x) .. " - " .. tostring(potvars.pos_y))
	dragSpot = nil
end

function showWindow(show)
	-- Utility function, shows or hides the miniwin.
	
	WindowShow(win, show)
end

function redraw()
	-- Utility function, redraws the miniwin.	
	drawDefaults()
	showWindow(vars.show)
end

function resize()
	-- Utility function, resizes the miniwin.	
	if not vars.minimize then
		WindowResize(win, vars.winRight, ((table.getn(mobs) or 0) + 1) * vars.fontHeight, ColourNameToRGB("black"))
	else
		WindowResize(win, vars.winRight, vars.fontHeight, ColourNameToRGB("black"))
	end
end

function textWidth(text)
	-- Utility function, returns the total width the given text requires within the miniwin.
	
	return WindowTextWidth(win, vars.defaultFont, text)
end

function drawDefaults()	
	-- Utility function, draws the default layout of the miniwin.
	
	-- Figure out what is being drawn first to determine the size of the window
    vars.header = {}	
	table.insert(vars.header, { text = ":", textcolour = ColourNameToRGB("firebrick") }) 
	table.insert(vars.header, { text = ":", textcolour = ColourNameToRGB("gainsboro") }) 
	table.insert(vars.header, { text = ":", textcolour = ColourNameToRGB("darkgoldenrod") }) 
	table.insert(vars.header, { text = " Mobs - ", textcolour = ColourNameToRGB("white")})	
	table.insert(vars.header, { text = tostring(table.getn(mobs) or 0), textcolour = ColourNameToRGB("white")})	
	
	local mobStyles = {}
	local width = textWidth("::: Mobs - ") + vars.fontSize * 2 + 5
	local foundFighting = false
	local mobColor = "white"
	if (not vars.minimize and table.getn(mobs) > 0) then							
		for i, mob in ipairs(mobs) do
			if (not foundFighting and mob == fighting) then 
				mobColor = "yellow"
				foundFighting = true
			end
			
			table.insert(mobStyles, {text = mob, textcolour = ColourNameToRGB(mobColor)})			
			local newWidth = textWidth(mob) + 10
			if (width < newWidth) then width = newWidth end
			
			mobColor = "white"
		end
	end
	vars.winRight = width

	resize()
	
	-- Miniwin background and outline
	WindowRectOp(win, miniwin.rect_fill , 0, 0, vars.winRight, 0, ColourNameToRGB("black"))	
	WindowRectOp(win, miniwin.rect_3d_rect , 0, 0, vars.winRight, 0, ColourNameToRGB("firebrick"), ColourNameToRGB("firebrick"))	
	
	-- Seperator for header
	WindowRectOp(win, miniwin.rect_3d_rect, 0, 0, vars.winRight, vars.fontHeight, ColourNameToRGB("firebrick"), ColourNameToRGB("firebrick"))
	
	-- Drag hotspot for header
	WindowAddHotspot(win, "DragArea", textWidth(":::") + 5, 0, vars.winRight, vars.fontHeight, "", "", "", "", "", vars.headerhint, miniwin.cursor_both_arrow, 0)
	WindowDragHandler(win, "DragArea", "dragmove", "dragrelease", 0)
	
	-- Minimize and close button	
	WindowAddHotspot(win, "ToggleArea", 5, 1, textWidth(":::") + 5, vars.fontSize * 1.16, "", "", "", "", "toggleMiniwin", "{-=Left click to minimize : Right click to close=-}", miniwin.cursor_hand, 0)
	
	-- Finally, draw the mobs and count
	drawText("", 0, vars.header)
	local count = 1
	for i, mobStyle in ipairs(mobStyles) do		
		drawText("", count, { { text = mobStyle.text, textcolour = mobStyle.textcolour } })
		count = count + 1
	end
end

function drawText(text, top, styles)
	-- Utility function, draws text into the miniwin.
	
	local left = 5
	if styles ~= nil then
		for i, v in ipairs(styles) do
			left = left + WindowText(win, vars.defaultFont, v.text, left, top * vars.fontHeight - 1, 0, 0, v.textcolour, true)
		end
	end
end

function toggleMiniwin(flags, hotspot_id)
	-- Utility function, toggles miniwin sizes.
	
	if flags == miniwin.hotspot_got_rh_mouse then
		closeToggle()
	elseif flags == miniwin.hotspot_got_lh_mouse then
		vars.minimize = not vars.minimize
		resize()
		redraw()
	end
end

function closeToggle()
	-- Utility function, displays or hides miniwin.
	
	vars.show = not vars.show
	showWindow(vars.show)
end

function lessThanEqual(a, b)
	return a <= b
end

function OnPluginClose()
	WindowDelete(win)
end

function OnPluginDisable()
	showWindow(false)
end

function OnPluginEnable()
	showWindow(true)
end


function OnPluginBroadcast(msg, id, name, text)	
	if id == "3e7dedbe37e44942dd46d264" then
		if text == "char.status" then
			local res, val = CallPlugin("3e7dedbe37e44942dd46d264", "gmcpval", "char.status.state")
			
			if val == "8" then
				world.EnableTriggerGroup("count", true)
				-- check who we are fighting
				local res, val = CallPlugin("3e7dedbe37e44942dd46d264", "gmcpval", "char.status.enemy")
				fighting = val
			else
				world.EnableTriggerGroup("count", false)		
				mobs = {}
				fighting = ""
				drawDefaults()
			end					
		end
	end
end


--[[ ================================================================== 
     =                       MINIWIN SNAP CLASS                       = 
     ================================================================== ]]

rect = {}

rect.intersects = function(r1, r2)
	local rw, rh, tw, th = rect.width(r2) + r2.x1, rect.height(r2) + r2.y1, rect.width(r1) + r1.x1, rect.height(r1) + r1.y1
	return ((rw < r2.x1 or rw > r1.x1) and
            (rh < r2.y1 or rh > r1.y1) and
            (tw < r1.x1 or tw > r2.x1) and
            (th < r1.y1 or th > r2.y1))
end

rect.width = function(r1)
	return math.abs(r1.x2 - r1.x1)
end

rect.height = function(r1)
	return math.abs(r1.y2 - r1.y1)
end

rect.snappable = function(r1, r2, saveVar)
	-- The idea here is to create inner and outer shells of the second rect,
	-- then check if the first rect intersects with the outer shell but not
	-- with the inner shell. If this is true, then the first rect can snap
	-- to the second rect.
	
	local outerr2 = {x1 = r2.x1 - (saveVar.snapSize or 10), y1 = r2.y1 - (saveVar.snapSize or 10), x2 = r2.x2 + (saveVar.snapSize or 10), y2 = r2.y2 + (saveVar.snapSize or 10)}
	local innerr2 = {x1 = r2.x1 + (saveVar.snapSize or 10), y1 = r2.y1 + (saveVar.snapSize or 10), x2 = r2.x2 - (saveVar.snapSize or 10), y2 = r2.y2 - (saveVar.snapSize or 10)}
	return rect.intersects(r1, outerr2) and not rect.intersects(r1, innerr2)
end

rect.snapEdge = function(r1, r2, saveVar)
	-- What happens here is the second rect gets separated
	-- into four pieces, one for each side. We then check
	-- which piece intersects with the first rect, and
	-- the piece that intersects will then be the snap edge.
	local top = {x1 = r2.x1, y1 = r2.y1 - (saveVar.snapSize or 10), x2 = r2.x2, y2 = r2.y1 + (saveVar.snapSize or 10)}
	local bottom = {x1 = r2.x1, y1 = r2.y2 - (saveVar.snapSize or 10), x2 = r2.x2, y2 = r2.y2 + (saveVar.snapSize or 10)}
	local left = {x1 = r2.x1 - (saveVar.snapSize or 10), y1 = r2.y1, x2 = r2.x1 + (saveVar.snapSize or 10), y2 = r2.y2}
	local right = {x1 = r2.x2 - (saveVar.snapSize or 10), y1 = r2.y1, x2 = r2.x2 + (saveVar.snapSize or 10), y2 = r2.y2}
	return rect.intersects(r1, top) and r1.y2 <= r2.y1, rect.intersects(r1, bottom) and r1.y1 >= r2.y2, rect.intersects(r1, left) and r1.x2 <= r2.x1, rect.intersects(r1, right) and r1.x1 >= r2.x2
end

function snap(currentWindow, changedX, changedY, saveVar)
	-- Attempt to snap gauge to other miniwins
	-- currentWindow is the dragged window ID
	-- changedX and changedY is the difference the previous window position and the current window position
	--    eg: local previousX, previousY = vars.pos_x, vars.pos_y
	--		  vars.pos_x, vars.pos_y = WindowInfo(win, 17) - dragSpotX, WindowInfo(win, 18) - dragSpotY
	--		  local changedX, changedY = vars.pos_x - previousX, vars.pos_y - previousY
	-- saveVar is where the new x and y positions are saved, usually vars, but can be elsewhere
	
	local currentRect = {x1 = WindowInfo(currentWindow, 10) + changedX, y1 = WindowInfo(currentWindow, 11) + changedY, x2 = WindowInfo(currentWindow, 12) + changedX, y2 = WindowInfo(currentWindow, 13) + changedY}
	local windows = WindowList()
	for i, v in ipairs(windows) do
		-- If miniwin is visible and we aren't checking the current gauge
		if WindowInfo(v, 5) and v ~= currentWindow then
			local winRect = {x1 = WindowInfo(v, 10), y1 = WindowInfo(v, 11), x2 = WindowInfo(v, 12), y2 = WindowInfo(v, 13)}
			if rect.snappable(currentRect, winRect, saveVar) then
				local top, bottom, left, right = rect.snapEdge(currentRect, winRect, saveVar)
				
				if top then
					saveVar.pos_y = winRect.y1 - rect.height(currentRect)
				elseif bottom then
					saveVar.pos_y = winRect.y2
				elseif left then
					saveVar.pos_x = winRect.x1 - rect.width(currentRect)
				elseif right then
					saveVar.pos_x = winRect.x2
				end
			end
		end
	end
end
]]>
</script>
</muclient>
