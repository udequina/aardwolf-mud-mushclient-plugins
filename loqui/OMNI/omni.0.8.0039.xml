<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, July 14, 2019, 7:12 PM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "omni" generated by Plugin Wizard -->

<muclient>
<plugin
   name="omni"
   author="Durel"
   id="b16d151337abc0f39a282125"
   language="Lua"
   purpose="Monitor status of mobs and players"
   save_state="y"
   date_written="2019-07-14 7:12:52"
   requires="5.06"
   version="1.0"
   >
<description trim="y">
<![CDATA[
The "Omniscient" plugin monitors the status of mobs and players.
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>


<!--  Triggers  -->
    
<!--  Aliases  -->

<aliases>

  <alias
   match="^[ ]*omni[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.set("%1")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+report[ ]+(all|mob|grp|~grp|grp-area|~grp-area|hp|tgt)[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.report.cli("%1", "%2")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+report[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.report.chars()</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+discover([ ]+on|[ ]+off)?[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.discover.cli(Trim("%1"))</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+scan[ ]+(players|area|room|mud|glance|study|consider|who)([ ]+[0-9]+)?[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.scan.processCLI("%1", tonumber("%2"))</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+database[ ]+reset[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.charsdb.reset()</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+database[ ]+clean[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.charsdb.clean()</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+database[ ]+search[ ]+(.*?)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.charsdb.search(\"%1\", true)</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+database[ ]+key(?:word)?[ ]+(.*?)[ ]+query[ ]+(.*?)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.charsdb.edit.nameKey(\"%1\", \"%2\")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+alias[ ]+create[ ]+([^ ]+)[ ]+command[ ]+(.*)[ ]+query[ ]+(.*)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.alias.create("%1", "%2", "%3", false)</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+alias[ ]+delete[ ]+([^ ]+)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.alias.delete("%1")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+alias[ ]+display([ ]+[^ ]+)?[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.alias.display(Trim("%1"))</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+alias[ ]+reset[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.alias.reset()</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+execute[ ]+([^ ]+)([ ]+[\-0-9]+)?[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.alias.execute("%1", "%2")</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+execute[ ]+command[ ]+(.*)[ ]+query[ ]+(.*)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.alias.command("%1", "%2")</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+options[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.options.report()</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+hitlist[ ]+display[ ]+([^ ]+)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.hitlist.display("%1")</send>
  </alias>
  
  <alias
   match="^[ ]*(campaign|campaig|campai|campa|cp)[ ]+(request|reques|requ|req|re|r|check|chec|che|ch|c)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   keep_evaluating="n"
   sequence="1"
  >
  <send>omni.hitlist.campaign.refresh(\"%1\", \"%2\")</send>
  </alias>
  
  <alias
   match="^[ ]*(gquest|gques|gque|gqu|gq)[ ]+(check|chec|che|ch|c)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   keep_evaluating="n"
   sequence="1"
  >
  <send>omni.hitlist.gquest.refresh(\"%1\", \"%2\")</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+(?:mini)?win[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.miniwin.set("%1")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+(?:mini)?win[ ]+reset[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.miniwin.reset.all() omni.miniwin.save()</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+(?:mini)?win[ ]+mode[ ]+([^ ]+)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.miniwin.mode.set("%1")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+(?:mini)?win[ ]+titlebar[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.miniwin.titlebar.set("%1")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+(?:mini)?win[ ]+optionbar[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.miniwin.optionbar.set("%1")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+(?:mini)?win[ ]+summarybar[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.miniwin.summarybar.set("%1")</send>
  </alias>

  <alias
   match="^[ ]*omni[ ]+verbose[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.verbose.set("%1")</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+commlog[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.commlog.set("%1")</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+backup[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.backup.set("%1")</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+backup[ ]+(create|delete|restore)[ ]+([^ ]+)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.backup.cli("%1", "%2")</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+backup[ ]+list[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.backup.list()</send>
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+backup[ ]+auto[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.backup.current()</send>
  </alias>
  
  <alias
   script="omni.reload"
   match="^[ ]*omni[ ]+reload[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  
  <alias
   script="omni.version"
   match="^[ ]*omni[ ]+version[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  
  <alias
   match="^[ ]*omni[ ]+help[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>omni.help.set("%1")</send>
  </alias>
  
  <alias
   script="omni.help.usage"
   match="^[ ]*omni(|[ ]+.*)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="1000"
  >
  </alias>

  <alias
   match="resetaard"
   enabled="y"
   sequence="100"
   ignore_case="y"
   script="omni.miniwin.reset.aard"
  >
  </alias>

</aliases>

<!--  Variables  -->


<!--  Script  -->


<script>
<![CDATA[


--[[
----------------------------------------------------------------------------------------------------------
Table of Contents
----------------------------------------------------------------------------------------------------------

Dependencies and Globals
------------------------

MUSH callbacks
--------------
function OnPluginInstall()
function OnPluginClose()
function OnPluginConnect()
function OnPluginDisconnect()
function OnPluginEnable()
function OnPluginDisable()
function OnPluginSaveState()
function OnPluginBroadcast(msg, id, name, text)

Plugin init/de-init
-------------------
function omni.reset()
function omni.init()
function omni.fini()

Scanning options
----------------
function omni.scan.init()
function omni.scan.fini()
function omni.scan.reset()
function omni.scan.processCLI(mode, seconds)
function omni.scan.requestCR(mode)

Scan: study
-----------
function omni.scan.study.reset()
function omni.scan.study.process(doReport)
function omni.scan.study.processCR()
function omni.scan.study.trigStartFn()
function omni.scan.study.trigEntryFn(who, what)

Scan: consider
--------------
function omni.scan.consider.reset()
function omni.scan.consider.process(doReport)
function omni.scan.consider.processCR()
function omni.scan.consider.trigEntryFn(name, line, wildcards)
function omni.scan.consider.sync(glanceTable)

Scan: glance
------------
function omni.scan.glance.reset()
function omni.scan.glance.getShortFlags(entry)
function omni.scan.glance.gagExit()
function omni.scan.glance.startRoomObjs()
function omni.scan.glance.endRoomObjs()
function omni.scan.glance.startRoomChars()
function omni.scan.glance.endRoomChars()
function omni.scan.glance.charLineTrigFn)
function omni.scan.glance.process(doReport)
function omni.scan.glance.processCR()
function omni.scan.glance.complete()

Scan: who
---------
function omni.scan.who.reset()
function omni.scan.who.process(mode)
function omni.scan.who.processCR()
function omni.scan.who.start()
function omni.scan.who.mid(line)
function omni.scan.who.stop(doAbort)

Scan: swho
----------
function omni.scan.swho.reset(mode)
function omni.scan.swho.process(mode)
function omni.scan.swho.processCR()
function omni.scan.swho.start(line)
function omni.scan.swho.mid(line)
function omni.scan.swho.stop(doAbort)

Scan: wrappers
--------------
function omni.scan.room.process(doReport)
function omni.scan.players.process(doReport)
function omni.scan.players.processCR()

Scan: timers
------------
function omni.scan.timer.set(mode, period)
function omni.scan.timer.get(mode)
function omni.scan.timer.isEnabled(mode)
function omni.scan.timer.init()
function omni.scan.timer.fini()
function omni.scan.setTimer(mode, periodSec)
function omni.scan.timer.process(mode)
function omni.scan.timer.addOneShot(name, periodSec, fnName)
function omni.scan.timer.area.process()
function omni.scan.timer.players.process()
function omni.scan.timer.general(mode)
function omni.scan.timer.area.trigger()
function omni.scan.timer.players.trigger()
function omni.scan.timer.room.trigger()
function omni.scan.timer.room.init()
function omni.scan.timer.room.fini()
function omni.scan.timer.room.fn()
function omni.scan.timer.room.fnCR()

Scan: misc
----------
function omni.clans.init()
function omni.clans.strip(line)
function omni.getKeyword(who)

Character (mob) database
-----------------------------------
function omni.charsdb.clean()
function omni.charsdb.reset()
function omni.charsdb.set(nameKey, nameShort, nameLong, area, room, charType,
                          popularity, align, levelFloor, levelCeiling, resists)
function omni.charsdb.select(sqlStr)
function omni.charsdb.isPlayer(name)
function omni.charsdb.isGroupie(name)
function omni.charsdb.room.import()
function omni.charsdb.room.set(area, room, roomId)

Plugin enable/disable
---------------------
function omni.set(mode)
function omni.get()
function omni.isEnabled(mode)

Discover mode enable/disable
----------------------------
function omni.discover.cli(mode)
function omni.discover.set(mode)
function omni.discover.get()
function omni.discover.isEnabled(mode)

Room and area status reporting
------------------------------
function omni.report.cli(switch, mode)
function omni.report.set(switch, mode)
function omni.report.get(switch)
function omni.report.isEnabled(mode)
function omni.report.getColor(nameKey)
function omni.report.sortByStats(players)
function omni.report.chars(target)

Alias options
-------------
function omni.alias.save()
function omni.alias.load()
function omni.alias.reset()
function omni.alias.create(aliasName, commandStr, queryStr, isTemporary)
function omni.alias.delete(aliasName)
function omni.alias.display(aliasName)
function omni.alias.command(command, query)
function omni.alias.execute(aliasName, targetNum, command, query)
function omni.alias.executeCR()
function omni.query.room(queryTable, preferredTarget)

Commlog options
---------------
function omni.commlog.set(enable)
function omni.commlog.get()
function omni.commlog.isEnabled()

Verbose options
---------------
function omni.verbose.set(enable)
function omni.verbose.get()
function omni.verbose.isEnabled()

Help options
------------
function omni.help.set(enable)
function omni.help.get()
function omni.help.isEnabled()
function omni.help.usage()

Plugin info
-----------
function omni.version()
function omni.options.report()

Backup options
--------------
omni.backup.init
omni.backup.fini
omni.backup.cli()
omni.backup.set(enable)
omni.backup.get()
omni.backup.isEnabled(enable)
omni.backup.getBackups()
omni.backup.getFile(name)
omni.backup.current()
omni.backup.list()
omni.backup.create(name)
omni.backup.delete(name, isQuiet)
omni.backup.restore(name)

Core helper functions
---------------------
function omni.printFormat(msg)
function omni.printColors(msg)
function omni.print(msg)
function omni.error(msg)
function omni.getRoom()
function omni.getName()
function omni.inCombat()
function omni.allowBackgroundSend()
function omni.isActive()
function omni.inSafeRoom()
function omni.commLog(msg)
function omni.isWordInString(word, field)
function omni.capitalize(word)
function omni.getTime()
function omni.reload()
function omni.retval.getString(retval)

Prompt enable/disable options
-----------------------------
function omni.prompt.init()
function omni.prompt.fini()
function omni.prompt.reset()
function omni.prompt.enable()
function omni.prompt.disable()

Miniwin!!!
----------
function omni.miniwin.init()
function omni.miniwin.fini()
function omni.miniwin.reset.all()
function omni.miniwin.reset.defaults()
function omni.miniwin.reset.aard()
function omni.miniwin.save()
function omni.miniwin.load()
function omni.miniwin.set(enable)
function omni.miniwin.get()
function omni.miniwin.isEnabled()
function omni.miniwin.show()
function omni.miniwin.hide()

function omni.miniwin.font.add()
function omni.miniwin.font.update(loc, name, size)

function omni.miniwin.report.scrollwheel(flags, hotspotId)
function omni.miniwin.report.menu.string(trect)
function omni.miniwin.report.menu.select(startNum, endNum, selectNum)
function omni.miniwin.report.menu.result(sender, hotspotId, result)
function omni.miniwin.report.calc()

function omni.miniwin.write(msg, doClear)

function omni.miniwin.mouseOver(flags, hotspotId)
function omni.miniwin.mouseOverCancel(flags, hotspotId)
function omni.miniwin.mouseDown(flags, hotspotId)
function omni.miniwin.mouseDownCancel(flags, hotspotId)
function omni.miniwin.mouseUp(flags, hotspotId)

function omni.miniwin.resize.moveCallback()
function omni.miniwin.resize.releaseCallback()

function omni.miniwin.optionbar.calc()
function omni.miniwin.optionbar.draw()

function omni.miniwin.summarybar.calc()
function omni.miniwin.summarybar.draw()

function omni.miniwin.titlebar.draw()

function omni.miniwin.draw()

function omni.miniwin.mode.set(mode)
function omni.miniwin.mode.get()
function omni.miniwin.mode.isEnabled(mode)

function omni.miniwin.titlebar.set(enable)
function omni.miniwin.titlebar.get()
function omni.miniwin.titlebar.isEnabled()

function omni.miniwin.optionbar.set(enable)
function omni.miniwin.optionbar.get()
function omni.miniwin.optionbar.isEnabled()

function omni.miniwin.summarybar.set(enable)
function omni.miniwin.summarybar.get()
function omni.miniwin.summarybar.isEnabled()

function omni.miniwin.graph.init()
function omni.miniwin.graph.fini()
function omni.miniwin.graph.reset()
function omni.miniwin.graph.draw(left, top, right, bottom)
function omni.miniwin.graph.calc()
function omni.miniwin.graph.categorize()
function omni.miniwin.graph.getAlignColor(align)

function omni.miniwin.graph.group.draw(startX, startY, width)
function omni.miniwin.graph.group.drawEntry(x, y, entry, info, isBright, isArea)
function omni.miniwin.graph.group.area.calc()
function omni.miniwin.graph.group.area.draw(startX, startY,
function omni.miniwin.graph.group.narea.calc()
function omni.miniwin.graph.group.narea.draw(startX, startY, level, name, nameColor, hp, hpMax)

function omni.miniwin.graph.ngroup.draw(startX, startY, width)
function omni.miniwin.graph.ngroup.drawEntry(x, y, entry, isRoom)
function omni.miniwin.graph.ngroup.area.calc()
function omni.miniwin.graph.ngroup.area.draw(startX, startY, ...)
function omni.miniwin.graph.ngroup.mob.calc()
function omni.miniwin.graph.ngroup.mob.draw(startX, startY, ...)

--]]


----------------------------------------------------------------------------------------------------------
-- Dependencies
----------------------------------------------------------------------------------------------------------

require "gmcphelper"
require "wait"
require "check"
require "tprint"

dofile(GetInfo(60) .. "aardwolf_colors.lua")


----------------------------------------------------------------------------------------------------------
-- Global vars and tables
----------------------------------------------------------------------------------------------------------

omni      = {}
omni.name = "OMNI"
omni.ver  = "0.8.0039"
omni.gmcp = {}

omni.plugins      = {}
omni.plugins.gmcp = "3e7dedbe37e44942dd46d264"
omni.plugins.dinv = "88c86ea252fc1918556df9fe"


----------------------------------------------------------------------------------------------------------
-- MUSH callbacks and hooks
----------------------------------------------------------------------------------------------------------

function OnPluginInstall()
  omni.init()
end -- OnPluginInstall


function OnPluginClose()
  omni.fini()
end -- OnPluginClose


function OnPluginConnect()
  --omni.print("OnPluginConnect!")

  if (not omni.isInitialized) then
    omni.init()
  end -- if
end -- OnPluginConnect


function OnPluginDisconnect()
  --omni.print("OnPluginDisconnect!")

  omni.fini()
end -- OnPluginDisconnect


function OnPluginEnable()
  omni.print("@GENABLED@W")
end -- OnPluginEnable


function OnPluginDisable()
  omni.print("@RENABLED@W")
end -- OnPluginDisable


function OnPluginSaveState()
  omni.miniwin.save()
end -- OnPluginSaveState


function OnPluginBroadcast(msg, id, name, text)
  if (id == omni.plugins.gmcp) then -- message from the GMCP Handler

    if (not omni.gmcp.isInitialized) then
      -- We want info on our group...
      Send_GMCP_Packet("group on")
      Send_GMCP_Packet("request group")
      omni.gmcp.isInitialized = true
    end -- if

    if (text == "room.info") then
      local newRoom = tonumber(gmcp("room.info.num") or "-1")
      local newZone = gmcp("room.info.zone")

      if (omni.gmcp.currentRoom ~= newRoom) then
        omni.scan.reset()
        omni.gmcp.currentRoom = newRoom
        omni.discover.room = 0
      end -- if

      if (omni.gmcp.currentZone ~= newZone) then
        omni.gmcp.currentZone = newZone
        omni.scan.swho.reset("area")

        -- Restart any scan timers when we hit a new zone.  This technically shouldn't be required but
        -- it gives us a way to semi-recover if someone disconnects at the wrong time and "loses" a timer.
        -- If we detect that a scan timer is missing, simply restart it.
        for timerName in omni.scan.timer.list:gmatch("%S+") do
          if (omni.scan.timer.isEnabled(timerName)) then
            local status = GetTimer(omni.scan.timer[timerName].name)
            if (status ~= eOK) then
              omni.scan.timer.process(timerName)
            end -- if
          end -- if
        end -- for

      end -- if
    end -- if

    if (text == "char.status") then
      -- If we are in combat and received a gmcp update, let the room timer know it probably wants to refresh
      if omni.inCombat() then
        omni.scan.timer.room.requested = true
        omni.doOocScan = true

      -- Similarly, if we ever break out of combat, do an "out-of-combat" scan to catch anything we missed
      elseif (omni.doOocScan) then
        omni.scan.timer.room.requested = true
        omni.doOocScan = false
      end -- if

      local charState = gmcp("char.status.state")
      if (not omni.isInitialized) then
        -- We aren't initialized yet.  If we are in the active, combat, sleeping, or resting/sitting states
        -- then we must be logged in and able to send commands to aard.  In this case, send any commands
        -- required to fully init the plugin.
        if ((charState == "3") or (charState == "8") or (charState == "9") or (charState == "11")) then
          -- Ensure the proper tags are enabled
          omni.print("@WEnabling @croomchars@W and @croomobjs@W tags")
          SendNoEcho("tags roomchars on")
          SendNoEcho("tags roomobjs on")
          SendNoEcho("tags on")

          -- Check if dinv is present and, if so, use it to manage prompts
          local isDinvEnabled = GetPluginInfo(omni.plugins.dinv, 17)
          if (isDinvEnabled == true) then
            omni.prompt.dinv.isEnabled = true
          end -- if

          omni.isInitialized = true
        end -- if
      end -- if

      -- We don't want to start the timers or run background scans until the player has been active at least
      -- once.  This simplifies the init code since we can eliminate a lot of corner cases.
      if (not omni.activeInitialized) and omni.isActive() then
        omni.activeInitialized = true

        -- Init timers after we know that we have logged in.  We also give a few seconds so other plugins
        -- have a chance to initialize before we start doing commands in the background via timers.  We
        -- probably don't need that extra delay, but you never know what crazy stuff plugins may try when
        -- they start up and this gives us a little insurance. 
        if omni.isEnabled() then
          DoAfterSpecial(2, "omni.scan.timer.init()", sendto.script)
        end -- if

        -- Start with an initial player scan.  We wait a few seconds for things to settle in case other
        -- plugins are also initializing.  Waiting probably isn't required, but it shouldn't hurt and it
        -- may help if there is a misbehaving plugin fighting with omni.
        DoAfterSpecial(3, "omni scan players", sendto.execute)
      end -- if
    end -- if

    if (text == "comm.tick") then
      -- This is rather nasty, but gmcp won't provide your quest timer if you are outside of a group.
      -- The best you can do is snoop on quest messages on the comm channel and those won't be triggered
      -- unless we specifically request a message. So here we request a quest update every tick that we
      -- are not in a group.  It's not pretty, but it works...
      local group = gmcp("group")
      if (group == nil) or (group.count == nil) then
        Send_GMCP_Packet("request quest")
      end -- if
    end -- if

    if (text == "group") then
      omni.gmcp.group = gmcp("group")

      -- Redraw the graphic window (if it is enabled) whenever gmcp group info changes
      if omni.isInitialized and omni.miniwin.mode.isEnabled("graphic") then
        omni.miniwin.draw()
      end -- if
    end -- if
  end -- if
end -- OnPluginBroadcast


----------------------------------------------------------------------------------------------------------
-- Plugin init/de-init
----------------------------------------------------------------------------------------------------------

function omni.reset()
  omni.scan.reset()
end -- omni.reset


function omni.init()

  -- Display the helpfile when the plugin loads
  if omni.help.isEnabled() then
    omni.help.usage()
  end -- if

  -- Start with fresh room data
  omni.reset()

  omni.isInitialized      = false
  omni.activeInitialized  = false
  omni.doOocScan          = false
  omni.gmcp.isInitialized = false

  -- Start with fresh alias tables
  omni.alias.load()

  omni.scan.init()
  omni.clans.init()
  omni.prompt.init()
  omni.hitlist.init()
  omni.alias.init()
  omni.miniwin.init()
  omni.backup.init()

  -- Add triggers for roomchar and roomobj tags
  check (AddTriggerEx(omni.scan.glance.startRoomCharsName,
                      "^\\{roomchars\\}$",
                      "",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "",
                      "omni.scan.glance.startRoomChars",
                      sendto.script, 100))

  check (AddTriggerEx(omni.scan.glance.endRoomCharsName,
                      "^\\{/roomchars\\}$",
                      "",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "",
                      "omni.scan.glance.endRoomChars",
                      sendto.script, 100))

  check (AddTriggerEx(omni.scan.glance.startRoomObjsName,
                      "^\\{roomobjs\\}$",
                      "",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "",
                      "omni.scan.glance.startRoomObjs",
                      sendto.script, 100))

  check (AddTriggerEx(omni.scan.glance.endRoomObjsName,
                      "^\\{/roomobjs\\}$",
                      "",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "",
                      "omni.scan.glance.endRoomObjs",
                      sendto.script, 100))

  check (AddTriggerEx(omni.scan.sanc.onTrigName,
                      "^You are surrounded by a shimmering white aura of divine protection.$" ..
                      "|" .. "^Aardwolf Aura of Sanctuary begins floating around you.$"       ..
                      "|" .. "^Your body begins to glow with an inner light.$",
                      "omni.scan.sanc.isEnabled = true",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange,
                      0, "", "", sendto.script, 100))

  check (AddTriggerEx(omni.scan.sanc.offTrigName,
                      "^Your brilliant white aura of sanctuary shimmers and is gone.$" ..
                      "|" .. "^Aardwolf Aura of Sanctuary stops floating around you.$" ..
                      "|" .. "^Your biofeedback is no longer effective.$",
                      "omni.scan.sanc.isEnabled = false",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange,
                      0, "", "", sendto.script, 100))

  -- There are some parts of initialization that we can't do until we know that we are logged in and
  -- able to send commands to aard.  This forces GMCP to check our status and our broadcast monitor
  -- can snoop for this to perform the remainder of our initialization code.
  Send_GMCP_Packet("request char")

end -- omni.init


function omni.fini()
  omni.backup.fini()

  omni.isInitialized     = false
  omni.activeInitialized = false

  DeleteTrigger(omni.scan.glance.startRoomCharsName)
  DeleteTrigger(omni.scan.glance.endRoomCharsName)
  DeleteTrigger(omni.scan.glance.startRoomObjsName)
  DeleteTrigger(omni.scan.glance.endRoomObjsName)
  DeleteTrigger(omni.scan.sanc.onTrigName)
  DeleteTrigger(omni.scan.sanc.offTrigName)

  omni.reset()
  omni.miniwin.fini()
  omni.hitlist.fini()
  omni.prompt.fini()
  omni.scan.fini()
  omni.alias.fini()
end -- omni.fini


----------------------------------------------------------------------------------------------------------
-- Scan options
----------------------------------------------------------------------------------------------------------

omni.scan                  = {}

omni.scan.pending          = {}
omni.scan.unidentified     = "*"

omni.scan.sanc             = {}
omni.scan.sanc.isEnabled   = false
omni.scan.sanc.onTrigName  = "omniScanSancOnTrig"
omni.scan.sanc.offTrigName = "omniScanSancOffTrig"


function omni.scan.init()
  omni.scan.studyPkg    = nil
  omni.scan.considerPkg = nil
  omni.scan.glancePkg   = nil
  omni.scan.whoPkg      = nil
  omni.scan.swhoPkg     = nil
  omni.scan.playersPkg  = nil
end -- omni.scan.init


function omni.scan.fini()
  omni.scan.timer.fini()
end -- omni.scan.fini


function omni.scan.reset()
  omni.scan.table = {}
end -- omni.scan.reset


function omni.scan.processCLI(mode, seconds)

  if (seconds == nil) or (seconds == "") then
    omni.print("@WPerforming @c" .. (mode or "nil") .. "@W scan")
  elseif (tonumber(seconds or "") ~= 0) then
    omni.print("@WScheduled @c" .. (mode or "nil") .. "@W scan every @C" .. seconds .. "@W seconds")
  end -- if

  if (seconds ~= nil) then
    omni.scan.setTimer(mode, seconds)
  elseif (mode == "mud") or (mode == "area") then
    omni.scan.swho.process(mode)
  elseif (mode == "glance") then
    omni.scan.glance.process(true)
  elseif (mode == "room") then
    omni.scan.room.process(true)
  elseif (mode == "study") then
    omni.scan.study.process(true)
  elseif (mode == "consider") then
    omni.scan.consider.process(true)
  elseif (mode == "who") then
    omni.scan.who.process(true)
  elseif (mode == "players") then
    omni.scan.players.process(true)
  else
    omni.error("omni.scan.processCLI: Invalid mode \"" .. (mode or "nil") .. "\"")
  end -- if

end -- omni.scan.processCLI


function omni.scan.requestCR(mode) -- can only be called from another co-routine
  if (mode ~= "glance") and (mode ~= "study") and (mode ~= "consider") then
    omni.error("omni.scan.requestCR: invalid mode \"" .. (mode or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  -- If a request is already in progress, queue up our request and return.  Whomever is running the
  -- current request is responsible for popping the queue and handling any pending scan requests.
  if (omni.scan.glance.inProgress) then
    table.insert(omni.scan.pending, mode)
    --omni.print("omni.scan.requestCR: Queuing mode \"" .. mode .. "\"")
    return DRL_RET_SUCCESS
  end -- if

  omni.scan.glance.inProgress = true
  omni.prompt.disable()

  local roomName = strip_colours(gmcp("room.info.name") or "")

  -- If a room name has "*" in it, then we need to escape it so we can match the literal
  roomName = string.gsub(roomName, "*", "\\*")

  check (AddTriggerEx(omni.scan.glance.roomNameTrigName,
                      "^" .. roomName .. ".*$",
                      "omni.scan.glance.gagExit()",
                      drlTriggerFlagsBaseline + trigger_flag.OneShot + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 100))

  if (mode ~= "glance") then
    SendNoEcho(mode)
  end -- if
  SendNoEcho("glance")

  local fence = "{/roomchars}"
  local regex = "^"
                .. fence
                .. "|You dream about being able to glance."
                .. "|.*GUST STATUES FACING SOUTH, WEST, NORTH, EAST"
                .. "|It.s far too dark for you to see what.s in this room!"
                .. "|You can.t see anything - you are temporarily blinded."
                .. "$" 

  line, wildcards = wait.regexp(regex, omni.scan.glance.timeout, trigger_flag.OmitFromOutput)
  if (line == nil) or (line == "") then
    omni.print("Timed out waiting for omni.scan.requestCR (" .. omni.scan.glance.timeout .. "s)")
    retval = DRL_RET_TIMEOUT
  end -- if

  omni.prompt.enable()

  DeleteTrigger(omni.scan.glance.roomNameTrigName)
  DeleteTrigger(omni.scan.glance.roomExitTrigName)

  omni.scan.pending.glance    = false
  omni.scan.pending[mode]     = false
  omni.scan.glance.inProgress = false

  local popMode = table.remove(omni.scan.pending)
  if (popMode ~= nil) then
    --omni.print("omni.scan.requestCR: Popping mode \"" .. popMode .. "\"")
    return omni.scan.requestCR(popMode)
  else
    return retval
  end -- if

end -- omni.scan.requestCR


----------------------------------------------------------------------------------------------------------
-- Study support
----------------------------------------------------------------------------------------------------------

omni.scan.study = {}

omni.scan.study.startTrig = "omniScanStudyStartTrigger"
omni.scan.study.entryTrig = "omniScanStudyEntryTrigger"
omni.scan.study.timeout   = 10


function omni.scan.study.reset()
  omni.scan.study.table      = {}
  omni.scan.study.startRoom  = 0 
end -- omni.scan.study.reset


omni.scan.studyPkg = nil
function omni.scan.study.process(doReport)
  local retval = DRL_RET_SUCCESS

  if (omni.scan.studyPkg ~= nil) then
    --omni.print("omni.scan.study.process: Skipping request because another request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.studyPkg          = {}
  omni.scan.studyPkg.doReport = doReport

  -- If we aren't in a co-routine already, start one for the request
  if (coroutine.running() == nil) then
    wait.make(omni.scan.study.processCR)
  else
    -- We are being called from a co-routine so we can make a direct call to the co-routine
    retval = omni.scan.study.processCR()
  end -- if

  return retval
end -- omni.scan.study.process


function omni.scan.study.processCR()
  local retval = DRL_RET_SUCCESS

  if (omni.scan.studyPkg == nil) then
    omni.error("omni.scan.study.processCR: package parameter is nil!")
    return DRL_RET_INTERNAL_ERROR
  end -- if

  check (AddTriggerEx(omni.scan.study.startTrig,
                      "^You quickly evaluate the health of all present.$",
                      "omni.scan.study.trigStartFn()",
                      drlTriggerFlagsBaseline + trigger_flag.OneShot + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 100))

  omni.scan.study.reset()
  omni.scan.study.startRoom = omni.getRoom()

  omni.scan.pending.study = true
  omni.scan.requestCR("study")

  local totTime = 0
  local timeout = 10
  local periodSec = 0.1
  local retval = DRL_RET_TIMEOUT
  while (totTime <= timeout) do
    -- If the user disconnected and we aren't initialized, return immediately and rely on the init/fini code
    -- to clean everything up
    if (omni.isInitialized == false) then
      return DRL_RET_UNINITIALIZED  
    end -- if

    if (not omni.scan.pending.study) then
      retval = DRL_RET_SUCCESS
      break
    end -- if

    wait.time(periodSec)
    totTime = totTime + periodSec
  end -- while

  if (retval == DRL_RET_TIMEOUT) then
    omni.print("omni.scan.study.processCR: Timed out waiting for request to complete")
    omni.scan.pending.study = false
  end -- if

  -- Cleanup triggers.  The start trigger may still be around if something went wrong (e.g., the study
  -- request timed out because the user was stacked).  The entry trigger only is disabled when we see
  -- our fence and know we won't be getting more entries for this study request.
  DeleteTrigger(omni.scan.study.startTrig)
  DeleteTrigger(omni.scan.study.entryTrig)

  if (omni.scan.studyPkg.doReport) then
    omni.report.chars()
  end -- if

  omni.scan.studyPkg = nil

  omni.scan.timer.room.pending = false

  return retval
end -- omni.scan.study.processCR


omni.scan.study.msgs = {}
omni.scan.study.msgs["is in perfect health"]                     = 100
omni.scan.study.msgs["are in perfect health"]                    = 100
omni.scan.study.msgs["has a few minor scratches"]                = 95
omni.scan.study.msgs["have a few minor scratches"]               = 95
omni.scan.study.msgs["is showing a few grazes"]                  = 90
omni.scan.study.msgs["are showing a few grazes"]                 = 90
omni.scan.study.msgs["is bleeding lightly"]                      = 80
omni.scan.study.msgs["are bleeding lightly"]                     = 80
omni.scan.study.msgs["has some small wounds and bruises"]        = 70
omni.scan.study.msgs["have some small wounds and bruises"]       = 70
omni.scan.study.msgs["is showing a few battle scars"]            = 60
omni.scan.study.msgs["are showing a few battle scars"]           = 60
omni.scan.study.msgs["has quite a few wounds"]                   = 50
omni.scan.study.msgs["have quite a few wounds"]                  = 50
omni.scan.study.msgs["has some big nasty wounds and scratches"]  = 40
omni.scan.study.msgs["have some big nasty wounds and scratches"] = 40
omni.scan.study.msgs["has some very nasty wounds"]               = 30
omni.scan.study.msgs["have some very nasty wounds"]              = 30
omni.scan.study.msgs["needs a hospital"]                         = 20
omni.scan.study.msgs["need a hospital"]                          = 20
omni.scan.study.msgs["is gravely injured"]                       = 10
omni.scan.study.msgs["are gravely injured"]                      = 10
omni.scan.study.msgs["is at death's door"]                       = 5


function omni.scan.study.trigStartFn()
  --omni.print("In study trigger start")

  local trigRegex = "^(.+?) ("
  for key, val in pairs(omni.scan.study.msgs) do
    trigRegex = trigRegex .. key .. "|"
  end -- for
  trigRegex = trigRegex .. "are at death.s door"
  trigRegex = trigRegex .. ").$"

  check (AddTriggerEx(omni.scan.study.entryTrig,
                      trigRegex,
                      "omni.scan.study.trigEntryFn(\"%1\", \"%2\")",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 100))

end -- omni.scan.study.trigStartFn


function omni.scan.study.trigEntryFn(who, what)
--  omni.print("who = \"" .. (who or "nil") .. "\"")
--  omni.print("what = \"" .. (what or "nil") .. "\"")

  -- We just want the hpPercent field from the study request.  However, study also reports hp for
  -- your char so there is an extra field here that is not in glance.  We include the keyword field
  -- in the study.table so that we can tell which entry is for you so that we can synch up the other
  -- character entries.
  table.insert(omni.scan.study.table, 
               { nameKey   = omni.getKeyword(who or "nil"),
                 hpPercent = omni.scan.study.msgs[what] or 0 } )

end -- omni.scan.study.trigEntryFn


----------------------------------------------------------------------------------------------------------
-- Consider support
----------------------------------------------------------------------------------------------------------

omni.scan.consider = {}

omni.scan.consider.entryTrig = "omniScanConsiderEntryTrigger"
omni.scan.consider.timeout   = 10


function omni.scan.consider.reset()
  omni.scan.consider.table       = {}
  omni.scan.consider.startRoom   = 0
end -- omni.scan.consider.reset


omni.scan.considerPkg = nil
function omni.scan.consider.process(doReport)
  if (omni.scan.considerPkg ~= nil) then
    --omni.print("omni.scan.consider.process: Skipping request because another request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.considerPkg          = {}
  omni.scan.considerPkg.doReport = doReport

  -- If we aren't in a co-routine already, start one for the request
  if (coroutine.running() == nil) then
    wait.make(omni.scan.consider.processCR)
  else
    -- We are being called from a co-routine so we can make a direct call to the co-routine
    retval = omni.scan.consider.processCR()
  end -- if

end -- omni.scan.consider.process


function omni.scan.consider.processCR()
  local retval = DRL_RET_SUCCESS

  if (omni.scan.considerPkg == nil) then
    omni.error("omni.scan.consider.processCR: package parameter is nil!")
    return DRL_RET_INTERNAL_ERROR
  end -- if

  local regex = "^(You see) (no one here but yourself).$|"                      ..
                "^(Strange) (forces prevent violence here).$|"                  ..
                "^.* (would not approve of you killing) (.*).$|"               ..
                "^.* (would smite you for killing) (.*).$|"                     ..
                "^(.*) (has already been challenged).$|"                        ..
                "^If you killed (.*), (who would serve) .* customers.$|"        ..
                "^(.*) (has divine protection).$|"                              ..
                "^.*You would stomp (.*) (into the ground).$|"                  ..
                "^(?:.*\\) )?(.*) (would be easy), but is it even worth.*$|"    ..
                "^.*No Problem. (.*) (is weak compared to you).$|"              ..
                "^(?:.*\\) )?(.*) (looks a little worried) about the idea.$|"   ..
                "^(?:.*\\) )?(.*) (should be a fair fight).$|"                  ..
                "^(?:.*\\) )?(.*) (snickers nervously).$|"                      ..
                "^(?:.*\\) )?(.*) (chuckles at the thought).*$|"                ..
                "^.*Best run away from (.*) (while you can).$|"                 ..
                "^.*Challenging (.*) would be either (very brave).*$|"          ..
                "^(?:.*\\) )?(.*) would (crush you like a bug).$|"              ..
                "^(?:.*\\) )?(.*) would (dance on your grave).$|"               ..
                "^(?:.*\\) )?(.*) says .(BEGONE FROM MY SIGHT) unworthy..$|"    ..
                "^.*You would be completely annihilated by (.*)(!)$"   

  check (AddTriggerEx(omni.scan.consider.entryTrig,
                      regex,
                      "",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "",
                      "omni.scan.consider.trigEntryFn",
                      sendto.script, 100))

  omni.scan.consider.reset()
  omni.scan.consider.startRoom = omni.getRoom()
  omni.scan.pending.consider = true
  omni.scan.requestCR("consider")

  local totTime = 0
  local timeout = 10
  local periodSec = 0.1
  local retval = DRL_RET_TIMEOUT
  while (totTime <= timeout) do
    -- If the user disconnected and we aren't initialized, return immediately and rely on the init/fini code
    -- to clean everything up
    if (omni.isInitialized == false) then
      return DRL_RET_UNINITIALIZED  
    end -- if

    if (not omni.scan.pending.consider) then
      retval = DRL_RET_SUCCESS
      break
    end -- if

    wait.time(periodSec)
    totTime = totTime + periodSec
  end -- while

  if (retval == DRL_RET_TIMEOUT) then
    omni.print("omni.scan.consider.processCR: Timed out waiting for request to complete")
    omni.scan.pending.consider = false
  end -- if

  -- Cleanup triggers.  The entry trigger only is disabled when we see our fence and know we won't
  -- be getting more entries for this consider request.
  DeleteTrigger(omni.scan.consider.entryTrig)

  if (omni.scan.considerPkg.doReport) then
    omni.print("Room discovery completed")
    --omni.report.chars()
  end -- if

  omni.scan.considerPkg = nil

  return retval
end -- omni.scan.consider.processCR


omni.scan.consider.msgs = {}
omni.scan.consider.msgs["has already been challenged"]      = { floor =    0, ceiling =    0 }
omni.scan.consider.msgs["has divine protection"]            = { floor = 9000, ceiling = 9000 }
omni.scan.consider.msgs["who would serve"]                  = { floor = 9000, ceiling = 9000 }
omni.scan.consider.msgs["would not approve of you killing"] = { floor = 9000, ceiling = 9000 }
omni.scan.consider.msgs["would smite you for killing"]      = { floor = 9000, ceiling = 9000 }
omni.scan.consider.msgs["into the ground"]                  = { floor = -200, ceiling =  -20 }
omni.scan.consider.msgs["would be easy"]                    = { floor =  -19, ceiling =  -10 }
omni.scan.consider.msgs["is weak compared to you"]          = { floor =   -9, ceiling =   -7 }
omni.scan.consider.msgs["looks a little worried"]           = { floor =   -4, ceiling =   -2 }
omni.scan.consider.msgs["should be a fair fight"]           = { floor =   -1, ceiling =    1 }
omni.scan.consider.msgs["snickers nervously"]               = { floor =    2, ceiling =    4 }
omni.scan.consider.msgs["chuckles at the thought"]          = { floor =    5, ceiling =    9 }
omni.scan.consider.msgs["while you can"]                    = { floor =   10, ceiling =   15 }
omni.scan.consider.msgs["very brave"]                       = { floor =   16, ceiling =   20 }
omni.scan.consider.msgs["crush you like a bug"]             = { floor =   21, ceiling =   30 }
omni.scan.consider.msgs["dance on your grave"]              = { floor =   31, ceiling =   40 }
omni.scan.consider.msgs["BEGONE FROM MY SIGHT"]             = { floor =   41, ceiling =   50 }
omni.scan.consider.msgs["!"]                                = { floor =   51, ceiling =  200 }


function omni.scan.consider.trigEntryFn(name, line, wildcards)

  if (wildcards == nil) then
    omni.error("omni.scan.consider.trigEntryFn: wildcards are nil!")
    return DRL_RET_INTERNAL_ERROR
  end -- if
  
  -- Some consider messages reverse the order of the wildcards.  Most have the form "[who] [what]" but
  -- some have the form "[what] [who]".
  local who, what
  local reverse1 = "would not approve of you killing"
  local reverse2 = "would smite you for killing"

  local wildcardsTrunc = {}
  for idx ,entry in ipairs(wildcards) do
    if (entry ~= nil) and (entry ~= "") then
      table.insert(wildcardsTrunc, entry)
    end -- if
  end -- for

  if (#wildcardsTrunc == 2) then
    if (wildcardsTrunc[1] == reverse1) or (wildcardsTrunc[1] == reverse2) then
      who  = wildcardsTrunc[2]
      what = wildcardsTrunc[1]
    else
      who  = wildcardsTrunc[1]
      what = wildcardsTrunc[2]
    end -- if
  else
    omni.error("omni.scan.consider.trigEntry: Invalid # of wildcards = " .. (#wildcardsTrunc or "nil"))
    return DRL_INTERNAL_ERROR
  end -- if

  -- Strip out single and double quotes from the short name to simplify SQL searches later
  who = string.gsub(who, "%\"", "")
  who = string.gsub(who, "%\'", "")

  --omni.print("line=\"" .. (line or "nil") .. "\"")
  --omni.print("who = \"" .. (who or "nil") .. "\"")
  --omni.print("what = \"" .. (what or "nil") .. "\"")

  -- If we can't consider the room then simply abort discover scan by returning early
  if (what == "forces prevent violence here") or
     (what == "no one here but yourself")     then
    return DRL_RET_SUCCESS
  end -- if

  local keyword = omni.getKeyword(who or "nil")
  if (keyword == "nil") then
    omni.error("omni.scan.consider.trigEntryFn: Failed to get keyword.  \nline=\"" .. (line or "nil") ..
               "\", who=\"" .. (who or "nil") .. "\", what=\"" .. (what or "nil") .. "\"")
    return DRL_INTERNAL_ERROR
  end -- if

  local msgEntry = omni.scan.consider.msgs[what]
  if (msgEntry == nil) then
    omni.error("omni.scan.consider.trigEntryFn: Unknown msg \"" .. (what or "nil") .. "\"")
    return DRL_INTERNAL_ERROR
  end -- if

  local isDivine = false
  if (msgEntry.floor >= 9000) then
    isDivine = true
  end -- if

  -- There are some divine mobs that we never want to consider because they do not show up in a glance and
  -- they prevent discovering that room.  If you can't interact with the mob anyway, we may as well not mess
  -- with it in our discovery.
  local room = omni.getRoom()
  if isDivine then
    -- FIXME: Add this to the DB?
    local skipRooms = "4416 4417 29246 30476 35075 35080 35057 35065 35085 35095 40096"

    -- add partroxis rooms in bulk
    for partroxisSucks=5764,5803 do
      skipRooms = skipRooms .. " " .. partroxisSucks
    end -- for

    for skipRoom in skipRooms:gmatch("%S+") do
      if (room == tonumber(skipRoom)) then
        return DRL_RET_SUCCESS
      end -- if
    end -- for
  end -- if

  local levelCurrent = tonumber(gmcp("char.status.level") or 0)

  table.insert(omni.scan.consider.table,
               { nameKey      = keyword,
                 nameShort    = who,
                 levelFloor   = levelCurrent + msgEntry.floor,
                 levelCeiling = levelCurrent + msgEntry.ceiling,
                 isPlayer     = omni.charsdb.isPlayer(keyword),
                 inGroup      = omni.charsdb.isGroupie(keyword),
                 isDivine     = isDivine
               })

end -- omni.scan.consider.trigEntryFn


function omni.scan.consider.sync(glanceTable)
  local considerSynced = false
  
  if (omni.scan.consider.table == nil) or (glanceTable == nil) or
     (omni.scan.consider.startRoom ~= omni.getRoom()) then
    return considerSynced
  end -- if

  -- Check if it syncs first by comparing the size of the consider table and glance table.  We don't see
  -- players in the consider table (they don't show up on consider) so we need to also track # of players
  -- to account for that discrepancy.
  --
  -- This loop is somewhat redundant with the loop below.  However, the 2nd loop actually modifies the
  -- glance table so we need to know if it syncs before we get to the point of modifying the glance table.
  local playerCount = 0
  for glanceIdx,glanceEntry in pairs(glanceTable) do
    if omni.charsdb.isPlayer(glanceEntry.nameLong) then
      playerCount = playerCount + 1
    end -- if
  end -- if

  if (#omni.scan.consider.table + playerCount == #glanceTable) then
    considerSynced = true

    -- If consider.table exists and synchronizes with the glanceTable, copy discovered fields into the glance.table
    local considerIdx = 1
    for glanceIdx,glanceEntry in pairs(glanceTable) do
      local considerEntry = omni.scan.consider.table[considerIdx]

      -- Track if this is a player
      if omni.charsdb.isPlayer(glanceEntry.nameLong) then
        glanceEntry.isPlayer = true
      end -- if

      -- We only sync non-player entries from the consider table to the glance table because the consider
      -- table doesn't include players.
      if (not glanceEntry.isPlayer) and (considerEntry ~= nil) then
        for key,val in pairs(considerEntry) do
          glanceEntry[key] = val
        end -- for
        considerIdx = considerIdx + 1
      end -- if

      -- Getting the char type takes a little calculation based on existing fields
      if (glanceEntry.isPlayer == true) then
        glanceEntry.charType = "player"
      elseif (glanceEntry.charmed  == true) or (glanceEntry.animated == true) then
        glanceEntry.charType = "pet"
      elseif (glanceEntry.isDivine == true) then
        glanceEntry.charType = "divine"
      else
        glanceEntry.charType = "mob"
      end -- if

      -- Getting align takes a little calculation too...
      if (glanceEntry.good == true) then
        glanceEntry.align = "good"
      elseif (glanceEntry.evil == true) then
        glanceEntry.align = "evil"
      else
        glanceEntry.align = "neutral"
      end -- if

    end -- for
  end -- if

  return considerSynced

end -- omni.scan.consider.sync


----------------------------------------------------------------------------------------------------------
-- Glance support
----------------------------------------------------------------------------------------------------------

omni.scan.glance                    = {}
omni.scan.glance.table              = {}
omni.scan.glance.inProgress         = false
omni.scan.glance.isSynched          = false
omni.scan.glance.timeout            = 10
omni.scan.glance.charLineTrigName   = "omniGlanceCharLineTrig"
omni.scan.glance.roomObjsTrigName   = "omniGlanceRoomObjsTrig"
omni.scan.glance.roomNameTrigName   = "omniGlanceRoomNameTrig"
omni.scan.glance.roomExitTrigName   = "omniGlanceRoomExitTrig"
omni.scan.glance.startRoomCharsName = "omniGlanceStartRoomCharsTrig"
omni.scan.glance.endRoomCharsName   = "omniGlanceEndRoomCharsTrig"
omni.scan.glance.startRoomObjsName  = "omniGlanceStartRoomObjsTrig"
omni.scan.glance.endRoomObjsName    = "omniGlanceEndRoomObjsTrig"

omni.scan.glance.flagArray = {}
omni.scan.glance.flagArray["(Animated)"]    = { animated = true }
-- Note: The (A) flag is used for both "animated" and "aimed".  Fortunately, we can distinguish them
--       by their colors.  The room scan trigger automagically converts (A) to (Animated) if it has
--       the color for animated mobs.
omni.scan.glance.flagArray["(Angry)"]       = { angry    = true }
omni.scan.glance.flagArray["(Charmed)"]     = { charmed  = true }
omni.scan.glance.flagArray["(C)"]           = { charmed  = true }
omni.scan.glance.flagArray["(Diseased)"]    = { diseased = true }
omni.scan.glance.flagArray["(D)"]           = { diseased = true }
omni.scan.glance.flagArray["(GoldenAura)"]  = { good     = true }
omni.scan.glance.flagArray["(G)"]           = { good     = true }
omni.scan.glance.flagArray["(Hidden)"]      = { hidden   = true }
omni.scan.glance.flagArray["(H)"]           = { hidden   = true }
omni.scan.glance.flagArray["(Invis)"]       = { invis    = true }
omni.scan.glance.flagArray["(I)"]           = { invis    = true }
omni.scan.glance.flagArray["(Marked)"]      = { marked   = true }
omni.scan.glance.flagArray["(X)"]           = { marked   = true }
omni.scan.glance.flagArray["(RedAura)"]     = { evil     = true }
omni.scan.glance.flagArray["(R)"]           = { evil     = true }
omni.scan.glance.flagArray["(Stealth)"]     = { stealth  = true }
omni.scan.glance.flagArray["(S)"]           = { stealth  = true }
omni.scan.glance.flagArray["(Translucent)"] = { passdoor = true }
omni.scan.glance.flagArray["(T)"]           = { passdoor = true }
omni.scan.glance.flagArray["(Undead)"]      = { undead   = true }
omni.scan.glance.flagArray["(U)"]           = { undead   = true }
omni.scan.glance.flagArray["(WhiteAura)"]   = { sanc     = true }
omni.scan.glance.flagArray["(W)"]           = { sanc     = true }
omni.scan.glance.flagArray["(Wounded)"]     = { wounded  = true }
omni.scan.glance.flagArray["(A)"]           = { aimed    = true }
omni.scan.glance.flagArray["(Aimed)"]       = { aimed    = true }
omni.scan.glance.flagArray["(P)"]           = { player   = true }
omni.scan.glance.flagArray["(Player)"]      = { player   = true }
omni.scan.glance.flagArray["(HARDCORE)"]    = { hardcore = true }
omni.scan.glance.flagArray["(RAIDER)"]      = { raider   = true }
omni.scan.glance.flagArray["(TRAITOR)"]     = { traitor  = true }
omni.scan.glance.flagArray["(WANTED)"]      = { wanted   = true }
omni.scan.glance.flagArray["(OPK)"]         = { opk      = true }
omni.scan.glance.flagArray["[AFK]"]         = { afk      = true }
omni.scan.glance.flagArray["(Linkdead)"]    = { linkdead = true }

omni.scan.glance.flagShort          = {}
omni.scan.glance.flagShort.good     = "@yG@w"
omni.scan.glance.flagShort.evil     = "@rR@w"
omni.scan.glance.flagShort.sanc     = "@WW@w"
omni.scan.glance.flagShort.invis    = "@wI@w"
omni.scan.glance.flagShort.hidden   = "@wH@w"
omni.scan.glance.flagShort.diseased = "@BD@w"
omni.scan.glance.flagShort.animated = "@MA@w"
omni.scan.glance.flagShort.charmed  = "@CC@w"
omni.scan.glance.flagShort.marked   = "@DX@w"
omni.scan.glance.flagShort.stealth  = "@cS@w"
omni.scan.glance.flagShort.passdoor = "@WT@w"
omni.scan.glance.flagShort.undead   = "@RU@w"


function omni.scan.glance.reset()
  omni.scan.glance.table       = {}
  omni.scan.glance.charCounter = {}
end -- omni.scan.glance.reset


function omni.scan.glance.getShortFlags(entry)
  local flagStr = ""

  if (entry == nil) then
    omni.error("omni.scan.glance.getShortFlags: entry parameter is missing")
    return flagStr
  end -- if

--  local orderedFlags = "good evil sanc invis hidden diseased animated charmed"
  local orderedFlags = "sanc"

  for flag in orderedFlags:gmatch("%S+") do
    if (entry[flag] == true) then
      flagStr = flagStr .. omni.scan.glance.flagShort[flag]
    else
      flagStr = flagStr .. " "
    end -- if
  end -- for

  return flagStr
end -- omni.scan.glance.getShortFlags


function omni.scan.glance.gagExit()

  check (AddTriggerEx(omni.scan.glance.roomExitTrigName,
                      "^(\\[ Exits: .* \\]|[ ]+|)$",
                      "",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.NoChange,
                      0, "", "", sendto.script, 100))

end -- omni.scan.glance.gagExit


function omni.scan.glance.startRoomObjs()

  -- Gag room objects if we are in the middle of an omni glance
  if (omni.scan.glance.inProgress) then
    check (AddTriggerEx(omni.scan.glance.roomObjsTrigName,
                        "(^.*$)",
                        "",
                        drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                        custom_colour.Custom11,
                        0, "", "", sendto.script, 100))
  end -- if

end -- omni.scan.glance.startRoomObjs


function omni.scan.glance.endRoomObjs()

  -- Ensure gag for room objects is removed (if it exists)
  DeleteTrigger(omni.scan.glance.roomObjsTrigName)

end -- omni.scan.glance.endRoomObjs


function omni.scan.glance.startRoomChars()

  local flags = drlTriggerFlagsBaseline
  if (omni.scan.glance.inProgress) then
    flags = flags + trigger_flag.OmitFromOutput
  end -- if

  omni.scan.glance.reset()

  check (AddTriggerEx(omni.scan.glance.charLineTrigName,
                      "(^.*$)",
                      "", flags, custom_colour.NoChange, 0, "",
                      "omni.scan.glance.charLineTrigFn", sendto.script, 100))


end -- omni.scan.glance.startRoomChars


function omni.scan.glance.endRoomChars()
  DeleteTrigger(omni.scan.glance.charLineTrigName)

  if omni.isEnabled() then
    -- We just finished a glance so clear out any glances still pending
    omni.scan.timer.room.requested = false
    omni.scan.timer.room.pending   = false

    omni.scan.glance.complete()
  end -- if
end -- omni.scan.glance.endRoomChars


function omni.scan.glance.charLineTrigFn(name, line, wildcards, styles)

  if (line == "{/roomchars}") then
    return
  end -- if

  -- If no chars were detected, we're done!
  if (line == "") then
    return
  end -- if

  if (line == nil) then
    omni.error("omni.scan.glance.charLineTrigFn: Missing line parameter")
    return
  end -- if

  local c14nLine = line

  -- Aard uses (A) for both animated and aimed mobs :(  As a result, colors are the only way to
  -- distinguish between mobs you can't attack (a pet) and mobs you currently are attacking (aimed).
  for _,style in ipairs(styles) do
    if ((style.text == "(A)") or (style.test == " (A)") or (style.text == "(A) ")) and
       (style.textcolour == 16711935) then
      c14nLine = string.gsub(c14nLine, "%(C%)%(A%)", "%(C%)%(Animated%)")
      break
    end -- if
  end -- if

  c14nLine = string.gsub(c14nLine, "Golden Aura", "GoldenAura")
  c14nLine = string.gsub(c14nLine, "Red Aura",    "RedAura")
  c14nLine = string.gsub(c14nLine, "White Aura",  "WhiteAura")

  -- It's possible the user is in "shortflags" mode.  In that case, we need to add spaces between
  -- the flags.  For example, "(G)(W)" would become "(G) (W)" so that we can parse flags normally.
  local shortFlags = string.match(c14nLine, "^(%(.*%)) ") or ""
  local spacedFlags = string.gsub(shortFlags, "%)%(", "%) %(") or ""
  shortFlags = string.gsub(shortFlags, "%)", "%%%)")
  shortFlags = string.gsub(shortFlags, "%(", "%%%(")
  spacedFlags = string.gsub(spacedFlags, "%)", "%%%)")
  spacedFlags = string.gsub(spacedFlags, "%(", "%%%(")
  c14nLine = string.gsub(c14nLine, "^" .. shortFlags, spacedFlags)

  local charEntry    = {}
  local charPrefix   = ""
  for element in c14nLine:gmatch("%S+") do
    if (omni.scan.glance.flagArray[element] == nil) then
      break
    end -- if

    for flagKey, flagVal in pairs(omni.scan.glance.flagArray[element]) do
      charEntry[flagKey] = flagVal
    end -- for

    if (charPrefix == "") then
      charPrefix = element
    else
      charPrefix = charPrefix .. " " .. element
    end -- if
  end -- for   
  local prefixLen = 0
  if (charPrefix ~= "") then
    prefixLen = string.len(charPrefix) + 2
  end -- if
  charEntry.nameLong = string.sub(c14nLine, prefixLen)

  -- Strip out color codes, single quotes, and double quotes from names to simplify things
  charEntry.nameLong = strip_colours(charEntry.nameLong)
  charEntry.nameLong = string.gsub(charEntry.nameLong, "%\"", "")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "%\'", "")

  if string.match(charEntry.nameLong, " %[QUEST%]$") then
    charEntry.isQuest = true
  else
    charEntry.isQuest = false
  end -- if
  charEntry.nameLong = string.gsub(charEntry.nameLong, " %[QUEST%]$", "")

  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is here%.$", ".")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is resting here%.$", ".")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is sitting here%.$", ".")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is sleeping here%.$", ".")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is sleeping on .*%.$", ".")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is sleeping in a trivia sleeping bag%.$", ".")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]*$", "")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]*.$", ".")

  charEntry.target = string.match(charEntry.nameLong, "is fighting (.*)%.$")
  if (charEntry.target == nil) or (charEntry.target == "") then
    charEntry.target = string.match(charEntry.nameLong, "is trying to KILL (.*).$")
  end -- if

  if (charEntry.target == "YOU") then
    charEntry.target = gmcp("char.base.name")
  end -- if

  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is fighting (.*)%.", ".")
  charEntry.nameLong = string.gsub(charEntry.nameLong, "[ ]+is trying to KILL (.*).", ".")

  -- Some mobs (e.g., "Something" mob that is part of the Cataclysm AQ) don't have a name
  if (charEntry.nameLong == "") then
    charEntry.nameLong = "NoName"
  end -- if

  charEntry.area     = gmcp("room.info.zone") or "nil"
  charEntry.room     = omni.getRoom()

  table.insert(omni.scan.glance.table, charEntry)

end -- omni.scan.glance.charLineTrigFn


omni.scan.glancePkg = nil
function omni.scan.glance.process(doReport)
  local retval = DRL_RET_SUCCESS

  if (omni.scan.glancePkg ~= nil) then
    --omni.print("omni.scan.glance.process: Skipping request because another request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.glancePkg          = {}
  omni.scan.glancePkg.doReport = doReport

  -- If we aren't in a co-routine already, start one for the request
  if (coroutine.running() == nil) then
    wait.make(omni.scan.glance.processCR)
  else
    -- We are being called from a co-routine so we can make a direct call to the co-routine
    retval = omni.scan.glance.processCR()
  end -- if

  return retval

end -- omni.scan.glance.process


function omni.scan.glance.processCR()

  omni.scan.pending.glance = true
  omni.scan.requestCR("glance")

  local totTime = 0
  local timeout = 10
  local periodSec = 0.1
  local retval = DRL_RET_TIMEOUT
  while (totTime <= timeout) do
    -- If the user disconnected and we aren't initialized, return immediately and rely on the init/fini code
    -- to clean everything up
    if (omni.isInitialized == false) then
      return DRL_RET_UNINITIALIZED  
    end -- if

    if (not omni.scan.pending.glance) then
      retval = DRL_RET_SUCCESS
      break
    end -- if

    wait.time(periodSec)
    totTime = totTime + periodSec
  end -- while

  if (retval == DRL_RET_TIMEOUT) then
    omni.print("omni.scan.glance.processCR: Timed out waiting for request to complete")
    omni.scan.pending.glance = false
  end -- if

  if (omni.scan.glancePkg.doReport) then
    omni.report.chars()
  end -- if

  omni.scan.glancePkg = nil

  omni.scan.timer.room.pending = false

  return retval
end -- omni.scan.glance.processCR


function omni.scan.glance.complete()
  local retMush
  local retval          = DRL_RET_SUCCESS
  local requestDiscover = false
  local considerSynced  = false

  -- Get ready to build our room scan.table.  If glance didn't find anything, then this should stay
  -- empty after the reset.  Otherwise, we'll fill in the entries as we process them below.
  omni.scan.reset()
  omni.highlight = nil

  -- The consider and glance operations do not include an entry for "you".  It is very nice to see an
  -- entry for you in the char reports though so we manually build an entry for that and then insert
  -- it into the glance table.  If we are doing a study operation, we can know exactly where in the
  -- room order you are.  Otherwise, we stick your entry up at the front of the list.
  local youName = gmcp("char.base.name")
  local youTarget = gmcp("char.status.enemy") or ""
  local youEntry = { nameKey   = youName,
                     nameShort = youName,
                     nameLong  = youName,
                     area      = "",
                     align     = "nil",
                     inGroup   = true,
                     isPlayer  = true,
                     charType  = "player",
                     sanc      = omni.scan.sanc.isEnabled,
                     target    = youTarget }

  -- Ideally, we could simply try to sync the current glance table with the current consider table to see
  -- if they match.  However, there is a case where you enter an aggro room and see mob descriptions before
  -- they detect you and turn aggro.  In this scenario, they turn aggro by the time the discover process can
  -- complete a consider/glance operation so only the aggro names are stored in the database.  To work around
  -- this, we keep a copy of the previous glance table that contains the "at peace" names and try to sync
  -- that table with the consider table first.  If that syncs, we store the "at peace" names in the DB this
  -- time.  The aggro names will be stored the next time the mob is encountered.
  if (omni.scan.glance.last ~= nil) then
    considerSynced = omni.scan.consider.sync(omni.scan.glance.last)
    if (considerSynced) then
      omni.scan.glance.table = omni.scan.glance.last
    end -- if
  end -- if

  if (not considerSynced) then
    considerSynced = omni.scan.consider.sync(omni.scan.glance.table)
  end -- if

  -- If study.table exists and synchronizes with glance.table, copy hpPercent into the glance.table
  -- The study table is one entry larger than the glance table since it includes an entry for you.
  if (omni.scan.study.table  ~= nil)                          and
     (omni.scan.glance.table ~= nil)                          and
     (#omni.scan.study.table - 1 == #omni.scan.glance.table)  and
     (omni.scan.study.startRoom == omni.getRoom())            then
    for idx,studyEntry in ipairs(omni.scan.study.table) do
      if (studyEntry.nameKey == youName) then
        youEntry.hpPercent = studyEntry.hpPercent
        table.insert(omni.scan.glance.table, idx, youEntry)
      elseif (omni.scan.glance.table[idx] ~= nil) then
        omni.scan.glance.table[idx].hpPercent = studyEntry.hpPercent
      end -- if
    end -- for
  else
    -- Insert the "you" entry into the first slot of the glance table since we didn't find a "you" entry
    -- via a study operation
    table.insert(omni.scan.glance.table, 1, youEntry)
  end -- if

  -- We now want to get DB data for each char found via glance.  If we have updated data on that char
  -- from a consider/discover request, update that entry in the DB.  If we don't have data for that char,
  -- request a discover operation.  Finally, merge any DB data with our glance data and move it to scan.table.

  -- Open the DB.  We'll keep this open while we read and possibly update each entry.  We will only close it
  -- after looping through each entry.  We do not do anything that would cause a context switch while the DB
  -- is open so it should be safe from conflicts.  Yay for single-threaded mush!
  local didOpenDB = false
  if (not omni.charsdb.isOpen) then
    retMush = DatabaseOpen(omni.charsdb.dbname, omni.charsdb.sqlite, 6)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.scan.glance.complete: Failed to open database \"" .. omni.charsdb.sqlite .. "\"")
      omni.scan.glance.reset()
      omni.scan.study.reset()
      omni.scan.consider.reset()
      return DRL_RET_INTERNAL_ERROR
    else
      omni.charsdb.isOpen = true
      didOpenDB = true
    end -- if
  end -- if

  -- Check and (possibly) update each entry in the glance table
  for idx,glanceEntry in ipairs(omni.scan.glance.table) do
    local dbEntry  = nil
    local charRoom = omni.getRoom()
    local isPlayer, playerShort = omni.charsdb.isPlayer(glanceEntry.nameLong)

    if (glanceEntry.player) then
      isPlayer = true
    end -- if

    -- See if this char is in the room cache
    local cacheEntry = omni.cache.room.get(charRoom, glanceEntry.nameLong)

    -- Check if the glanceEntry has a corresponding entry in the database.  If the current char is yourself,
    -- don't bother going to the DB since we are just using a fake entry anyway.
    if (glanceEntry.nameKey == gmcp("char.base.name")) then
      dbEntry = youEntry

    -- If this char is a player, look in the players table (we no longer store players in the DB)
    elseif isPlayer then
      dbEntry = omni.scan.players.table[glanceEntry.nameLong]

    -- If we found it in the room cache, use it!
    elseif (cacheEntry ~= nil) then
      dbEntry = cacheEntry

    else
      local selectTab = nil
      local selStr = "SELECT nameKey, nameShort, nameLong, area, room, "    ..
                            "charType, popularity, align, levelFloor, levelCeiling, resists " ..
                     "FROM chars " ..
                     "WHERE (nameLong = \"" .. (glanceEntry.nameLong or "nil") .. "\"" ..
                            "AND room = " .. charRoom .. ") " ..
                     "OR    (nameShort = \"" .. playerShort .. "\");"
      retval, selectTab = omni.charsdb.select(selStr)
      if (selectTab ~= nil) and (#selectTab > 0) then
        dbEntry = selectTab[1]
        omni.cache.room.set(charRoom, dbEntry) -- store this in the cache
      end -- if
    end -- if

    -- If there was no corresponding entry in the database, request a consider/discovery operation.
    -- However, we don't want to get into an infinite loop if we are unable to scan a char/room for some
    -- reason (maybe it's a safe room or some other reason) so we only attempt one discovery each time
    -- we enter a room.  For additional discover requests, either manually request one or leave the room
    -- and then come back.  The omni.discover.room field is cleared when gmcp tells us we've changed rooms.
    local isNewEntry = false
    if (dbEntry == nil) then
      if (omni.discover.isEnabled()) and (omni.discover.room ~= omni.getRoom()) and
         (omni.inCombat() or omni.isActive()) and
         (not omni.inSafeRoom()) and
         ((omni.scan.consider.table == nil) or (#omni.scan.consider.table == 0)) then
        omni.discover.room = omni.getRoom()
        requestDiscover = true
        --omni.print("DB does not have an entry for \"" .. glanceEntry.nameLong .. "\"")
      end -- if
 
      isNewEntry = true
      dbEntry = {} -- hack to make merging dbEntry and glanceEntry easier below
    end -- if

    local equivFields = "nameKey nameShort nameLong area room charType " ..
                        "popularity align levelFloor levelCeiling resists"

    -- If we had a successful consider/discovery, see if we need to update the DB with new data
    if (considerSynced) then
      omni.discover.room = 0

      -- Check if dbEntry matches glanceEntry.  If it doesn't, update the DB.
      local doUpdateDB = false
      for element in equivFields:gmatch("%S+") do
        if (glanceEntry.isPlayer == true) then
          -- Skip the DB update if this is a player -- we only update player entries in a players scan

        elseif (glanceEntry[element] == nil)   or
               (glanceEntry[element] == "nil") or
               (glanceEntry[element] == "")    then
          -- If an entry doesn't exist in the glance.table, use the DB value instead
          glanceEntry[element] = dbEntry[element]

        elseif (dbEntry[element] ~= glanceEntry[element]) then
          --omni.print("Updating DB field \"" .. element .. "\" from \"" .. (dbEntry[element] or "nil") .. 
          --           "\" to \"" .. (glanceEntry[element] or "nil") .. "\"")
          if (element == "levelFloor") then
            local dbFloor = tonumber(dbEntry[element] or "")
            local glFloor = tonumber(glanceEntry[element] or "")
            if (dbFloor ~= nil) and (glFloor ~= nil) and (dbFloor > glFloor) then
              --omni.print("Skipping update of floor from " .. dbFloor .. " to " .. glFloor)
              glanceEntry.levelFloor = dbEntry.levelFloor
            else
              doUpdateDB = true
            end -- if

          elseif (element == "levelCeiling") then
            local dbCeiling = tonumber(dbEntry[element] or "")
            local glCeiling = tonumber(glanceEntry[element] or "")
            if (dbCeiling ~= nil) and (glCeiling ~= nil) and (dbCeiling < glCeiling) then
              --omni.print("Skipping update of ceiling from " .. dbCeiling .. " to " .. glCeiling)
              glanceEntry.levelCeiling = dbEntry.levelCeiling
            else
              doUpdateDB = true
            end -- if

          elseif (element == "nameKey") then
            -- Only update the nameKey in the DB if we haven't discovered it before.  We do not want to
            -- overwrite a nameKey as part of a discovery because the user may have manually updated it
            -- and we don't want to whack a custom keyword given by the user.
            if (dbEntry[element] == nil) or (dbEntry[element] == "nil") or (dbEntry[element] == "") then
              doUpdateDB = true
            else
              glanceEntry.nameKey = dbEntry.nameKey
            end -- if

          else
            doUpdateDB = true

          end -- if

        end -- if
      end -- for

      if (doUpdateDB) then
        local sqlStr

        if (isNewEntry) then
          omni.charsdb.room.set()
          sqlStr = string.format("INSERT INTO chars " ..
                                 "(nameKey, nameShort, nameLong, area, room, " ..
                                 "charType, popularity, align, levelFloor, levelCeiling, resists) " ..
                                 "VALUES (\"%s\", \"%s\", \"%s\", \"%s\", %d, "   ..
                                 "\"%s\", %d, \"%s\", %d, %d, \"%s\")",
                                 glanceEntry.nameKey, glanceEntry.nameShort, glanceEntry.nameLong,
                                 glanceEntry.area, glanceEntry.room or 0,
                                 glanceEntry.charType, glanceEntry.popularity or 0, glanceEntry.align,
                                 glanceEntry.levelFloor or 0, glanceEntry.levelCeiling or 0,
                                 glanceEntry.resists or "nil")
          --omni.print("New sqlStr = " .. sqlStr)
        else
          sqlStr = string.format("UPDATE chars SET " ..
                                 "nameKey      = \"%s\", " .. 
                                 "nameShort    = \"%s\", " .. 
                                 "nameLong     = \"%s\", " .. 
                                 "area         = \"%s\", " .. 
                                 "room         = %d,     " .. 
                                 "charType     = \"%s\", " .. 
                                 "popularity   = %d,     " .. 
                                 "align        = \"%s\", " .. 
                                 "levelFloor   = %d,     " .. 
                                 "levelCeiling = %d,     " .. 
                                 "resists      = \"%s\"  " ..
                                 "WHERE nameLong = \"" .. glanceEntry.nameLong .. "\"" ..
                                 "AND room = " .. glanceEntry.room,
                                 glanceEntry.nameKey, glanceEntry.nameShort, glanceEntry.nameLong,
                                 glanceEntry.area, glanceEntry.room,
                                 glanceEntry.charType, glanceEntry.popularity, glanceEntry.align,
                                 glanceEntry.levelFloor, glanceEntry.levelCeiling, glanceEntry.resists)
          --omni.print("Updating sqlStr = " .. sqlStr)
        end -- if

        retMush = DatabaseExec(omni.charsdb.dbname, sqlStr)
        if (retMush ~= sqlite3.OK) then
          omni.error("omni.scan.glance.complete: Failed to execute \"" .. omni.charsdb.sqlite .. "\": " ..
                     DatabaseError(omni.charsdb.dbname))
          retval = DRL_RET_INTERNAL_ERROR
        end -- if
        if omni.verbose.isEnabled() then
          omni.print("@WDB entry for \"@c" .. glanceEntry.nameLong .. "@W\"")
        end -- if
      end -- if
    end -- if

    -- Fill in the room's scan.table.  The contents for this table will come from our glance.table and
    -- also (if it exists) from the data pulled out of our DB for this entry.
    local roomEntry = {}

    -- Start with the glanceEntry as the baseline then we can add items from the dbEntry if they exist
    for glanceKey, glanceVal in pairs(glanceEntry) do
      roomEntry[glanceKey] = glanceVal
    end -- for

    if (dbEntry.charType ~= nil) then
      if (dbEntry.charType == "player") then
        roomEntry.isPlayer = true
      else
        roomEntry.isPlayer = false
      end -- if
      if (dbEntry.charType == "divine") then
        roomEntry.isDivine = true
      else
        roomEntry.isDivine = false
      end -- if
    end -- if

    roomEntry.nameKey = dbEntry.nameKey or glanceEntry.nameKey or
                        (omni.scan.unidentified .. (glanceEntry.nameLong or "nil"))
    roomEntry.nameShort = dbEntry.nameShort or glanceEntry.nameShort or omni.scan.unidentified

    local counterKey = string.lower(roomEntry.nameKey) -- cannonicalize this
    if (omni.scan.glance.charCounter[counterKey] == nil) then
      omni.scan.glance.charCounter[counterKey] = 1
    end -- if
    if (roomEntry.isPlayer) then
      roomEntry.dotName = roomEntry.nameKey
    else
      local charKeys = roomEntry.nameKey
      if string.find(charKeys, " ") then -- If there is a space (multiple keys) use quotes around them
        charKeys = "'" .. charKeys .. "'"
      end -- if
      roomEntry.dotName = omni.scan.glance.charCounter[counterKey] .. "." .. charKeys
    end -- if
    omni.scan.glance.charCounter[counterKey] = omni.scan.glance.charCounter[counterKey] + 1

    roomEntry.inGroup      = omni.charsdb.isGroupie(roomEntry.nameKey)
    roomEntry.levelFloor   = dbEntry.levelFloor   or roomEntry.levelFloor
    roomEntry.levelCeiling = dbEntry.levelCeiling or roomEntry.levelCeiling
    roomEntry.charType     = dbEntry.charType     or roomEntry.charType 

    if (dbEntry.align ~= nil) then
      roomEntry.align = dbEntry.align
      if (dbEntry.align == "good") then
        roomEntry.good = true
      elseif (dbEntry.align == "evil") then
        roomEntry.evil = true
      end -- if
    end -- if

    roomEntry.resists = dbEntry.resists

    if (roomEntry.nameShort == omni.scan.unidentified) and omni.inSafeRoom() then
      -- Skip unidentified mobs that are in safe rooms since we can't consider them
    else
      -- Insert the entry into the room scan.table.
      table.insert(omni.scan.table, roomEntry)
    end -- if
  end -- for

  if (didOpenDB) then
    retMush = DatabaseClose(omni.charsdb.dbname)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.scan.glance.complete: Failed to close database \"" .. omni.charsdb.sqlite .. "\"")
      retval = DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = false
  end -- if

  -- Save the current glance table so that we can try to sync it on the consider/discover operation.
  -- This is for the case where we enter an aggro room, see mob descriptions at peace, but they switch
  -- to aggro descriptions by the time the consider/glance operation happens.  In this situation, we never
  -- store the "at peace" descriptions in the database because they aren't there when we discover the room.
  omni.scan.glance.last = nil
  if (requestDiscover and (omni.scan.considerPkg == nil)) then
    omni.scan.glance.last = omni.copy(omni.scan.glance.table)

    -- Strip out any reference to you in the glance table since we add that back in automatically and we
    -- don't want a duplicate entry
    local youIndex = 0
    for i, entry in ipairs(omni.scan.glance.last) do
      if (entry.nameKey == gmcp("char.base.name")) then
        youIndex = i
        break
      end -- if
    end -- for
    if (youIndex > 0) then
      table.remove(omni.scan.glance.last, youIndex)
    end -- if
  end -- if

  -- Clean up any intermediate mode tables that were used here.  The glance table can (and should) be rebuilt
  -- every time we call this so clearing it here makes sense.  Similarly, the consider table has already been
  -- used to update the database if necessary at this point so we should whack it now before we leave.
  -- However, the study table has data that is required for the omni.query.room() function.  It's possible
  -- that we gather the study data, update the room table, and then throw that room table away before the
  -- query.room code touches that room table.  As a result, we always keep the most recent study table
  -- around.
  omni.scan.glance.reset()
  omni.scan.consider.reset()

  -- If at least one char in the room hasn't been identified and we haven't already tried to discover this
  -- room since we've been in it, kick off a consider/discover request.
  if (requestDiscover) then
    --omni.print("omni.scan.glance.complete: room discovery requested")

    if (omni.scan.considerPkg ~= nil) then
      --omni.print("omni.scan.glance.complete: Skipping discovery request because another one is in progress")
    else
      omni.scan.consider.process(false)
    end -- if
  end -- if

  -- If we are in windowed mode, always update the window with our latest results.  Otherwise, we leave
  -- whether or not to report things up to the user via the doReport parameter in a scan request.
  if omni.miniwin.isEnabled() then
    omni.report.chars()
  end -- if

  return retval
end -- omni.scan.glance.complete


----------------------------------------------------------------------------------------------------------
-- omni.scan.who -- Use the who command
----------------------------------------------------------------------------------------------------------

omni.scan.who       = {}
omni.scan.who.table = {}

omni.scan.who.startTrigName = "omniWhoStartTrig"
omni.scan.who.midTrigName   = "omniWhoMidTrig"
omni.scan.who.stopTrigName  = "omniWhoEndTrig"
omni.scan.who.inProgress    = false


function omni.scan.who.reset()
  omni.scan.who.table = {}
end -- omni.scan.who.reset


omni.scan.whoPkg = nil
function omni.scan.who.process(mode)
  if (omni.scan.whoPkg ~= nil) then
    omni.print("omni.scan.who.process: Skipping scan request, another request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.whoPkg      = {}

  -- If we aren't in a co-routine already, start one for the scan
  if (coroutine.running() == nil) then
    wait.make(omni.scan.who.processCR)
  else
    -- We are being called from a co-routine so we can make a direct call to the co-routine
    return omni.scan.who.processCR()
  end -- if

  return DRL_RET_SUCCESS

end -- omni.scan.who.process


function omni.scan.who.processCR()
  if (omni.scan.whoPkg == nil) then
    omni.error("omni.scan.who.processCR: Missing package parameter!")
    return DRL_RET_INVALID_PARAM
  end -- if

  if (omni.scan.who.inProgress) then
    omni.print("omni.scan.who.processCR: Skipping request, another who request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.who.reset()

  omni.scan.who.inProgress = true

  check (AddTriggerEx(omni.scan.who.startTrigName,
                      "^[ ]+Aardwolf Players Online[ ]*$",
                      "omni.scan.who.start()",
                      drlTriggerFlagsBaseline + trigger_flag.OneShot + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 100))

  omni.prompt.disable()

  SendNoEcho("who")

  local totTime = 0
  local timeout = 30
  local periodSec = 0.1
  local retval = DRL_RET_TIMEOUT
  while (totTime <= timeout) do
    -- If the user disconnected and we aren't initialized, return immediately and rely on the init/fini code
    -- to clean everything up
    if (omni.isInitialized == false) then
      return DRL_RET_UNINITIALIZED  
    end -- if

    if (not omni.scan.who.inProgress) then
      retval = DRL_RET_SUCCESS
      break
    end -- if

    wait.time(periodSec)
    totTime = totTime + periodSec
  end -- while

  if (retval == DRL_RET_TIMEOUT) then
    -- Let the user know they timed out, but only if their state is one in which you would expect to
    -- get a result.  For example, don't bother with the message if they are afk or writing a note.
    if omni.allowBackgroundSend() then
      omni.print("Scan of who timed out -- you may have been stacked")
    end -- if
    omni.scan.who.stop(true)
  elseif omni.miniwin.isEnabled() then
    omni.report.chars()
  end -- if

  return DRL_RET_SUCCESS
end -- omni.scan.who.processCR


function omni.scan.who.start()

  check (AddTriggerEx(omni.scan.who.midTrigName,
                      "^(.*)$",
                      "omni.scan.who.mid(\"%1\")",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom14,
                      0, "", "", sendto.script, 1))
  check (AddTriggerEx(omni.scan.who.stopTrigName,
                      "^Players invis: \\[[0-9]+\\], Max on ever: \\[[0-9]+\\]$",
                      "omni.scan.who.stop(false)",
                      trigger_flag.Enabled + trigger_flag.RegularExpression +
                        trigger_flag.Replace + trigger_flag.OneShot + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 0))

end -- omni.scan.who.start


function omni.scan.who.mid(line)

  if (line == nil) or (line == "") then
    return
  end -- if

  local strippedLine = string.gsub(line, "^%[...............%] ", "") or ""

  -- I don't know the order for these so I can't anchor them at the start of the line
  strippedLine = string.gsub(strippedLine, "%[Helper%] ",    "")
  strippedLine = string.gsub(strippedLine, "%(DUEL%) ",      "")
  strippedLine = string.gsub(strippedLine, "%(Note%) ",      "")
  strippedLine = string.gsub(strippedLine, "%(WAR%) ",       "")
  strippedLine = string.gsub(strippedLine, "%(Laser%) ",     "")
  strippedLine = string.gsub(strippedLine, "%(Editor%) ",    "")

  -- These are stripped in the order of how they appear in a who entry so we can use ^ to catch start-of-line
  strippedLine = string.gsub(strippedLine, "^%(Linkdead%) ", "")
  strippedLine = string.gsub(strippedLine, "^%*AFK%* ",      "")
  strippedLine = string.gsub(strippedLine, "^%(WANTED%) ",   "")
  strippedLine = string.gsub(strippedLine, "^%[Advisor%] ",  "")
  strippedLine = string.gsub(strippedLine, "^%(OPK%) ",      "")
  strippedLine = string.gsub(strippedLine, "^%(HARDCORE%) ", "")
  strippedLine = string.gsub(strippedLine, "^%(TRAITOR%) ",   "")
  strippedLine = string.gsub(strippedLine, "^%(RAIDER%) ",   "")

  strippedLine = string.gsub(strippedLine, "%[C%]$",         "")
  strippedLine = string.gsub(strippedLine, "%[Q%]$",         "")

  --omni.print("line=\"" .. (line or "nil") .. "\"")
  --omni.print("strippedLine=\"" .. (strippedLine or "nil") .. "\"")

  local nameLong = string.match(strippedLine, "(.*)$") or ""

  nameLong = omni.clans.strip(nameLong) -- strip off any clan names that may be at the end

  -- Remove any color codes since we also remove those in a room scan and names won't match if we don't
  -- also strip them here
  nameLong = strip_colours(nameLong)

  -- Strip out single and double quotes from names to make things simpler
  nameLong = string.gsub(nameLong, "%\"", "")
  nameLong = string.gsub(nameLong, "%\'", "")

  local name = string.sub(nameLong, 1, 23) -- Get the pretitle (max 10 chars) + space + name (12 chars)

  if (name ~= nil) and (name ~= "") then
    --omni.print("name=\"" .. (name or "nil") .. "\"")
    omni.scan.who.table[name] = {}
    omni.scan.who.table[name].nameLong = nameLong
  end -- if

  -- Mush comes with the Hyperlink_URL2.xml plugin that converts web addresses into hyperlinks.  That sounds
  -- benign, but it omits the original text from the output and then *always* reports the hyperlink via a
  -- color tell which makes it impossible for other plugins to gag that output.  As a result, if a player
  -- puts a web link in their title and we run "who", we can't gag the line for that player.  We take the
  -- drastic step here of whacking all triggers in other plugins for this line.  Hopefully nothing subtle
  -- goes wrong by doing this...
  StopEvaluatingTriggers(true)

end -- omni.scan.who.mid


function omni.scan.who.stop(didTimeout)
  local retval = DRL_RET_SUCCESS

  DeleteTrigger(omni.scan.who.midTrigName)

  omni.prompt.enable()

  omni.scan.who.inProgress = false
  omni.scan.whoPkg = nil

  return retval
end -- omni.scan.who.stop


----------------------------------------------------------------------------------------------------------
-- omni.scan.swho -- Use swho12 on area and the entire mud to track players
----------------------------------------------------------------------------------------------------------

omni.scan.swho               = {}

omni.scan.swho.area          = {}
omni.scan.swho.area.table    = {}
omni.scan.swho.mud           = {}
omni.scan.swho.mud.table     = {}

omni.scan.swho.startTrigName = "omniSwhoStartTrig"
omni.scan.swho.midTrigName   = "omniSwhoMidTrig"
omni.scan.swho.stopTrigName  = "omniSwhoEndTrig"
omni.scan.swho.inProgress    = false
omni.scan.swho.mode          = "nil"
omni.scan.swho.tooManyMsg    = "There are too many doors and fences to see who is in this area." 


function omni.scan.swho.reset(mode)
  if (mode == "area") then
    omni.scan.swho.area.table = {}
  elseif (mode == "mud") then
    omni.scan.swho.mud.table = {}
  else
    omni.error("omni.scan.swho.reset: Invalid mode \"" .. (mode or "nil") .. "\"")
  end -- if
end -- omni.scan.swho.reset


omni.scan.swhoPkg = nil
function omni.scan.swho.process(mode)
  if (omni.scan.swhoPkg ~= nil) then
    --omni.print("Skipping swho scan request, another request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.swhoPkg      = {}
  omni.scan.swhoPkg.mode = mode

  -- If we aren't in a co-routine already, start one for the scan
  if (coroutine.running() == nil) then
    wait.make(omni.scan.swho.processCR)
  else
    -- We are being called from a co-routine so we can make a direct call to the co-routine
    return omni.scan.swho.processCR()
  end -- if

  return DRL_RET_SUCCESS

end -- omni.scan.swho.process

function omni.scan.swho.processCR()
  if (omni.scan.swhoPkg == nil) then
    omni.error("omni.scan.swho.processCR: Missing package parameter!")
    return DRL_RET_INVALID_PARAM
  end -- if

  if (omni.scan.swho.inProgress) then
    omni.print("Skipping request, another swho request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.swho.mode = omni.scan.swhoPkg.mode

  local command = ""
  if (omni.scan.swho.mode == "mud") then
    command = "swho 12"
  elseif (omni.scan.swho.mode == "area") then
    command = "swho 12 area"
  else
    omni.error("omni.scan.swho.processCR: Invalid parameter \"" .. (omni.scan.swho.mode or "nil") .. "\"")
    omni.scan.swho.inProgress = false
    omni.scan.swhoPkg = nil
    return DRL_RET_INVALID_PARAM
  end -- if

  omni.scan.swho.inProgress = true
  omni.prompt.disable()

  check (AddTriggerEx(omni.scan.swho.startTrigName,
                      "^(" ..
                           "[ ]+Who list sorted by : Total Stats[ ]*|" ..
                           omni.scan.swho.tooManyMsg                   ..
                      ")$",
                      "omni.scan.swho.start(\"%1\")",
                      drlTriggerFlagsBaseline + trigger_flag.OneShot + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 100))

  SendNoEcho(command)

  local totTime = 0
  local timeout = 30
  local periodSec = 0.1
  local retval = DRL_RET_TIMEOUT
  while (totTime <= timeout) do
    -- If the user disconnected and we aren't initialized, return immediately and rely on the init/fini code
    -- to clean everything up
    if (omni.isInitialized == false) then
      return DRL_RET_UNINITIALIZED  
    end -- if

    if (not omni.scan.swho.inProgress) then
      retval = DRL_RET_SUCCESS
      break
    end -- if

    wait.time(periodSec)
    totTime = totTime + periodSec
  end -- while

  if (retval == DRL_RET_TIMEOUT) then
    -- Let the user know they timed out, but only if their state is one in which you would expect to
    -- get a result.  For example, don't bother with the message if they are afk or writing a note.
    if omni.allowBackgroundSend() then
      omni.print("Scan of swho " .. omni.scan.swho.mode .. ": timed out -- you may have been stacked")
    end -- if

    omni.print("Scan of swho " .. omni.scan.swho.mode .. ": timed out, attempting cleanup...")
    omni.scan.swho.stop(true)

  elseif omni.miniwin.isEnabled() then
    omni.report.chars()

  end -- if

  return retval
end -- omni.scan.swho.processCR


function omni.scan.swho.start(line)

  if (line == omni.scan.swho.tooManyMsg) then
    if omni.verbose.isEnabled() then
      --omni.print("Scan of " .. omni.scan.swho.mode .. " completed")
    end -- if

    omni.prompt.enable()
    omni.scan.swho.inProgress = false
    omni.scan.swhoPkg = nil
    return
  end -- if

  omni.scan.swho.reset(omni.scan.swho.mode)

  check (AddTriggerEx(omni.scan.swho.midTrigName,
                      "^(.*)$",
                      "omni.scan.swho.mid(\"%1\")",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 100))

  check (AddTriggerEx(omni.scan.swho.stopTrigName,
                      "^Players invis: \\[[0-9]+\\], Max on ever: \\[[0-9]+\\]$",
                      "omni.scan.swho.stop(false)",
                      drlTriggerFlagsBaseline + trigger_flag.OneShot + trigger_flag.OmitFromOutput,
                      custom_colour.Custom11,
                      0, "", "", sendto.script, 100))

end -- omni.scan.swho.start


omni.scan.swho.raceShort = { "Human",
                             "Dwarf",
                             "Elf",
                             "Giant",
                             "Half",
                             "H-Grif",
                             "Troll", 
                             "Sprite",  
                             "Quick",
                             "Drow",
                             "Cen",
                             "Vamp",
                             "Wolf",   
                             "Rat",  
                             "Diva",  
                             "Shade",
                             "Triton",   
                             "Lizard", 
                             "Eldar" }


function omni.scan.swho.isSuperhero(level, race, class)
  --omni.print("isSuperhero: level=\"" .. (level or "nil") .. "\", race=\"" .. 
  --           (race or "nil") .. "\", class=\"" .. (class or "nil") .. "\"")

  -- If we have a known level and class (todo: check if it's a valid P+4 etc. format) then we check if
  -- the middle word of the whoname is a known race.  If we get to this point then we assume this is not
  -- a superhero because the whoname is something like "123  eldar  P+4".  If someone picks a custom 
  -- whoname of that format then we may not accurately determine their level.  Close enough... :)
  if (level ~= nil) and (class ~= nil) then
    for i, raceShort in ipairs(omni.scan.swho.raceShort) do
      if (race == raceShort) then
        return false
      end -- if
    end -- for
  end -- if

  return true
end -- omni.scan.swho.isSuperhero


function omni.scan.swho.mid(line)

  if (line == nil) or (line == "") then
    return
  end -- if

  -- Look at the whoname field (if it exists) to determine the player's level
  local playerLevel = 0
  local whoname = string.match(line, "^%[(...............)%] ")
  if (whoname ~= nil) then
    local levelNum, race, classes = string.match(whoname, "^(...)  (%S+)%s+(%S+)")
    levelNum = tonumber(levelNum or "")
    if omni.scan.swho.isSuperhero(levelNum, race, classes) or
      (whoname == "   SUPERHERO   ") or (whoname == " SUPERHEROINE  ") then
      playerLevel = 201
    elseif (whoname == "     HERO      ") or (whoname == "    HEROINE    ") then
      playerLevel = 200
    elseif (levelNum == nil) then -- whoname was a custom string so this is either 200 or 201 (guess 201)
      playerLevel = 201
    else
      playerLevel = levelNum
    end -- if
  end -- if

  -- Clip off the whoname field and any [Q] or [C] flags at the end of the line
  local clippedLine = string.gsub(line, "^%[...............%] ", "")
  clippedLine = string.gsub(clippedLine, "%[C%]$", "")
  clippedLine = string.gsub(clippedLine, "%[Q%]$", "")
  clippedLine = string.gsub(clippedLine, "[ ]+$", "")

  -- Remove any color codes since we also remove those in a room scan and names won't match if we don't
  -- also strip them here
  clippedLine = strip_colours(clippedLine)

  -- Remove the last two lines of swho output since we don't want or need those here
  if string.match(clippedLine, "^Players ") then
    return
  end -- if

  -- Get the numStats for this player
  local playerStats = tonumber(Trim(string.match(clippedLine, "^%[(......)%] ") or "")) or 0
  clippedLine = string.gsub(clippedLine, "^%[(......)%] ", "")

  -- Get the clan for this player (if one exists)
  local playerClan, clanShort = "", ""
  clippedLine, playerClan, clanShort = omni.clans.strip(clippedLine)

  -- Get the player name
  local playerName = string.match(clippedLine, "[^ ]+$")
  clippedLine = string.gsub(clippedLine, "[^ ]+$", "")

  -- Get the flags
  local fullFlags = string.gsub(clippedLine, "[ ]*$", "")
  local playerFlags = ""
  if (string.match(fullFlags, "%(HARDCORE%)")) then
    playerFlags = playerFlags .. "@RH"
  end -- if
  if (string.match(fullFlags, "%(WANTED%)")) then
    playerFlags = playerFlags .. "@RW"
  end -- if
  if (string.match(fullFlags, "%(OPK%)")) then
    playerFlags = playerFlags .. "@MO"
  end -- if
  if (playerFlags ~= "") then
    playerFlags = " " .. playerFlags .. "@w"
  end -- if

  if (playerName ~= nil) and (playerName ~= "") then
    omni.scan.swho[omni.scan.swho.mode].table[playerName] = { name      = playerName,
                                                              clan      = playerClan,
                                                              clanShort = clanShort,
                                                              flags     = playerFlags,
                                                              level     = playerLevel,
                                                              stats     = playerStats }
  end -- if

end -- omni.scan.swho.mid


function omni.scan.swho.stop(didTimeout)
  local retval = DRL_RET_SUCCESS

  if (didTimeout) then
    DeleteTrigger(omni.scan.swho.startTrigName) 
    DeleteTrigger(omni.scan.swho.stopTrigName)
  end -- if

  DeleteTrigger(omni.scan.swho.midTrigName)

  omni.prompt.enable()

  omni.scan.swho.inProgress = false
  omni.scan.swhoPkg = nil

  return retval
end -- omni.scan.swho.stop


----------------------------------------------------------------------------------------------------------
-- Wrapper around study/glance
----------------------------------------------------------------------------------------------------------

omni.scan.room = {}
function omni.scan.room.process(doReport)
  local retval = DRL_RET_RETRY

  -- We can only study/glance if we are active or in combat.  Don't bother trying if the player is 
  -- sleeping or in another state that doesn't allow actions.
  if omni.isActive() or omni.inCombat() then
    if omni.report.isEnabled("hp") then
      retval = omni.scan.study.process(doReport)
    else
      retval = omni.scan.glance.process(doReport)
    end -- if
  end -- if

  return retval
end -- omni.scan.room.process


----------------------------------------------------------------------------------------------------------
-- Wrapper around who/swho/charsdb modules to track players in the database
----------------------------------------------------------------------------------------------------------

omni.scan.players       = {}
omni.scan.players.table = {}

omni.scan.playersPkg = nil
function omni.scan.players.process(doReport)
  local retval

  if (omni.scan.playersPkg ~= nil) then
    omni.print("Skipping player scan request: another request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.scan.playersPkg          = {}
  omni.scan.playersPkg.doReport = doReport

  -- If we aren't in a co-routine already, start one for the request
  if (coroutine.running() == nil) then
    wait.make(omni.scan.players.processCR)
  else
    -- We are being called from a co-routine so we can make a direct call to the co-routine
    retval = omni.scan.players.processCR()
  end -- if

  return retval
end -- omni.scan.players.process


function omni.scan.players.processCR()
  retval = DRL_RET_SUCCESS

  if (omni.scan.playersPkg == nil) then
    omni.error("omni.scan.players.processCR: package parameter is nil!")
    return DRL_RET_INTERNAL_ERROR
  end -- if

  retval = omni.scan.swho.process("mud")
  if (retval ~= DRL_RET_SUCCESS) then
    -- Being busy (another request is in progress) isn't an error
    if (retval ~= DRL_RET_BUSY) then
      omni.error("omni.scan.players.process: omni.scan.swho.process returned with error \"" ..
                 omni.retval.getString(retval) .. "\"")
    end -- if
    omni.scan.playersPkg = nil
    return retval
  end -- if

  retval = omni.scan.who.process(doReport)
  if (retval ~= DRL_RET_SUCCESS) then
    -- Being busy (another request is in progress) isn't an error
    if (retval ~= DRL_RET_BUSY) then
      omni.error("omni.scan.players.process: omni.scan.who.process returned with error \"" ..
                 omni.retval.getString(retval) .. "\"")
    end -- if
    omni.scan.playersPkg = nil
    return retval
  end -- if

  if (omni.scan.swho.mud.table == nil) or (omni.scan.who.table == nil) then
    omni.scan.playersPkg = nil
    return retval
  end -- if

  -- Merge the who and swho tables
  for key,whoEntry in pairs(omni.scan.who.table) do
    local nameShort = ""

    for element in key:gmatch("%S+") do
      nameShort = nameShort .. " " .. element
      if (omni.scan.swho.mud.table[element] ~= nil) then
        local playerEntry = { nameKey   = Trim(element),
                              nameShort = Trim(nameShort),
                              nameLong  = whoEntry.nameLong .. ".",
                              area     = "",
                              align    = "nil",
                              isPlayer = true,
                              charType = "player"}

        -- This can be found by looking in a room and seeing either nameLong or (if notitle is enabled)
        -- the short name followed by a ".".  Yeah, it's kludgy.
        omni.scan.players.table[playerEntry.nameLong]  = playerEntry
        omni.scan.players.table[playerEntry.nameShort .. "."] = playerEntry -- supports "notitle"
        break
      end -- if
    end -- for
  end -- for

  omni.scan.playersPkg = nil

  -- Kick off a room scan in case we need to update things for a newly discovered player
  omni.scan.timer.room.requested = true

  return retval
end -- omni.scan.players.processCR


----------------------------------------------------------------------------------------------------------
-- Scan timer support
----------------------------------------------------------------------------------------------------------

omni.scan.timer                      = {}

omni.scan.timer.area                 = {}
omni.scan.timer.area.name            = "omniScanTimerArea"
omni.scan.timer.area.timeout         = "omniScanTimerAreaTimeout"
omni.scan.timer.area.var             = "omniScanTimerAreaState"
omni.scan.timer.area.fence           = "omniScanTimerAreaFence"
omni.scan.timer.area.trgName         = "omniScanTimerAreaTrigger"
omni.scan.timer.area.fenceRunning    = false

omni.scan.timer.players              = {}
omni.scan.timer.players.name         = "omniScanTimerPlayers"
omni.scan.timer.players.timeout      = "omniScanTimerPlayersTimeout"
omni.scan.timer.players.var          = "omniScanTimerPlayersState"
omni.scan.timer.players.fence        = "omniScanTimerPlayersFence"
omni.scan.timer.players.trgName      = "omniScanTimerPlayersTrigger"
omni.scan.timer.players.fenceRunning = false

omni.scan.timer.room                 = {}
omni.scan.timer.room.name            = "omniScanTimerRoom"
omni.scan.timer.room.var             = "omniScanTimerRoomState"
omni.scan.timer.room.trgName         = "omniScanTimerRoomTrigger"
omni.scan.timer.room.requested       = false
omni.scan.timer.room.pending         = false

omni.scan.timer.list                 = "area players"
omni.scan.maxPeriodSec               = 9999

omni.scan.timer.gagTrigName          = "omniScanTimerGagTrigger"


function omni.scan.timer.set(mode, period)
  local periodSec = tonumber(period or "")

  if (mode ~= "area") and (mode ~= "players") and (mode ~= "room") then
    omni.error("omni.scan.timer.set: invalid mode \"" .. (mode or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  if (periodSec == nil) or (periodSec < 0) then
    omni.error("omni.scan.timer.set: Invalid period \"" .. (period or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  SetVariable(omni.scan.timer[mode].var, periodSec)

  if (periodSec == 0) then
    omni.print("@WScheduled @c" .. mode .. "@W scan: @RDISABLED@w")
  end -- if

  return DRL_RET_SUCCESS
end -- omni.scan.timer.set


function omni.scan.timer.get(mode)
  if (mode ~= "area") and (mode ~= "players") and (mode ~= "room") then
    omni.error("omni.scan.timer.get: invalid mode \"" .. (mode or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  local periodSec = GetVariable(omni.scan.timer[mode].var)

  if (periodSec == nil) or (periodSec == "") then
    if (mode == "players") then
      periodSec = 600 -- pick 10 minutes as a default period to scan for new players
    else
      periodSec = 0
    end -- if

    omni.scan.timer.set(mode, periodSec) -- default is disabled
  end -- if

  return tonumber(periodSec or "0")
end -- omni.scan.timer.get


function omni.scan.timer.isEnabled(mode)
  local periodSec = omni.scan.timer.get(mode)
  if (periodSec == nil) or (periodSec == "") or
     (periodSec == 0) or (periodSec == "0")  or
     (not omni.isEnabled())                  then
    return false
  else
    return true
  end -- if
end -- omni.scan.timer.isEnabled


function omni.scan.timer.init()
  for timerName in omni.scan.timer.list:gmatch("%S+") do
    if (omni.scan.timer.isEnabled(timerName)) then
      omni.scan.timer.process(timerName)
    end -- if
  end -- for

  omni.scan.timer.area.fenceRunning    = false
  omni.scan.timer.players.fenceRunning = false
  omni.scan.timer.room.requested       = false
  omni.scan.timer.room.pending         = false

  -- Create a regex that matches lines that will cause us to want to rescan the room (eventually).
  -- We also set the room.requested = true option in the last kill trigger.  In other words, if we
  -- ever see something die in our room, we should schedule a scan to glance at the room again.
  local regexMove      = "^(.*) ("                                                            ..
                         "leaves|canters|gallops|crashes|dashes|zooms|flies|swoops|glides|"   ..
                         "darts|flits|slinks|marches|pads|scurries|scampers|skulks|slithers|" ..
                         "sloshes|stomps|strides|jets|screams and charges)( in.*)? "          ..
                         "(north|south|east|west|up|down).$"
  local regexMobProg   = "^A bolt of lightning flashes from the heavens and strikes (.*) directly in the chest!$"
  local regexRetreat   = "^(.*) has fled.$|^.* retreats .*$"
  local regexDisappear = "^(.*) disappears.$|^(.*) disappears to be joined with .* spouse.$"
  local regexBlindCure = "^You can see again.$|^Your vision returns.$"
  local regexRepop     = "^(.*) appears in the room.$"
  local regexBuffs     = "^The white aura around (.*) vanishes.$|" ..
                         "^(.*) is surrounded by a shimmering white aura of divine protection.$"

  local regex = regexMove      .. "|" .. regexMobProg   .. "|" .. regexRetreat .. "|" ..
                regexDisappear .. "|" .. regexBlindCure .. "|" .. regexRepop   .. "|" ..
                regexBuffs     .. "|" 

  check (AddTriggerEx(omni.scan.timer.room.trgName,
                      regex,
                      "omni.scan.timer.room.requested = true",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100)) 

  check (AddTriggerEx(omni.scan.timer.gagTrigName,
                      "^(" .. 
                           omni.scan.timer.area.fence    .. "|" ..
                           omni.scan.timer.players.fence .. 
                      ")$",
                      "",
                      drlTriggerFlagsBaseline + trigger_flag.OmitFromOutput,
                      custom_colour.Custom14, 0, "", "", sendto.script, 100))

  omni.scan.timer.room.init()

end -- omni.scan.timer.init


function omni.scan.timer.fini()
  for timerName in omni.scan.timer.list:gmatch("%S+") do
    DeleteTimer(omni.scan.timer[timerName].name)
  end -- for

  omni.scan.timer.room.fini()
end -- omni.scan.timer.fini


function omni.scan.setTimer(mode, periodSec)

  if (periodSec == nil) then
    omni.error("omni.scan.setTimer: missing periodSec parameter")

  elseif (periodSec > omni.scan.maxPeriodSec) then
    omni.error("omni.scan.setTimer: period of " .. periodSec .. " seconds exceeds maximum time of " ..
               omni.scan.maxPeriodSec .. " seconds")

  elseif (periodSec < 0) then
    omni.error("omni.scan.setTimer: timer period cannot be negative")

  elseif (mode == "area") or (mode == "players") then
    omni.scan.timer.set(mode, periodSec)
    omni.scan.timer.process(mode)

  elseif (mode == "room") then
    omni.scan.timer.set(mode, periodSec)
    omni.scan.timer.room.init()
    
  else
    omni.print("Timers for scan mode \"" .. (mode or "nil") .. "\" are not yet supported")

  end -- if
end -- omni.scan.setTimer


function omni.scan.timer.process(mode)
  local periodSec = omni.scan.timer.get(mode)

  if (periodSec == nil) then
    omni.error("omni.scan.timer.process: invalid mode parameter \"" .. (mode or "nil") .. "\"")
  end -- if

  if (periodSec == 0) then
    DeleteTimer(omni.scan.timer[mode].name)
  else
    omni.scan.timer.addOneShot(omni.scan.timer[mode].name, periodSec, "omni.scan.timer." .. mode .. ".process")
  end -- if
end -- omni.scan.timer.process


function omni.scan.timer.addOneShot(name, periodSec, fnName)
  local hr  = math.floor((periodSec % 86400) / 3600) 
  local min = math.floor((periodSec %  3600) /   60)
  local sec = math.floor((periodSec %    60) /    1)

  local timerLine = string.format("AddTimer(\"%s\", %d, %d, %d, \"\", " ..
                                  "timer_flag.Enabled + timer_flag.Replace + timer_flag.OneShot, \"%s\")",
                                   name, hr, min, sec, fnName)
  check (DoAfterSpecial(0.1, timerLine, sendto.script))
end -- omni.scan.timer.addOneShot


function omni.scan.timer.area.process()
  return omni.scan.timer.general("area")
end -- omni.scan.timer.area.process


function omni.scan.timer.players.process()
  return omni.scan.timer.general("players")
end -- omni.scan.timer.players.process


function omni.scan.timer.general(mode)

  if omni.scan.timer.isEnabled(mode) then

    -- If our state allows us to send commands to the mud, send a fence and wait for a response.  If we
    -- currently can't send anything to the mud (e.g., we are AFK or writing a note) then skip processing
    -- for this request and schedule the next timer.
    if omni.allowBackgroundSend() and (omni.scan.timer[mode].fenceRunning == false) then
      omni.scan.timer[mode].fenceRunning = true

      local fence =  omni.scan.timer[mode].fence
      check (AddTriggerEx(omni.scan.timer[mode].trgName,
                          "^" .. fence .. "$",
                          "omni.scan.timer." .. mode .. ".trigger(false)",
                          drlTriggerFlagsBaseline + trigger_flag.OneShot,
                          custom_colour.Custom11, 0, "", "", sendto.script, 100))
      omni.prompt.disable()
      SendNoEcho("echo " .. fence)

      -- Add a timer to clean up things by calling the trigger if we time out.  Maybe the user disconnected
      -- and missed the fence we were waiting for.
      AddTimer(omni.scan.timer[mode].timeout, 0, 0, 30, "",
               timer_flag.Enabled + timer_flag.Replace + timer_flag.OneShot,
               "omni.scan.timer." .. mode .. ".triggerTimeout")

    else
      omni.scan.timer.addOneShot(omni.scan.timer[mode].name,
                                 omni.scan.timer.get(mode),
                                 "omni.scan.timer." .. mode .. ".process")
    end -- if

  end -- if
end -- omni.scan.timer.general


function omni.scan.timer.area.triggerTimeout()
  omni.scan.timer.area.trigger(true)
end -- omni.scan.timer.area.triggerTimeout


function omni.scan.timer.players.triggerTimeout()
  omni.scan.timer.players.trigger(true)
end -- omni.scan.timer.players.triggerTimeout


function omni.scan.timer.area.trigger(didTimeout)
  if (omni.scan.timer.area.fenceRunning) then
    omni.scan.timer.area.fenceRunning = false

    if (not didTimeout) then
      DeleteTimer(omni.scan.timer.area.timeout)
    end -- if

    omni.prompt.enable()

    if omni.scan.timer.isEnabled("area") then
      if omni.allowBackgroundSend() then
        --omni.print("Sending an area scan...")  
        -- We can't do anything that will mess with triggers in this trigger thread.  As a result, we
        -- schedule the scan as soon as we can in another thread.
        DoAfterSpecial(0.1, "omni.scan.swho.process(\"area\")", sendto.script)
      end -- if

      -- Schedule the next instance of the timer
      omni.scan.timer.addOneShot(omni.scan.timer.area.name,
                                 omni.scan.timer.get("area"),
                                 "omni.scan.timer.area.process")
    end -- if
  end -- if
end -- omni.scan.timer.area.trigger


function omni.scan.timer.players.trigger(didTimeout)
  if (omni.scan.timer.players.fenceRunning) then

    omni.scan.timer.players.fenceRunning = false

    if (not didTimeout) then
      DeleteTimer(omni.scan.timer.players.timeout)
    end -- if

    omni.prompt.enable()

    if omni.scan.timer.isEnabled("players") then
      if omni.allowBackgroundSend() then
        --omni.print("Sending a players scan...")
        -- We can't do anything that will mess with triggers in this trigger thread.  As a result, we
        -- schedule the scan as soon as we can in another thread.
        DoAfterSpecial(0.1, "omni.scan.players.process(false)", sendto.script)
      end -- if

      -- Schedule the next instance of the timer
      omni.scan.timer.addOneShot(omni.scan.timer.players.name,
                                 omni.scan.timer.get("players"),
                                 "omni.scan.timer.players.process")
    end -- if
  end -- if
end -- omni.scan.timer.players.trigger


function omni.scan.timer.room.init()
  local sec = omni.scan.timer.get("room") or 0

  AddTimer(omni.scan.timer.room.name,
           0, 0, sec, "",
           timer_flag.Enabled + timer_flag.Replace,
           "omni.scan.timer.room.fn")        
end -- omni.scan.timer.room.init


function omni.scan.timer.room.fini()
  DeleteTimer(omni.scan.timer.room.name)
end -- omni.scan.timer.room.fini


function omni.scan.timer.room.fn()
  wait.make(omni.scan.timer.room.fnCR)
end -- omni.scan.timer.room.fn


function omni.scan.timer.room.fnCR()

  -- If the room timer is enabled and our state allows us to send commands to the mud, proceed.  Otherwise,
  -- skip this request since we can't scan a room if we are AFK or writing a note.
  if omni.isEnabled()                   and
     omni.scan.timer.isEnabled("room")  and 
     omni.allowBackgroundSend()         and
     omni.scan.timer.room.requested     and
     (not omni.scan.timer.room.pending) then

    omni.scan.timer.room.requested = false
    omni.scan.timer.room.pending   = true

    local retval = omni.scan.room.process(false)
    if (retval ~= DRL_RET_SUCCESS) then
      -- If there was a failure processing the room request, then rollback the flags so that we try again
      omni.scan.timer.room.requested = true
      omni.scan.timer.room.pending   = false  
    end -- if
  end -- if

end -- omni.scan.timer.room.fnCR


----------------------------------------------------------------------------------------------------------
-- Current clan tags
----------------------------------------------------------------------------------------------------------

omni.clans = {}
omni.clans.list = "wolf loner outcast twinlobe watchmen chaos seekers emerald light dragon baal hook " ..
                  "bard crusader xunti imperium crimson retribution druid amazon pyre masaki rhabdo "  ..
                  "perdition loqui gaardian tao touchstone boot"

omni.clans.rename = {}
omni.clans.rename.wolf        = "@R.:|@WWolf@R|:."
omni.clans.rename.loner       = "@g  [@CLoner@g] "
omni.clans.rename.outcast     = " @B(@MOutcast@B)"
omni.clans.rename.twinlobe    = "@M-@CTwinlobe@M-"
omni.clans.rename.watchmen    = "@Y|@x238O.o 8==D@Y|"
omni.clans.rename.chaos       = "@D{@Rchaos@D}   "
omni.clans.rename.seekers     = " @M(@YSeekers@M)"
omni.clans.rename.emerald     = " @C[@GEmeroid@C]"
omni.clans.rename.light       = "@x032<@W-@x032)@Wl@x253i@x249t@x240e@x032(@W-@x032>"
omni.clans.rename.dragon      = "@W*@G)@WDragon@G(@W*"
omni.clans.rename.baal        = "  @r[@RBa'al@r] "
omni.clans.rename.hook        = "@Co-}@YHooK@C{-o"
omni.clans.rename.bard        = "@W[@RB@Ga@Cr@Yd@W]    "
omni.clans.rename.crusader    = "@M=@WCrusader@M="
omni.clans.rename.xunti       = "@r^@bX@r.@bu@r{@bN@r}@bt@r.@bI"
omni.clans.rename.imperium    = "@r-@WIMPERIUM@r-"
omni.clans.rename.crimson     = " @Y|@RCrimson@Y|"
omni.clans.rename.retribution = "@Y|@rRe@RtryButt"
omni.clans.rename.druid       = " @W|@w\\@gDr@Wu@yid@w/@W|"
omni.clans.rename.amazon      = "@R> @GA@gmazo@Gn @R<"
omni.clans.rename.pyre        = "@b~@W-@C/@cP@Byr@ce@C\\@W-@b~"
omni.clans.rename.masaki      = "@W-=@rMasaki@W=-"
omni.clans.rename.rhabdo      = "@W^@b\\@WRh@wab@Wdo@b/@W^"
omni.clans.rename.perdition   = " @WP@we@Rr@rdit@Ri@wo@Wn@w"
omni.clans.rename.loqui       = " @w:@y:@WLoquI@y:@w:"
omni.clans.rename.gaardian    = "@y|@wGaardian@y|"
omni.clans.rename.tao         = "  @g\\}@wTao@g{/ "
omni.clans.rename.touchstone  = "@WTouchStone"
omni.clans.rename.boot        = "@Y|@Dx=@GBOOT@D=x@Y|"

-- Hacks to avoid some of the worst escape sequences :P
local CLAN_DRUID  = [[/|\Druid/|\]]
local CLAN_PYRE   = [[~-/Pyre\-~]]
local CLAN_RHABDO = [[(^\Rhabdo/^)]]
local CLAN_TAO    = [[\}Tao{/]]
local CLAN_MASAKI = [[{-=Masaki=-}]]

omni.clans.table = {}
omni.clans.table[".:|Wolf|:."]             = omni.clans.rename.wolf
omni.clans.table["[Loner]"]                = omni.clans.rename.loner
omni.clans.table["(Outcast)"]              = omni.clans.rename.outcast
omni.clans.table["-!-Twinlobe-!-"]         = omni.clans.rename.twinlobe
omni.clans.table["|Watchmen|"]             = omni.clans.rename.watchmen
omni.clans.table["{chaos}"]                = omni.clans.rename.chaos
omni.clans.table["(Seekers)"]              = omni.clans.rename.seekers
omni.clans.table["[Emerald]"]              = omni.clans.rename.emerald
omni.clans.table["<-)light(->"]            = omni.clans.rename.light
omni.clans.table["-=*)Dragon(*=-"]         = omni.clans.rename.dragon
omni.clans.table["[Ba'al]"]                = omni.clans.rename.baal
omni.clans.table["o-}HooK{-o"]             = omni.clans.rename.hook
omni.clans.table["[Bard]"]                 = omni.clans.rename.bard
omni.clans.table["=Crusader="]             = omni.clans.rename.crusader
omni.clans.table["^X.u{N}t.I^"]            = omni.clans.rename.xunti
omni.clans.table[">>>-IMPERIUM->"]         = omni.clans.rename.imperium
omni.clans.table["<*><|Crimson|><*>"]      = omni.clans.rename.crimson
omni.clans.table["-|Retribution|-"]        = omni.clans.rename.retribution
omni.clans.table[CLAN_DRUID]               = omni.clans.rename.druid
omni.clans.table["<-:*:-> Amazon <-:*:->"] = omni.clans.rename.amazon
omni.clans.table[CLAN_PYRE]                = omni.clans.rename.pyre
omni.clans.table[CLAN_RHABDO]              = omni.clans.rename.rhabdo
omni.clans.table["+ Perdition +"]          = omni.clans.rename.perdition
omni.clans.table[":::LoquI:::"]            = omni.clans.rename.loqui
omni.clans.table["<<|Gaardian|>>"]         = omni.clans.rename.gaardian
omni.clans.table[CLAN_TAO]                 = omni.clans.rename.tao
omni.clans.table["(>TouchStone<)"]         = omni.clans.rename.touchstone
omni.clans.table["|=x=BOOT=x=|"]           = omni.clans.rename.boot
omni.clans.table["{-=Masaki=-}"]           = omni.clans.rename.masaki
omni.clans.table[CLAN_MASAKI]              = omni.clans.rename.masaki
omni.clans.table["<(=Watchix=)>"]          = omni.clans.rename.watchmen

-- April fools renames
omni.clans.table["(-DoH-)"]                = omni.clans.rename.emerald
omni.clans.table["{-=WeeaboO=-}"]          = omni.clans.rename.masaki
omni.clans.table["uU HooF Uu"]             = omni.clans.rename.hook


function omni.clans.init()
  for clan in omni.clans.list:gmatch("%S+") do
    -- Get a string with the clan name where the name has the first letter capitalized
    local clanUpper = omni.capitalize(clan)

    -- Add an entry to the clans table for the case where "clantags" is enabled
    omni.clans.table["[" .. clanUpper .. "]"] = omni.clans.rename[clan]
  end -- for
end -- omni.clans.init


-- Strip off any clan tags from the given line
function omni.clans.strip(line)
  local strippedLine = line

  for clanName, nickName in pairs(omni.clans.table) do
    local lineSuffix = string.sub(line, -string.len(clanName))
    if (clanName == lineSuffix) then
      local clanShort = ""
      for k,v in pairs(omni.clans.rename) do
        if (v == nickName) then
          clanShort = k
          break
        end -- if
      end -- if

      --omni.print("lineSuffix = \"" .. lineSuffix .. "\"")
      strippedLine = string.sub(line, 1, string.len(line) - string.len(clanName) - 1)
      return Trim(strippedLine or ""), nickName, clanShort
    end -- if
  end -- for

  return Trim(strippedLine or ""), "", ""
end -- omni.clans.strip


----------------------------------------------------------------------------------------------------------
-- Mob search and keyword options
----------------------------------------------------------------------------------------------------------

--FIXME TODO: move this to the DB

omni.exceptions = {}

omni.exceptions.sohtwo                 = {}
omni.exceptions.sohtwo["Sagen"]        = "notcarlsagen"
omni.exceptions.sohtwo["Demonspawn"]   = "angelic"
omni.exceptions.sohtwo["Obyron"]       = "fuzzybunny"
omni.exceptions.sohtwo["Broud"]        = "dejected"
omni.exceptions.sohtwo["Rumour"]       = "obstinate"
omni.exceptions.sohtwo["Dadrake"]      = "letsturnlefthere"
omni.exceptions.sohtwo["Aaeron"]       = "shinythings"
omni.exceptions.sohtwo["Althalus"]     = "homeskillet"
omni.exceptions.sohtwo["Belmont"]      = "bridgetroll"
omni.exceptions.sohtwo["Domain"]       = "66"
omni.exceptions.sohtwo["Euphonix"]     = "ragbrai"
omni.exceptions.sohtwo["Ghann"]        = "longghaan"
omni.exceptions.sohtwo["Halo"]         = "jackandcoke"
omni.exceptions.sohtwo["Ikyu"]         = "ickypoo"
omni.exceptions.sohtwo["Justme"]       = "helperisme"
omni.exceptions.sohtwo["Kharpern"]     = "kittyimm"
omni.exceptions.sohtwo["KlauWaard"]    = "tricksy"
omni.exceptions.sohtwo["Kt"]           = "ktkat"
omni.exceptions.sohtwo["Lasher"]       = "thearchitect"
omni.exceptions.sohtwo["Madcatz"]      = "mathizard"
omni.exceptions.sohtwo["Maerchyng"]    = "maerchyng"
omni.exceptions.sohtwo["Morrigu"]      = "morrigu"
omni.exceptions.sohtwo["OrcWarrior"]   = "sheepshagger"
omni.exceptions.sohtwo["Pane"]         = "painintheneck"
omni.exceptions.sohtwo["Plaideleon"]   = "crazycanadian"
omni.exceptions.sohtwo["Rekhart"]      = "hartsawreck"
omni.exceptions.sohtwo["Sarlock"]      = "l33td00d"
omni.exceptions.sohtwo["Tela"]         = "telllllllla"
omni.exceptions.sohtwo["Timeghost"]    = "floppyimm"
omni.exceptions.sohtwo["Tripitaka"]    = "laketripitaka"
omni.exceptions.sohtwo["Tymme"]        = "hourglass"
omni.exceptions.sohtwo["Vladia"]       = "sexyvamp"
omni.exceptions.sohtwo["Whitdjinn"]    = "thundercat"
omni.exceptions.sohtwo["WindJammer"]   = "justsomeimm"
omni.exceptions.sohtwo["Wolfe"]        = "likeobybutbritish"
omni.exceptions.sohtwo["Xyzzy"]        = "weirdcode"
omni.exceptions.sohtwo["Aerianne"]     = "pointyears"
omni.exceptions.sohtwo["Cadaver"]      = "newbiehater"
omni.exceptions.sohtwo["Delight"]      = "turkishdelight"
omni.exceptions.sohtwo["Dirtworm"]     = "wormy"
omni.exceptions.sohtwo["Eclaboussure"] = "dropbearimm"
omni.exceptions.sohtwo["Filt"]         = "plainolefilt"
omni.exceptions.sohtwo["Glimmer"]      = "betterhalfofclaire"
omni.exceptions.sohtwo["Kinson"]       = "upgradeboy"
omni.exceptions.sohtwo["Lumina"]       = "thievesrus"
omni.exceptions.sohtwo["Oladon"]       = "spellingbee"
omni.exceptions.sohtwo["Rhuli"]        = "rulistheworld"
omni.exceptions.sohtwo["Sausage"]      = "fatbreakfast"
omni.exceptions.sohtwo["Sirene"]       = "warriorprincess"
omni.exceptions.sohtwo["Takihisis"]    = "dragonlady"
omni.exceptions.sohtwo["Terrill"]      = "askcitron"
omni.exceptions.sohtwo["Tyanon"]       = "tieoneon"
omni.exceptions.sohtwo["Valkur"]       = "demonlord"
omni.exceptions.sohtwo["Vilgan"]       = "unabridged"
omni.exceptions.sohtwo["Xantcha"]      = "pokerimm"
omni.exceptions.sohtwo["Zane"]         = "inzanity"
omni.exceptions.sohtwo["Jaenelle"]     = "goodie"
omni.exceptions.sohtwo["Styliann"]     = "willyouhurryup"
omni.exceptions.sohtwo["Whisper"]      = "kinda"
omni.exceptions.sohtwo["Shen"]         = "master"
omni.exceptions.sohtwo["Mordist"]      = "complex"
omni.exceptions.sohtwo["Rezit"]        = "nascaard"
omni.exceptions.sohtwo["Penthesilea"]  = "pandemonium"
omni.exceptions.sohtwo["Guinness"]     = "cantwriteatall"
omni.exceptions.sohtwo["Paramore"]     = "failedmusician"
omni.exceptions.sohtwo["Neeper"]       = "sith"
omni.exceptions.sohtwo["Laren"]        = "lovethemsmurfs"
omni.exceptions.sohtwo["Citron"]       = "sober"
omni.exceptions.sohtwo["Arthon"]       = "airhead"
omni.exceptions.sohtwo["Dreamfyre"]    = "straight"
omni.exceptions.sohtwo["Flat"]         = "pancake"
omni.exceptions.sohtwo["Quadrapus"]    = "tjopping"
omni.exceptions.sohtwo["Claire"]       = "cookies"
omni.exceptions.sohtwo["Korridel"]     = "unremarkable"
omni.exceptions.sohtwo["Elvendar"]     = "omgsheneverstopstalking"
omni.exceptions.sohtwo["Anaristos"]    = "warsnail"
omni.exceptions.sohtwo["Xeno"]         = "onex"
omni.exceptions.sohtwo["Fenix"]        = "helper"
omni.exceptions.sohtwo["Koala"]        = "cuddlebear"

omni.exceptions.titan = {}
omni.exceptions.titan["A Water initiate"] = "water"

omni.exceptions.fortune = {}
omni.exceptions.fortune["The tome of law"]        = "tome"
omni.exceptions.fortune["The tome of accounting"] = "tome"
omni.exceptions.fortune["The tome of history"]    = "tome"
omni.exceptions.fortune["The tome of tactics"]    = "tome"

omni.exceptions.mistridge = {}
omni.exceptions.mistridge["Stratus Enor"] = "stratus"

omni.exceptions.thieves = {}
omni.exceptions.thieves["A demon of insanity"] = "demon"


function omni.getKeyword(who)
  if (who == nil) or (who == "") then
    omni.error("omni.getKeyword: missing \"who\" parameter")
    return "nil"
  end -- if

  local area = gmcp("room.info.zone")

  -- We want the last word in the short name phrase
  local keyword = who:gsub("^.* ", "")

  -- Check if there is a known keyword exception for this char.  First check if there is a nameShort match
  -- via the "who" parameter.  If we don't see a match there, also check the cruder keyword match as well.
  -- That helps with the SOH mob area.
  if (omni.exceptions[area] ~= nil) then
    if (omni.exceptions[area][who] ~= nil) then
      keyword = omni.exceptions[area][who]
    elseif (omni.exceptions[area][keyword] ~= nil) then
      keyword = omni.exceptions[area][keyword]
    end -- if
  end -- if

  -- If the keyword is hyphenated, use the first half of the word.  For example, Umari half-griffons
  -- all respond to "half" but only some (maybe half? *grin*) respond to "griffon".
  keyword = keyword:gsub("-.*$", "")

  if (keyword == "You") then
    keyword = gmcp("char.base.name") or "nil"
  end -- if

  -- kludge for known-mob areas
  if (area == "icefall") and (not omni.charsdb.isPlayer(keyword)) then
    local room = omni.getRoom()

    -- IF floor
    if (room >= 38701) and (room <= 38728) then
      keyword = "Icefall"
    end -- if
  end -- if

  return keyword

end -- omni.getKeyword


----------------------------------------------------------------------------------------------------------
-- Character (mob) database
----------------------------------------------------------------------------------------------------------

omni.charsdb        = {}
omni.charsdb.room   = {}
omni.charsdb.edit   = {}

omni.charsdb.sqlBase = "omni.sqlite"
omni.charsdb.sqlite  = GetInfo(66) .. omni.charsdb.sqlBase
omni.charsdb.dbname  = "charsdb"
omni.charsdb.isOpen  = false


function omni.charsdb.clean()
  local retval = DRL_RET_SUCCESS
  local retMush

  local didOpenDB = false
  if (not omni.charsdb.isOpen) then
    retMush = DatabaseOpen(omni.charsdb.dbname, omni.charsdb.sqlite, 6)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.clean: Failed to open database \"" .. omni.charsdb.sqlite .. "\"")
      return DRL_RET_INTERNAL_ERROR, nil
    end -- if
    omni.charsdb.isOpen = true
    didOpenDB = true
  end -- if

  DatabaseExec(omni.charsdb.dbname, "VACUUM;")

  if (didOpenDB) then
    retMush = DatabaseClose(omni.charsdb.dbname)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.clean: Failed to close database \"" .. omni.charsdb.sqlite .. "\"")
      retval = DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = false
  end -- if

  omni.print("@WDatabase cleanup completed")

  return retval
end -- omni.charsdb.clean


function omni.charsdb.reset()
  local retval = DRL_RET_SUCCESS
  local retMush

  local didOpenDB = false
  if (not omni.charsdb.isOpen) then
    retMush = DatabaseOpen(omni.charsdb.dbname, omni.charsdb.sqlite, 6)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.reset: Failed to open database \"" .. omni.charsdb.sqlite .. "\"")
      return DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = true
    didOpenDB = true
  end -- if

  retMush = DatabaseExec(omni.charsdb.dbname, [[
DROP TABLE IF EXISTS chars;
CREATE TABLE chars(
  nameKey      TEXT NOT NULL,
  nameShort    TEXT NOT NULL,
  nameLong     TEXT NOT NULL,
  area         TEXT,
  room         INT,
  charType     TEXT NOT NULL,
  popularity   INT,
  countQt      INT,
  countCp      INT,
  countGq      INT,
  align        TEXT,
  levelFloor   INT,
  levelCeiling INT,
  resists      TEXT
  );

DROP TABLE IF EXISTS rooms;
CREATE TABLE rooms(area TEXT NOT NULL, roomName TEXT NOT NULL, roomId int NOT NULL);

DROP TABLE IF EXISTS version;
CREATE TABLE version(name TEXT NOT NULL, major INT NOT NULL, minor INT NOT NULL);
INSERT INTO version (name, major, minor) VALUES ("version", 1, 0);
INSERT INTO version (name, major, minor) VALUES ("chars",   1, 0);
INSERT INTO version (name, major, minor) VALUES ("rooms",   1, 0);
  ]])

  if (retMush ~= sqlite3.OK) then
    omni.error("omni.charsdb.reset: Failed to execute reset on database \"" .. omni.charsdb.sqlite .. "\"")
    retval = DRL_RET_INTERNAL_ERROR
  end -- if

  -- Dropping a table doesn't actually free up space from that table.  We need VACUUM for that.
  retMush = DatabaseExec(omni.charsdb.dbname, "VACUUM;")

  -- Import room information from the aard database so that we do less work later
  omni.charsdb.room.import()

  if (didOpenDB) then
    retMush = DatabaseClose(omni.charsdb.dbname)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.reset: Failed to close database \"" .. omni.charsdb.sqlite .. "\"")
      retval = DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = false
  end -- if

  omni.print("@WDatabase reset completed")

  -- Perform an initial scan of players currently on the mud
  Execute("omni scan players")

  return retval
end -- omni.charsdb.reset


function omni.charsdb.set(nameKey, nameShort, nameLong, area, room, charType,
                          popularity, align, levelFloor, levelCeiling, resists)
  local retval = DRL_RET_SUCCESS
  local retMush
  local searchTab
  local sqlStr

  if (nameLong == nil) or (nameLong == "nil") or (nameLong == "") then
    return DRL_RET_INVALID_PARAM
  end -- if

  local didOpenDB = false
  if (not omni.charsdb.isOpen) then
    retMush = DatabaseOpen(omni.charsdb.dbname, omni.charsdb.sqlite, 6)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.set: Failed to open database \"" .. omni.charsdb.sqlite .. "\"")
      return DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = true
    didOpenDB = true
  end -- if

  -- Add an entry into the room table for this room if one does not yet exist
  omni.charsdb.room.set()

  local sqlSelect = "SELECT nameKey, nameShort, nameLong, area, room,     " ..
                    "charType, popularity, align, levelFloor, levelCeiling, resists "  ..
                    "FROM chars WHERE nameLong = \"" .. (nameLong or "nil") .. "\""    ..
                    "AND room = " .. (room or 0)

  retval, searchTab = omni.charsdb.select(sqlSelect)

  -- We should never have more than one hit for a long name + room query
  if (#searchTab > 1) then
    omni.error("omni.charsdb.set: Found " .. #searchTab .. " results for nameLong \"" .. nameLong .. "\"")
    retval = DRL_RET_INTERNAL_ERROR

  -- Insert it since this is the first time we've hit it
  elseif (#searchTab == 0) then

--[[FIXME ###: we shouldn't need this anymore since players are no longer included in the DB
    -- If this is a player, remove any previous entry in case the nameLong (i.e., title) field changed.
    -- We do not check the return value since this can report an error if no such entry actually exists
    -- (but that isn't an error in this case.)
    if omni.charsdb.isPlayer(nameKey) then
      DatabaseExec(omni.charsdb.dbname, "DELETE FROM chars WHERE nameKey = \"" .. nameKey .. "\";")
    end -- if
--]]

    sqlStr = string.format("INSERT INTO chars " ..
                           "(nameKey, nameShort, nameLong, area, room, " ..
                           "charType, popularity, align, levelFloor, levelCeiling, resists) " ..
                           "VALUES (\"%s\", \"%s\", \"%s\", \"%s\", %d, "   ..
                           "\"%s\", %d, \"%s\", %d, %d, \"%s\")",
                           (nameKey or "nil"), (nameShort or "nil"), (nameLong or "nil"),
                           (area or "nil"), (tonumber(room or "") or 0),
                           (charType or "nil"), (tonumber(popularity or "") or 0),
                           (align or "nil"), (tonumber(levelFloor or "") or 0),
                           (tonumber(levelCeiling or "") or 0), (resists or ""))

    --omni.print("Inserting sqlStr = " .. sqlStr)
    if omni.verbose.isEnabled() then
      omni.print("Character database: Adding \"@c" .. (nameLong or "nil") .. "@w\"")
    end -- if

  else
    local entry = searchTab[1]

    -- Check if the entry has been updated.  If so, update it in the database...
    if (nameKey      ~= entry.nameKey)      or
       (nameShort    ~= entry.nameShort)    or
       (nameLong     ~= entry.nameLong)     or
       (area         ~= entry.area)         or
       (room         ~= entry.room)         or
       (charType     ~= entry.charType)     or
       (popularity   ~= entry.popularity)   or
       (align        ~= entry.align)        or
       (levelFloor   ~= entry.levelFloor)   or
       (levelCeiling ~= entry.levelCeiling) or
       (resists      ~= entry.resists)      then

      sqlStr = string.format("UPDATE chars SET " ..
                             "nameKey      = \"%s\", " .. 
                             "nameShort    = \"%s\", " .. 
                             "nameLong     = \"%s\", " .. 
                             "area         = \"%s\", " .. 
                             "room         = %d,     " .. 
                             "charType     = \"%s\", " .. 
                             "popularity   = %d,     " .. 
                             "align        = \"%s\", " .. 
                             "levelFloor   = %d,     " .. 
                             "levelCeiling = %d,     " .. 
                             "resists      = \"%s\"  " ..
                             "WHERE nameLong = \"" .. nameLong .. "\"" ..
                             "AND room = " .. omni.getRoom(),
                             nameKey, nameShort, nameLong, area, room, charType,
                             popularity, align, levelFloor, levelCeiling, resists)
      --omni.print("Updating sqlStr = " .. sqlStr)

    else
      -- omni.print("No need to update entry for " .. (nameLong or "nil"))

    end -- if
  end -- if

  if (sqlStr ~= nil) then
    retMush = DatabaseExec(omni.charsdb.dbname, sqlStr)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.set: Failed to execute \"" .. omni.charsdb.sqlite .. "\": " ..
                 DatabaseError(omni.charsdb.dbname))
      retval = DRL_RET_INTERNAL_ERROR
    end -- if
  end -- if

  if (didOpenDB) then
    retMush = DatabaseClose(omni.charsdb.dbname)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.set: Failed to close database \"" .. omni.charsdb.sqlite .. "\": " ..
                 DatabaseError(omni.charsdb.dbname))
      retval = DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = false
  end -- if

  return retval
end -- omni.charsdb.set


function omni.charsdb.select(sqlStr)
  local retval = DRL_RET_SUCCESS 
  local retMush

  local didOpenDB = false
  if (not omni.charsdb.isOpen) then
    retMush = DatabaseOpen(omni.charsdb.dbname, omni.charsdb.sqlite, 6)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.select: Failed to open database \"" .. omni.charsdb.sqlite .. "\"")
      return DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = true
    didOpenDB = true
  end -- if

  retMush = DatabasePrepare(omni.charsdb.dbname, sqlStr)
  if (retMush ~= sqlite3.OK) then
    omni.error("omni.charsdb.select: Failed to execute \"" .. omni.charsdb.sqlite .. "\": " ..
               DatabaseError(omni.charsdb.dbname))
    omni.error("omni.charsdb.select: Failing sqlStr = \"" .. (sqlStr or "nil") .. "\"")
    retval = DRL_RET_INTERNAL_ERROR
  end -- if

  local resultTable = {}

  local colNames = DatabaseColumnNames(omni.charsdb.dbname)
  local numCols  = DatabaseColumns(omni.charsdb.dbname)
  local row      = DatabaseStep(omni.charsdb.dbname)

  while (row == sqlite3.ROW) do
    local entry = {}
    local values = DatabaseColumnValues(omni.charsdb.dbname)
    
    for i=1,numCols do
      entry[colNames[i]] = values[i]
    end -- for    

    table.insert(resultTable, entry)

    row = DatabaseStep(omni.charsdb.dbname)
  end -- while

  DatabaseFinalize(omni.charsdb.dbname)

  if (didOpenDB) then
    retMush = DatabaseClose(omni.charsdb.dbname)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.select: Failed to close database \"" .. omni.charsdb.sqlite .. "\": " ..
                 DatabaseError(omni.charsdb.dbname))
      retval = DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = false
  end -- if

  return retval, resultTable
end -- omni.charsdb.select


function omni.charsdb.isPlayer(name)
  local isPlayer    = false
  local playerShort = ""
  local charType    = "nil"
  local stripName   = ""

  -- The "notitle" option means that it's possible the name we see with a glance is just nameShort with
  -- a period on the end.
  if (name ~= nil) then
    stripName = string.sub(name, 1, -2) -- strip off the last char (e.g., a period)
  end -- if

  if (omni.scan.players.table[name] ~= nil) then
    isPlayer = true
    playerShort = omni.scan.players.table[name].nameShort
  elseif (omni.scan.players.table[stripName] ~= nil) then
    isPlayer = true
    playerShort = omni.scan.players.table[stripName].nameShort
  end -- if

  return isPlayer, playerShort
end -- omni.charsdb.isPlayer


function omni.charsdb.isGroupie(name)
  local members = gmcp("group.members")

  if (members ~= nil) and (members ~= "") then
    for i, val in ipairs(members) do
      if (val.name == name) then
        return true
      end -- if
    end -- for
  end -- if

  return false
end -- omni.charsdb.isGroupie


function omni.charsdb.room.import()
  local retval = DRL_RET_SUCCESS
  local aardDb   = GetInfo(66) .. "Aardwolf.db"
  local aardName = "aard"

  local retMush = DatabaseOpen(aardName, aardDb, 6)
  if (retMush ~= sqlite3.OK) then
    omni.error("omni.charsdb.room.import: Failed to open database \"" .. aardDb .. "\"")
    return DRL_RET_INTERNAL_ERROR
  end -- if

  retMush = DatabasePrepare(aardName, "SELECT uid, name, area FROM rooms WHERE uid != -1")
  if (retMush ~= sqlite3.OK) then
    omni.error("omni.charsdb.room.import: Failed to execute \"" .. aardDb .. "\": " ..
               DatabaseError(aardName))
    retval = DRL_RET_INTERNAL_ERROR
  end -- if

  local resultTable = {}

  local colNames = DatabaseColumnNames(aardName)
  local numCols  = DatabaseColumns(aardName)
  local row      = DatabaseStep(aardName)

  while (row == sqlite3.ROW) do
    local entry = {}
    local values = DatabaseColumnValues(aardName)
    
    for i=1,numCols do
      entry[colNames[i]] = values[i]
    end -- for    

    table.insert(resultTable, entry)

    row = DatabaseStep(aardName)
  end -- while

  DatabaseFinalize(aardName)

  retMush = DatabaseClose(aardName)
  if (retMush ~= sqlite3.OK) then
    omni.error("omni.charsdb.room.import: Failed to close database \"" .. aardDb .. "\": " ..
               DatabaseError(aardName))
    retval = DRL_RET_INTERNAL_ERROR
  end -- if

  if (#resultTable < 1) then
    omni.print("Skipping room import from Aardwolf.db, no rooms were found")
    return
  end -- if

  if (not omni.charsdb.isOpen) then
    omni.error("omni.charsdb.room.import: char database is not open")
    return DRL_RET_INTERNAL_ERROR
  end -- if

  local sqlResetStr = "INSERT INTO rooms (area, roomName, roomId) VALUES "
  local sqlStr      = sqlResetStr
  local bundleSize  = 500
  local numImported = 0
  for idx,roomEntry in ipairs(resultTable) do
    local suffix  = ","   
    local roomId  = tonumber(roomEntry.uid)
    local roomName = string.gsub(roomEntry.name, "\"", "") -- strip off double quotes

    if (roomId ~= nil) then
      if ((idx % bundleSize) == 0) or (idx == #resultTable) then
        suffix = ";"
      end -- if

      sqlStr = sqlStr .. "(\"" .. roomEntry.area .. "\", \"" .. roomName .. "\", \"" .. roomId .. "\")" .. suffix
      numImported = numImported + 1
    end -- if

    -- If this is the last room in a bundle or if it is the last room in the table, flush it
    if (suffix == ";") then
      retMush = DatabaseExec(omni.charsdb.dbname, sqlStr)
      if (retMush ~= sqlite3.OK) then
        omni.error("omni.charsdb.room.import: Failed to execute \"" .. omni.charsdb.sqlite .. "\": " ..
                   DatabaseError(omni.charsdb.dbname))
        omni.error("Failing SQL string = \"" .. sqlStr .. "\"")
        retval = DRL_RET_INTERNAL_ERROR
        break
      end -- if

      sqlStr = sqlResetStr
    end -- if

  end -- for

  omni.print("@WImport added @C" .. numImported .. "@W rooms from \"@c" .. aardDb .. "@W\"")

  return retval
end -- omni.charsdb.room.import


-- Note: This assumes that the DB is already open when the function is called
function omni.charsdb.room.set(area, room, roomId)
  -- If the user doesn't provide area/room/id then use the current room information
  local targetArea     = area   or omni.gmcp.currentZone  or "nil"
  local targetRoomName = room   or gmcp("room.info.name") or "nil"
  local targetRoomId   = roomId or omni.getRoom()         or -1

  local sqlSelect = "SELECT area, roomName, roomId FROM rooms WHERE roomId = " .. targetRoomId
  retval, searchTab = omni.charsdb.select(sqlSelect)
  if (#searchTab == 0) then
    -- The room doesn't have an entry yet.  Add it!
    local sqlStr = "INSERT INTO rooms (area, roomName, roomId) " ..
                   "VALUES (\"" .. targetArea .. "\", \"" .. targetRoomName .. "\", \"" .. targetRoomId .. "\");"
    DatabaseExec(omni.charsdb.dbname, sqlStr)
  end -- if
end -- omni.charsdb.room.set


function omni.charsdb.search(sqlQuery, doDisplay)
  local sqlSelect = "SELECT nameKey, nameShort, nameLong, area, room,     " ..
                    "charType, popularity, align, levelFloor, levelCeiling, resists "  ..
                    "FROM chars WHERE " .. (sqlQuery or "nil")

  --omni.print("omni.charsdb.search: sqlSelect=" .. sqlSelect)

  local retval, searchTab = omni.charsdb.select(sqlSelect)
  if (retval ~= DRL_RET_SUCCESS) then
    --omni.error("omni.charsdb.search: Failed to search database with query \"" .. (sqlQuery or "nil") .. "\"")

  elseif (doDisplay) then
    table.sort(searchTab, function (e1, e2) return e2.popularity < e1.popularity end)
    omni.charsdb.display(searchTab)
  end -- if

  return retval, searchTab
end -- omni.charsdb.search


function omni.charsdb.searchSerial(sqlQuery)
  local msg = ""

  local retval, searchArray = omni.charsdb.search(sqlQuery, false)
  if (retval == DRL_RET_SUCCESS) and (searchArray ~= nil) then
    msg = serialize.save("searchArray", searchArray)
  end -- if

  return msg
end -- omni.charsdb.searchSerial


function omni.charsdb.searchRooms(sqlQuery)
  local sqlSelect = "SELECT area, roomName, roomId FROM rooms WHERE " .. (sqlQuery or "nil")
  local msg = ""

  --omni.print("omni.charsdb.searchRooms: sqlSelect=" .. sqlSelect)

  local retval, searchArray = omni.charsdb.select(sqlSelect)
  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.charsdb.searchRooms: Failed to search database with query \"" ..
     (sqlQuery or "nil") .. "\"")
  else
    msg = serialize.save("searchArray", searchArray)
  end -- if

  return msg
end -- omni.charsdb.searchRooms


function omni.charsdb.display(charTable)
  local numMatches = 0
  if (charTable ~= nil) then
    numMatches = #charTable
  end -- if

  local outMsg = "Search found " .. numMatches .. " entries"

  if (numMatches > 0) then
    for i,entry in ipairs(charTable) do
      -- Display everything with a popularity > 0 and up to 10 entries with popularity of 0
      if (i > 10) and (entry.popularity == 0) then
        break
      end -- if

      local color = "@c"
      if (i % 2 ~= 0) then
        color = "@C"
      end -- if
      local divider   = color .. "@x039|" .. color
      local keyTrunc  = string.sub((entry.nameKey or "nil"), 1, 12)
      local longTrunc = string.sub((entry.nameLong or "nil"), 1, 45)
      local curLine = string.format("\n%s%2d%s%5d%s%-10s%s%-12s%s%-45s%s",
                                    divider,
                                    entry.popularity, divider,
                                    entry.room,       divider,
                                    entry.area,       divider,
                                    keyTrunc,         divider,
                                    longTrunc,        divider)
      outMsg = outMsg .. curLine
    end -- for
  end -- if

  omni.print(outMsg)
end -- omni.charsdb.display


function omni.charsdb.edit.nameKey(nameKey, sqlQuery)
  return omni.charsdb.edit.full(nameKey, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, sqlQuery)
end -- omni.charsdb.edit.nameKey


function omni.charsdb.edit.full(nameKey, nameShort, nameLong, area, room, charType, popularity,
                                align, levelFloor, levelCeiling, resists, sqlQuery)
  local didOpenDB = false
  if (not omni.charsdb.isOpen) then
    retMush = DatabaseOpen(omni.charsdb.dbname, omni.charsdb.sqlite, 6)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.select: Failed to open database \"" .. omni.charsdb.sqlite .. "\"")
      return DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = true
    didOpenDB = true
  end -- if

  local retval, searchTab = omni.charsdb.search(sqlQuery, false)

  if (#searchTab > 0) then
    for i,entry in ipairs(searchTab) do

      -- If the user gave us an updated field, use it.  Otherwise, use what we had previously.
      -- Note: we never update the nameLong or room fields because those are what define a mob entry.
      --local curNameLong   = nameLong     or entry.nameLong
      --local curRoom       = room         or entry.room
      local curNameKey      = nameKey      or entry.nameKey
      local curNameShort    = nameShort    or entry.nameShort
      local curArea         = area         or entry.area
      local curCharType     = charType     or entry.charType
      local curPopularity   = popularity   or entry.popularity
      local curAlign        = align        or entry.align
      local curLevelFloor   = levelFloor   or entry.levelFloor
      local curLevelCeiling = levelCeiling or entry.levelCeiling
      local curResists      = resists      or entry.resists

      sqlStr = string.format("UPDATE chars SET " ..
                             "nameKey      = \"%s\", " .. 
                             "nameShort    = \"%s\", " .. 
                             "nameLong     = \"%s\", " .. 
                             "area         = \"%s\", " .. 
                             "room         = %d,     " .. 
                             "charType     = \"%s\", " .. 
                             "popularity   = %d,     " .. 
                             "align        = \"%s\", " .. 
                             "levelFloor   = %d,     " .. 
                             "levelCeiling = %d,     " .. 
                             "resists      = \"%s\"  " ..
                             "WHERE nameLong = \"" .. entry.nameLong .. "\"" ..
                             "AND room = " .. entry.room,
                             curNameKey, curNameShort, entry.nameLong, curArea, entry.room,
                             curCharType, curPopularity, curAlign, curLevelFloor,
                             curLevelCeiling, curResists)
      --omni.print("omni.charsdb.edit.full: sqlStr = " .. sqlStr)
      DatabaseExec(omni.charsdb.dbname, sqlStr)
    end -- for
  end -- if

  omni.print("Updated " .. #searchTab .. " database entries")

  if (didOpenDB) then
    retMush = DatabaseClose(omni.charsdb.dbname)
    if (retMush ~= sqlite3.OK) then
      omni.error("omni.charsdb.select: Failed to close database \"" .. omni.charsdb.sqlite .. "\": " ..
                 DatabaseError(omni.charsdb.dbname))
      retval = DRL_RET_INTERNAL_ERROR
    end -- if
    omni.charsdb.isOpen = false
  end -- if

  return retval
end -- omni.charsdb.edit.full


----------------------------------------------------------------------------------------------------------
-- Global plugin enable
----------------------------------------------------------------------------------------------------------

omni.varName = "omniState"


function omni.set(mode)

  if (mode ~= "on") and (mode ~= "off") then
    omni.error("omni.set: Invalid mode \"" .. (mode or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  SetVariable(omni.varName, mode)

  local msg
  if (mode == "on") then
    msg = "@GENABLED@w"
    omni.scan.timer.init()

    if omni.miniwin.isEnabled() then
      omni.miniwin.show()
    end -- if
  else
    msg = "@RDISABLED@w"
    omni.scan.timer.fini()

    if omni.miniwin.isEnabled() then
      omni.miniwin.hide()
    end -- if
  end -- if

  omni.print("@WOmni plugin is " .. msg)

  return DRL_RET_SUCCESS
end -- omni.set


function omni.get()
  local mode = GetVariable(omni.varName)

  if (mode == nil) or (mode == "") then
    mode = "on"
    omni.set(mode) -- default mode
  end -- if

  return mode
end -- omni.get


function omni.isEnabled(mode)
  if (omni.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.isEnabled


----------------------------------------------------------------------------------------------------------
-- Char discovery
----------------------------------------------------------------------------------------------------------

omni.discover = {}

omni.discover.room    = 0
omni.discover.varName = "omniDiscoverState"


function omni.discover.cli(mode)
  if (mode == nil) or (mode == "") then
    omni.scan.consider.process(true)
  else
    omni.discover.set(mode)
  end -- if

end -- omni.discover.cli


function omni.discover.set(mode)

  if (mode ~= "on") and (mode ~= "off") then
    omni.error("omni.discover.set: Invalid discover mode \"" .. (mode or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  SetVariable(omni.discover.varName, mode)

  local msg
  if (mode == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WDiscover mode is " .. msg)

  return DRL_RET_SUCCESS
end -- omni.discover.set


function omni.discover.get()
  return (GetVariable(omni.discover.varName) or "")
end -- omni.discover.get


function omni.discover.isEnabled(mode)
  if (omni.discover.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.discover.isEnabled


----------------------------------------------------------------------------------------------------------
-- Reporting options
----------------------------------------------------------------------------------------------------------

omni.report = {}

omni.report.varName = "omniReportState"


function omni.report.cli(switch, mode)

  if (switch == nil) or (mode == nil) then
    omni.report.chars()

  elseif (switch == "all") then
    omni.report.set("mob",       mode)
    omni.report.set("grp",       mode)
    omni.report.set("~grp",      mode)
    omni.report.set("grp-area",  mode)
    omni.report.set("~grp-area", mode)
    omni.report.set("area",      mode)
    omni.report.set("hp",        mode)
    omni.report.set("hpp",       mode)
    omni.report.set("qt",        mode)
    omni.report.set("tnl",       mode)
    omni.report.set("mv",        mode)
    omni.report.set("mv",        mode)
    omni.report.set("tgt",       mode)
    omni.report.set("dmg",       mode)
    omni.report.set("narea",     mode)

  elseif (switch == "mob")       or
         (switch == "grp")       or
         (switch == "~grp")      or
         (switch == "grp-area")  or
         (switch == "~grp-area") or
         (switch == "area")      or
         (switch == "hp")        or
         (switch == "hpp")       or
         (switch == "qt")        or
         (switch == "tnl")       or
         (switch == "mv")        or
         (switch == "mn")        or
         (switch == "tgt")       or
         (switch == "dmg")       or
         (switch == "narea")     then

    omni.report.set(switch, mode)

  end -- if

end -- omni.report.cli


function omni.report.set(switch, mode)

  if (mode ~= "on") and (mode ~= "off") then
    omni.error("omni.report.set: Invalid report mode \"" .. (mode or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  -- Variables don't like it if you have a "~" or "-" in the name...
  local varName = omni.report.varName
  if (switch == "~grp") then
    varName = varName .. "notgrp"
  elseif (switch == "grp-area") then
    varName = varName .. "grparea"
  elseif (switch == "~grp-area") then
    varName = varName .. "notgrparea"
  else
    varName = varName .. switch
  end -- if

  SetVariable(varName, mode)

  local msg
  if (mode == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WReport mode for \"" .. (switch or "nil") .. "\" is " .. msg)

  -- Request a rescan if reporting changed in some way
  omni.scan.timer.room.requested = true

  return DRL_RET_SUCCESS
end -- omni.report.set


function omni.report.get(switch)

  local varName = omni.report.varName
  if (switch == "~grp") then
    varName = varName .. "notgrp"
  elseif (switch == "grp-area") then
    varName = varName .. "grparea"
  elseif (switch == "~grp-area") then
    varName = varName .. "notgrparea"
  else
    varName = varName .. switch
  end -- if

  local varValue = GetVariable(varName) or "nil"

  -- Turn some modes on by default
  if (varValue == "nil") then
    local defaultModeList = "mob grp ~grp grp-area ~grp-area narea qt"

    for mode in defaultModeList:gmatch("%S+") do
      if (switch == mode) then
        varValue = "on"
        omni.report.set(mode, varValue)
        break
      end -- if
    end -- for
  end -- if

  return varValue

end -- omni.report.get


function omni.report.isEnabled(mode)
  local isEnabled = false

  if (mode == nil) or (mode == "") then
    if (omni.report.get("mob")       == "on") or
       (omni.report.get("grp")       == "on") or
       (omni.report.get("~grp")      == "on") or
       (omni.report.get("grp-area")  == "on") or
       (omni.report.get("~grp-area") == "on") or
       (omni.report.get("area")      == "on") or
       (omni.report.get("hp")        == "on") or
       (omni.report.get("hpp")       == "on") or
       (omni.report.get("qt")        == "on") or
       (omni.report.get("tnl")       == "on") or
       (omni.report.get("mv")        == "on") or
       (omni.report.get("mn")        == "on") or
       (omni.report.get("tgt")       == "on") or
       (omni.report.get("dmg")       == "on") or
       (omni.report.get("narea")     == "on") then
      isEnabled = true
    end -- if

  elseif (omni.report.get(mode) == "on") then
    isEnabled = true
  end -- if

  return isEnabled
end -- omni.report.isEnabled


omni.report.colorGroup  = "@x159"
omni.report.colorNGroup = "@x141"
omni.report.colorMob    = "@G"

function omni.report.getColor(nameKey)
  local color = omni.miniwin.graph.color
  local charColor, charVal = "", 0

  for i,scanEntry in ipairs(omni.scan.table) do
    if (nameKey == scanEntry.nameKey) or (nameKey == scanEntry.nameShort) then
      if (scanEntry.isPlayer) then
        if (scanEntry.inGroup) or (scanEntry.nameKey == gmcp("char.base.name")) then
          charColor = omni.report.colorGroup
          charVal   = color.group
        else
          charColor = omni.report.colorNGroup
          charVal   = color.ngroup
        end -- if
      elseif ((scanEntry.animated == true) or (scanEntry.charmed == true) or (scanEntry.isDivine)) then
        charColor = "@c"
        charVal   = color.divine
      elseif (scanEntry.good == true) then
        charColor = "@y"
        charVal   = color.good
      elseif (scanEntry.evil == true) then
        charColor = "@r"
        charVal   = color.evil
      else
        charColor = "@w"
        charVal   = color.neutral
      end -- if

      break
    end -- if
  end -- for

  return charColor, charVal
end -- omni.report.getColor


function omni.report.sortByStats(players)
  if (players ~= nil) and (#players > 0) then
    for i, entry in ipairs(players) do
      if (entry.stats == nil) or (entry.stats == 0) then
        return
      end -- if
    end -- for

    table.sort(players, function (e1, e2) return e2.stats < e1.stats end)
  end -- if
end -- omni.report.sortByStats


function omni.report.chars(target)

  local mobStr         = ""
  local numMobs        = 0
  local numAllies      = 0
  local numEnemies     = 0
  local numArea        = 0
  local numAreaAllies  = 0
  local numAreaEnemies = 0

  if (omni.scan.swho.area.table ~= nil) then
    local sortedPlayers = {}

    for player, areaEntry in pairs(omni.scan.swho.area.table) do
      table.insert(sortedPlayers, areaEntry)
    end -- for

    omni.report.sortByStats(sortedPlayers)

    for idx, areaEntry in ipairs(sortedPlayers) do
      local flagsLen = #strip_colours(areaEntry.flags)
      local nameWidth = 16
      local mergeName = string.sub(areaEntry.name, 1, nameWidth - flagsLen)
      mergeName = mergeName .. string.rep(" ", nameWidth - string.len(mergeName) - flagsLen) .. areaEntry.flags
      local charColor = ""

      -- Use different colors for players in your group (including just you if you aren't in a group) and 
      -- players not in your group
      if omni.charsdb.isGroupie(areaEntry.name) or (areaEntry.name == gmcp("char.base.name")) then
        if omni.report.isEnabled("grp-area") then
          charColor = omni.report.colorGroup
        end -- if
        numAreaAllies = numAreaAllies + 1
      else
        if omni.report.isEnabled("~grp-area") then
          charColor = omni.report.colorNGroup
        end -- if
        numAreaEnemies = numAreaEnemies + 1
      end -- if

      if (charColor ~= "") then
        mobStr = string.format("%s%-10s @x039| %s%s @x039| @W%3d : %4d\n",
                               mobStr, areaEntry.clan, charColor, mergeName, areaEntry.level, areaEntry.stats)
        numArea = numArea + 1
      end -- if
    end -- for

    if (numArea > 0) then
      if omni.miniwin.isEnabled() then
        mobStr = mobStr .. "@w\n"
      else
        mobStr = "@x039" .. string.rep("-", 49) .. "@w\n" .. mobStr .. "@x039" .. string.rep("-", 49) .. "@w\n"
      end -- if
    end -- if

  end -- if

  for i,mob in ipairs(omni.scan.table) do
    local mobColor
    local showChar = false

    if (mob.inGroup) or (mob.nameKey == gmcp("char.base.name")) then
      if omni.report.isEnabled("grp") then
        showChar = true
      end -- if
      numAllies = numAllies + 1
      mobColor = omni.report.colorGroup

    elseif (mob.isPlayer) and (not mob.inGroup) then
      if omni.report.isEnabled("~grp") then   
        showChar = true
      end -- if
      numEnemies = numEnemies + 1
      mobColor = omni.report.colorNGroup

    elseif (not mob.isPlayer) then
      if omni.report.isEnabled("mob") then
        showChar = true
      end -- if
      numMobs = numMobs + 1
      if ((mob.animated == true) or (mob.charmed == true) or (mob.isDivine)) then
        mobColor = "@c"
      elseif (mob.good == true) then
        mobColor = "@y"
      elseif (mob.evil == true) then
        mobColor = "@r"
      else
        mobColor = "@w"
      end -- if
    end -- if

    if (showChar) then
      -- Highlight a specific mob if the user requested that
      if (mob.dotName == target) then
        mobColor = "@x208"
      end -- if

      mobStr = mobStr .. string.format("@W%2d @x039| ", i)

      if (mob ~= nil) and (mob.hpPercent ~= nil) and (tonumber(mob.hpPercent or "") ~= nil) and
         omni.report.isEnabled("hp") then
        local hpPercent = tonumber(mob.hpPercent or "")
        local hpColor
        if (hpPercent == 100) then
          hpColor = "@W"
        elseif (hpPercent > 85) then
          hpColor = "@G"
        elseif (hpPercent > 70) then
          hpColor = "@g"
        elseif (hpPercent > 55) then
          hpColor = "@Y" 
        elseif (hpPercent > 40) then
          hpColor = "@y"
        elseif (hpPercent > 25) then
          hpColor = "@x201"
        elseif (hpPercent > 10) then
          hpColor = "@x198"
        else
          hpColor = "@x196"
        end -- if

        mobStr = mobStr .. string.format("%s %3d%% @x039| ", hpColor, hpPercent)
      elseif (mob.wounded == true) then
        mobStr = mobStr .. "@rWound @x039| "
      else
        mobStr = mobStr .. "@w----- @x039| "
      end -- if

      local target      = ""
      local targetColor = ""
      local targetName  = ""
      if (mob.target ~= nil) and (mob.target ~= "") then
        targetColor = omni.report.getColor(mob.target)
        targetName = mob.target
      end -- if
      target = string.format("@w--> %s%-20s", targetColor, string.sub(targetName, 1, 20))

      -- See how many chars are targeting each groupie
      local numAttackers = 0
      local attackStr = ""
      if (mob.inGroup) or (mob.nameKey == gmcp("char.base.name")) then
        for _,attacker in ipairs(omni.scan.table) do
          if (mob.nameKey == attacker.target) or (mob.nameShort == attacker.target) then
            numAttackers = numAttackers + 1
          end -- if
        end -- for
        mob.numAttackers = numAttackers

        if (numAttackers > 0) then
          attackStr = "@r (@R" .. numAttackers .. "@r) "
        end -- if
      end -- if

      local nameSuffix = ""
      if (mob.isQuest == true) then
        nameSuffix = " @W[@RQ@W]@w"
      end -- if

      local startSanc = ""
      local endSanc   = ""
      local numCharsInName
      local nameFieldWidth = 16

      if (mob.sanc == true) then
        startSanc = "@W("
        endSanc   = "@W)"
      end -- if      

      if (string.match(mob.dotName, "%d+.nil") ~= nil) then
        mob.dotName = "Pending..."
      end -- if

      local formattedChars = startSanc .. mobColor .. endSanc .. nameSuffix .. attackStr
      numCharsInName = nameFieldWidth - string.len(strip_colours(formattedChars))
      local truncName = string.sub((mob.dotName or "nil"), 1, numCharsInName)
      local formattedMob = startSanc ..  mobColor .. truncName .. endSanc .. nameSuffix
      local numSpaces = nameFieldWidth - string.len(strip_colours(truncName)) -
                        string.len(strip_colours(formattedChars))
      if (numSpaces < 0) then
        numSpaces = 0
      end -- if

      mobStr = mobStr .. formattedMob .. string.rep(" ", numSpaces) .. attackStr .. target

      if (i ~= #omni.scan.table) then
        mobStr = mobStr .. "\n@w"
      end -- if
    end -- if

  end -- for

  if omni.miniwin.isEnabled() then
    omni.report.roomMobs = numMobs
    omni.report.roomGroup = numAllies
    omni.report.roomNGroup = numEnemies
    omni.report.areaGroup = numAreaAllies
    omni.report.areaNGroup = numAreaEnemies

    if omni.miniwin.mode.isEnabled("basic") then
      omni.miniwin.write(mobStr, true)
    end -- if
    omni.miniwin.draw()
  else
    local roomSummary = string.format("@WRoom %sMobs %d %sGrp %d %s~Grp %d   " ..
                                      "@WArea %sGrp %d %s~Grp %d",
                                      omni.report.colorMob, numMobs,
                                      omni.report.colorGroup, numAllies,
                                      omni.report.colorNGroup, numEnemies,
                                      omni.report.colorGroup, numAreaAllies,
                                      omni.report.colorNGroup, numAreaEnemies)
    mobStr = roomSummary .. "\n" .. mobStr
    omni.print(mobStr)
  end -- if

  return mobStr

end -- omni.report.chars


----------------------------------------------------------------------------------------------------------
-- Command alias routines
----------------------------------------------------------------------------------------------------------

omni.alias = {}
omni.alias.table = {}


omni.alias.defaults = 
  {
    -- Kill the first mob you see in the room
    "omni alias create default " ..
      "command kill #target "    ..
      "query   target 1 minHP any maxHP any wound any mob yes grp no algn any sanc any minLvl any maxLvl any",

    -- BS the 2nd mob in the room that is not wounded (fall back to the first mob if only one mob left)
    "omni alias create bandit " ..
      "command bs #target "     ..
      "query   target 2 minHP any maxHP any wound no mob yes grp no algn any sanc any minLvl any maxLvl any",

    -- BS the 2nd mob in the room that is not wounded while skipping sanc'ed mobs
    "omni alias create banditns " ..
      "command bs #target "     ..
      "query   target 2 minHP any maxHP any wound no mob yes grp no algn any sanc no minLvl any maxLvl any",

    -- BS the last mob in the room that is betwen 80-100% hp
    "omni alias create bandit-reverse " ..
      "command bs #target "             ..
      "query   target -1 minHP 80 maxHP 100 wound any mob yes grp no algn any sanc any minLvl any maxLvl any",

    -- Perform a single backstab on each mob in the room starting at the back of the room.  The process is to
    -- first "omni execute bandit-next" and then do "omni execute next" repeatedly to hit the remaining mobs.
    "omni alias create bandit-next " ..
      "command bs #target "                   ..
      "query   target -1 minHP any maxHP any wound any mob yes grp no algn any sanc any minLvl any maxLvl any",

    -- Perform a single backstab on each mob in the room starting at the back of the room.  The process is to
    -- first "omni execute bandit-nextns" and then do "omni execute next" repeatedly to hit the remaining mobs.
    "omni alias create bandit-nextns " ..
      "command bs #target "                   ..
      "query   target -1 minHP any maxHP any wound no mob yes grp no algn any sanc no minLvl any maxLvl any",

    -- Perform a single attack on each mob in the room starting at the back of the room.  The process is to
    -- first "omni execute navi-next" and then do "omni execute next" repeatedly to hit the remaining mobs.
    "omni alias create navi-next " ..
      "command c mega #target "                   ..
      "query   target -1 minHP any maxHP any wound any mob yes grp no algn any sanc any minLvl any maxLvl any",

    -- Similar to "bandit" but it only targets mobs between 80-100% hp that do not have sanc
    "omni alias create bandit-no-sanc " ..
      "command bs #target "            ..
      "query   target 2 minHP 80 maxHP 100 wound any mob yes grp no algn any sanc no minLvl any maxLvl any",

    -- BS the 2nd mob in the room with 80-100% hp that has an evil align
    "omni alias create bandit-evil " ..
      "command bs #target "          ..
      "query   target 2 minHP 80 maxHP 100 wound any mob yes grp no algn evil sanc any minLvl any maxLvl any",

    -- BS the 2nd mob in the room with 80-100% hp that has a good align
    "omni alias create bandit-good " ..
      "command bs #target "          ..
      "query   target 2 minHP 80 maxHP 100 wound any mob yes grp no algn good sanc any minLvl any maxLvl any",

    -- BS the 2nd mob in the room with 80-100% hp that has a neutral align
    "omni alias create bandit-neut " ..
      "command bs #target "          ..
      "query   target 2 minHP 80 maxHP 100 wound any mob yes grp no algn neut sanc any minLvl any maxLvl any",

    "omni alias create deso " ..
      "command c deso #target "    ..
      "query   target 1 minHP any maxHP any wound any mob yes grp no algn any sanc any minLvl any maxLvl any",

    -- Cast desolation on the first mob in the room until it has less than 40% hp.  Then switch to the 2nd
    -- mob in the room (presumably so melee can finish the 1st mob).  The intent is to never break combat
    -- and always have at least one mob under attack.
    "omni alias create deso2 " ..
      "command c deso #target "    ..
      "query   target 1 minHP any maxHP any wound no mob yes grp no algn any sanc any minLvl any maxLvl any",

    -- Target the first player not in your group that has less than 30% hp
    "omni alias create pk-coup-de-grace " ..
      "command spiral #target "           ..
      "query   target 1 minHP 0 maxHP 30 wound any mob no grp no algn any sanc any minLvl any maxLvl any",

    -- Cast restore on the first person in your group with under 30% hp
    "omni alias create restore-weak-groupie " ..
      "command c restore #target "            ..
      "query   target 1 minHP 0 maxHP 30 wound any mob no grp yes algn any sanc any minLvl any maxLvl any",

    -- BS the first mob in the room that matches a name in our hitlist
    "omni alias create hitlist " ..
      "command kill #target "     ..
      "query   target 1 minHP any maxHP any wound any mob yes grp no algn any sanc any hitlist yes",

  }


function omni.alias.save()
  local serializedData = serialize.save("omni.alias.table", omni.alias.table)
  --omni.print("omni.alias.save: serialized data= " .. (serializedData or "nil"))

  SetVariable("omniAliasTable", serializedData)
end -- omni.alias.save


function omni.alias.load()
  local tableString = GetVariable("omniAliasTable") or ""
  if (tableString == "") then
    omni.alias.reset()
    omni.alias.save()
  else
    loadstring(tableString)()
  end -- if
end -- omni.alias.load


function omni.alias.init()
  omni.alias.executePkg = nil
end -- omni.alias.init


function omni.alias.fini()
  -- placeholder
end -- omni.alias.fini


function omni.alias.reset()
  omni.alias.table = {}

  for i,val in ipairs(omni.alias.defaults) do
    Execute(val)
  end -- for

  omni.print("@WAll aliases have been reset to their default values")
end -- omni.alias.reset


omni.alias.queryKeys = { target  = "number",
                         minhp   = "number",
                         maxhp   = "number",
                         wound   = "yes no any",
                         mob     = "yes no any",
                         grp     = "yes no any",
                         algn    = "good evil neut any",
                         sanc    = "yes no any",
                         minlvl  = "number",
                         maxlvl  = "number",
                         hitlist = "yes no any",
                         command = "string" }


function omni.alias.create(aliasName, commandStr, queryStr, isTemporary)
  local retval = DRL_RET_SUCCESS

  if (aliasName == nil) or (aliasName == "") then
    omni.error("omni.alias.create: invalid alias name parameter \"" .. (aliasName or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  if (commandStr == nil) or (commandStr == "") then
    omni.error("omni.alias.create: invalid command string parameter \"" .. (commandStr or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  if (queryStr == nil) or (queryStr == "") then
    omni.error("omni.alias.create: invalid query string parameter \"" .. (queryStr or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  aliasEntry = {}
  aliasEntry.command = commandStr

  local idx = 1
  local key, value

  for element in string.lower(queryStr):gmatch("%S+") do
    
    if ((idx % 2) ~= 0) then
      if (omni.alias.queryKeys[element] == nil) then
        omni.error("omni.alias.create: Invalid keyword \"" .. (element or "nil") .. "\"")
        return DRL_RET_INVALID_PARAM
      end -- if

      key = element
    else
      aliasEntry[key] = element
    end -- if

    idx = idx + 1
  end -- for

  -- If this isn't a temporary alias, save it in our alias table
  if (not isTemporary) then
    omni.alias.table[aliasName] = aliasEntry
    omni.alias.save()
  end -- if

  return DRL_RET_SUCCESS, aliasEntry

end -- omni.alias.create


function omni.alias.delete(aliasName)
  if (aliasName == nil) or (aliasName == "") then
    omni.error("omni.alias.delete: invalid alias name parameter \"" .. (aliasName or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if
  
  if (aliasName == "default") then
    omni.error("omni.alias.delete: You cannot delete the default alias.")
    return DRL_RET_INVALID_PARAMETER
  end -- if

  omni.alias.table[aliasName] = nil
  omni.alias.save()

  return DRL_RET_SUCCESS
end -- omni.alias.delete


function omni.alias.display(aliasName)
  local sortedAliases = {}
  for key,val in pairs(omni.alias.table) do
    table.insert(sortedAliases, { key=key, val=val })
  end -- for
  table.sort(sortedAliases,
             function (e1, e2)
               if (e1.key < e2.key) then
                 return true
               else
                 return false
               end -- if
             end) -- function
  
  local horiz = "@x039---------------------|-------------------|------|-----|-----|-----|-----|-----|------|------|-----|-----|@w\n"
  local header = "@W        alias        @x039|@W      command      @x039|@W tgt# @x039|@W >HP @x039|@W <HP @x039|@W wnd @x039|@W mob @x039|@W grp @x039|@W algn @x039|@W sanc @x039|@W <lv @x039|@W >lv @x039|@w\n"

  local msg = "Aliases\n" .. horiz .. header .. horiz
  local default = omni.alias.table["default"]

  for i,entry in ipairs(sortedAliases) do
    local key = entry.key
    local val = entry.val

    local color
    if ((i % 2) ~= 0) then
      color = "@C"
    else
      color = "@c"
    end -- if

    if (aliasName == nil) or (aliasName == "") or (aliasName == key) then
      msg = msg .. string.format("%s%-20s @x039|"  ..  -- alias name
                                 "%s %-17s @x039|" ..  -- command
                                 "%s %4s @x039|"   ..  -- target #
                                 "%s %3s @x039|"   ..  -- minHP
                                 "%s %3s @x039|"   ..  -- maxHP
                                 "%s %3s @x039|"   ..  -- wounded
                                 "%s %3s @x039|"   ..  -- mob
                                 "%s %3s @x039|"   ..  -- grp
                                 "%s %4s @x039|"   ..  -- align
                                 "%s %4s @x039|"   ..  -- sanc
                                 "%s %3s @x039|"   ..  -- minlvl
                                 "%s %3s @x039|"   ..  -- maxlvl
                                 "@w\n",
                                 color, key,
                                 color, val.command or default.command,
                                 color, val.target  or default.target,
                                 color, val.minhp   or default.minhp,
                                 color, val.maxhp   or default.maxhp,
                                 color, val.wound   or default.wound,
                                 color, val.mob     or default.mob,
                                 color, val.grp     or default.grp,
                                 color, val.algn    or default.algn,
                                 color, val.sanc    or default.sanc,
                                 color, val.minlvl  or default.minlvl,
                                 color, val.maxlvl  or default.maxlvl)
                                 
      msg = msg .. horiz
    end -- if
  end -- for

  omni.print(msg)
end -- omni.alias.display


function omni.alias.command(command, query)
  return omni.alias.execute("temporary", 0, command, query)
end -- omni.alias.command


omni.alias.executePkg = nil

function omni.alias.execute(aliasName, targetNum, command, query)
  local retval = DRL_RET_SUCCESS

  if (aliasName == nil) or (aliasName == "") or 
     ((aliasName ~= "next") and (aliasName ~= "temporary") and (omni.alias.table[aliasName] == nil)) then
    omni.error("omni.alias.execute: invalid alias name parameter \"" .. (aliasName or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if
 
  if (omni.alias.executePkg ~= nil) then
    omni.error("omni.alias.execute: Skipping request because another request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.alias.executePkg            = {}
  omni.alias.executePkg.aliasName  = aliasName
  omni.alias.executePkg.targetNum  = targetNum
  omni.alias.executePkg.command    = command
  omni.alias.executePkg.query      = query

  -- If we aren't in a co-routine already, start one for the alias.execute request
  if (coroutine.running() == nil) then
    wait.make(omni.alias.executeCR)
  else
    -- We are being called from a co-routine so we can make a direct call to the co-routine
    retval = omni.alias.executeCR()
  end -- if

  return retval

end -- omni.alias.execute


function omni.alias.executeCR()
  local retval = DRL_RET_SUCCESS

  if (omni.alias.executePkg == nil) then
    omni.error("omni.alias.executeCR: package is nil!?!")
    return DRL_RET_INTERNAL_ERROR
  end -- if

  local entry
  local cmd           = ""
  local target        = ""
  local totalChars    = 0
  local matchingChars = 0

  -- If we are hitting the "next" alias, use the details from the previous request.  Otherwise, find
  -- out what to do in the alias table.
  if (omni.alias.executePkg.aliasName == "next") then
    entry = omni.query.roomEntry
  elseif (omni.alias.executePkg.command ~= nil) and (omni.alias.executePkg.query ~= nil) then
    retval, entry = omni.alias.create(omni.alias.executePkg.aliasName, omni.alias.executePkg.command,
                                      omni.alias.executePkg.query, true)
  else
    entry = omni.alias.table[omni.alias.executePkg.aliasName]
  end -- if

  if (entry == nil) then
    omni.error("omni.alias.executeCR: alias \"" .. omni.alias.executePkg.aliasName .. "\" does not exist")
    omni.alias.executePkg = nil
    return DRL_RET_INTERNAL_ERROR
  end -- if

  -- Fill in default values if the entry doesn't have everything specified
  for defaultKey, defaultVal in pairs(omni.alias.table["default"]) do
    if (entry[defaultKey] == nil) then
      entry[defaultKey] = defaultVal
    end -- if
  end -- for

  if (entry.minhp ~= "any") or (entry.maxhp ~= "any") or omni.report.isEnabled("hp") then
    retval = omni.scan.study.process(false)
    if (retval ~= DRL_RET_SUCCESS) and (retval ~= DRL_RET_BUSY) then
      omni.error("omni.alias.executeCR: scan failed: " .. omni.retval.getString(retval))
    end -- if
  else
    retval = omni.scan.glance.process(false)
    if (retval == DRL_RET_BUSY) then
      -- If the glance was busy because another glance -- maybe from a room timer -- was in progress, then we 
      -- simply wait for the first glance to complete.  We can piggyback off of it instead of doing a new one.
      local totTime, timeout, periodSec = 0, 5, 0.1
      while (totTime <= timeout) do
        -- If the user disconnected and we aren't initialized, return immediately and rely on the init/fini code
        -- to clean everything up
        if (omni.isInitialized == false) then
          return DRL_RET_UNINITIALIZED  
        end -- if

        if (omni.scan.glancePkg == nil) then
          break
        end -- if
        wait.time(periodSec)
        totTime = totTime + periodSec
      end -- while

    elseif (retval ~= DRL_RET_SUCCESS) then
      omni.error("omni.alias.executeCR: glance failed: " .. omni.retval.getString(retval))
    end -- if
  end -- if

  if (omni.alias.executePkg.aliasName == "next") then
    if (#omni.query.roomResult > 0) then
      matchingChars = #omni.query.roomResult
      totalChars    = #omni.scan.table
      target        = table.remove(omni.query.roomResult, 1)
    end -- if
    retval = DRL_RET_SUCCESS
  else
    retval, target, totalChars, matchingChars = omni.query.room(entry, omni.alias.executePkg.targetNum) 
  end -- if

  -- If a matching target exists, use it!
  if (target ~= nil) and (target ~= "") then
    cmd = string.gsub(entry.command, "#target", target)
    local what
    if (omni.alias.executePkg.aliasName == "temporary") then
      what = "custom command"
    else
      what = omni.alias.executePkg.aliasName .. (omni.alias.executePkg.targetNum or "")
    end -- if

    ColourNote("white", "green",  " OMNI: " .. "Executing " .. what ..
               ": " .. cmd .. " (" .. matchingChars .. "/" .. totalChars .. " characters selected) ")

  elseif (retval == DRL_RET_RETRY) then
    -- Study and glance didn't sync (maybe a mob changed rooms or died in between those calls).  This isn't
    -- an error, it just means that we couldn't identify which mobs to target based on HP since the HP data
    -- wasn't available at this time.  Retry!
    cmd = "echo @x105[@x039OMNI@x105]@w @WPlease retry request@w"
    --ColourNote("black", "orange",  " OMNI: " ..
    --           "Please retry request: a mob changed rooms or died before HP data could be used ")
  else
    cmd = "echo @x105[@x039OMNI@x105]@w @WNo mobs found@w"
    retval = DRL_RET_MISSING_ENTRY
  end -- if

  -- Do whatever we're supposed to do...
  Execute(cmd)

  if omni.report.isEnabled() and (totalChars ~= nil) and (totalChars > 0) then
    omni.highlight = target
    omni.report.chars(target)
  end -- if

  BroadcastPlugin(tostring(retval), tostring(matchingChars))

  omni.alias.executePkg = nil
  return retval

end -- omni.alias.executeCR


omni.query            = {}
omni.query.roomResult = {}
omni.query.roomEntry  = {}

function omni.query.room(queryTable, preferredTarget)
  if (queryTable == nil) then
    omni.error("omni.query.room: query table parameter is missing")
    return DRL_RET_INTERNAL_ERROR, nil, nil, nil
  end -- if

  local targetIdx, targetStr
  if (preferredTarget ~= nil) and (preferredTarget ~= "") then
    targetStr = preferredTarget
  else
    targetStr = queryTable.target
  end -- if

  targetIdx = tonumber(targetStr or "")
  if (targetIdx == nil) then
    omni.error("omni.query.room: Invalid target \"" .. (targetStr or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM, nil, nil, nil
  end -- if

  local retval        = DRL_RET_SUCCESS
  local targetKey     = ""
  local totalChars    = 0
  local matchingChars = 0

  -- Store the most recent entry so that we know how to handle things if there is a "next" request
  omni.query.roomResult = {}
  omni.query.roomEntry  = queryTable

  for i, val in ipairs(omni.scan.table) do

    -- Check if HP values are used and the study operation didn't sync.  In that case, return with
    -- an error code that lets the caller know to retry the operation.  This isn't an error, it just
    -- means that there were different #s of mobs in the room at the time of study and the time of
    -- glance.  This could happen if a mob or player entered or left the room or died at an inopportune
    -- time (between the study and glance commands).
    if ((queryTable.minhp ~= "any") or (queryTable.maxhp ~= "any")) and (val.hpPercent == nil) then
      return DRL_RET_RETRY, nil, 0, 0
    end -- if

    if -- Check if we can target the char
       (val.isDivine  ~= true)     and -- don't include NPCs that we can't attack
       (val.charType  ~= "divine") and
       (val.charType  ~= "pet")    and -- don't include pets in the list
       (val.charmed   ~= true)     and 
       (val.animated  ~= true)     and 
       (val.nameShort ~= omni.scan.unidentified) and

       -- Exception list: mobs we don't want to target (FIXME: move to DB?)
       (val.nameKey   ~= "Salkin")         and -- Salkin, room 38210
       (val.nameKey   ~= "Pliny")          and -- Pompeii, room 62
       (val.nameShort ~= "A void warrior") and -- magic-immune annoying mobs in earthlords :P

       -- HP
       ((queryTable.minhp == "any") or 
        ((val.hpPercent ~= nil) and (tonumber(queryTable.minhp or "0") <= val.hpPercent))) and
       ((queryTable.maxhp == "any") or
        ((val.hpPercent ~= nil) and (tonumber(queryTable.maxhp or "0") >= val.hpPercent))) and

       -- Wounded flag
       ((queryTable.wound  == "any")                            or
        ((queryTable.wound == "yes") and (val.wounded == true)) or
        ((queryTable.wound == "no")  and (val.wounded ~= true))) and

       -- Player
       (((queryTable.mob == "no")  and (val.isPlayer == true)) or
        ((queryTable.mob == "yes") and (val.isPlayer ~= true))) and

       -- Group
       (((queryTable.grp == "no")  and (val.inGroup ~= true)) or
        ((queryTable.grp == "yes") and (val.inGroup == true))) and

       -- Sanctuary
       ((queryTable.sanc == "any")                            or
        ((queryTable.sanc == "yes") and (val.sanc == true))   or
        ((queryTable.sanc == "no")  and (val.sanc ~= true))) and

       -- Level
       ((queryTable.minlvl == "any") or
        ((val.levelFloor ~= nil) and (queryTable.minlvl <= val.levelFloor)))  and 
       ((queryTable.maxlvl == "any") or
        ((val.levelCeiling ~= nil) and (queryTable.maxlvl <= val.levelCeiling))) and

       -- Align
       ((queryTable.algn == "any")                          or
        ((queryTable.algn == "good") and (val.good == true)) or
        ((queryTable.algn == "evil") and (val.evil == true)) or
        ((queryTable.algn == "neut") and (val.good ~= true) and (val.evil ~= true))) and

       -- Hitlist (quest, campaign, and gquest mobs)
       ((queryTable.hitlist == "any") or (queryTable.hitlist == "") or (queryTable.hitlist == nil) or
        ((queryTable.hitlist == "yes") and omni.hitlist.isHitlist(val.nameShort)))
    then
      if (targetIdx > 0) and (#omni.query.roomResult >= targetIdx) then
        -- placeholder: we keep track of the matches even if they are beyond our target index
      else
        table.insert(omni.query.roomResult, 1, (val.dotName or "nil"))
      end -- if

      matchingChars = matchingChars + 1
    end -- if
  end -- for

  -- Pop off some entries if we aren't starting right at the end
  while (targetIdx + 1 < 0) do
    table.remove(omni.query.roomResult, 1)
    matchingChars = matchingChars - 1
    targetIdx = targetIdx + 1
  end -- while

  local totalChars = #omni.scan.table

  if (#omni.query.roomResult > 0) then
    targetKey = table.remove(omni.query.roomResult, 1)
  end -- if

  return retval, targetKey, totalChars, matchingChars
end -- omni.query.room


----------------------------------------------------------------------------------------------------------
-- Commlog access
----------------------------------------------------------------------------------------------------------

omni.commlog = {}


function omni.commlog.set(enable)
  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.commlog.set: invalid commlog mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("commlogState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WMirroring to communication log is " .. msg)

end -- omni.commlog.set


function omni.commlog.get()
  return (GetVariable("commlogState") or "")
end -- omni.commlog.get


function omni.commlog.isEnabled()
  if (omni.commlog.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.commlog.isEnabled


----------------------------------------------------------------------------------------------------------
-- Verbose access
----------------------------------------------------------------------------------------------------------

omni.verbose = {}


function omni.verbose.set(enable)
  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.verbose.set: invalid verbose mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("verboseState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WVerbose logging is " .. msg)

end -- omni.verbose.set


function omni.verbose.get()
  return (GetVariable("verboseState") or "")
end -- omni.verbose.get


function omni.verbose.isEnabled()
  if (omni.verbose.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.verbose.isEnabled


----------------------------------------------------------------------------------------------------------
-- Help screens
----------------------------------------------------------------------------------------------------------

omni.help = {}


function omni.help.set(enable)
  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.help.set: invalid help mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("helpState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WStartup help screen is " .. msg)

end -- omni.help.set


function omni.help.get()
  return (GetVariable("helpState") or "")
end -- omni.help.get


function omni.help.isEnabled()
  local status = omni.help.get()

  if (status == nil) or (status == "") then
    -- Turn the help on by default
    status = "on"
    omni.help.set(status)
  end -- if

  if (status == "on") then
    return true
  else
    return false
  end -- if
end -- omni.help.isEnabled


function omni.help.usage()

omni.printColors([[
@x039-----------------------------------------------------------------------------------------------@w
@x039OMNI: Omniscient plugin to track everything happening around you
@x039-----------------------------------------------------------------------------------------------@w

  @cSpecify contents of room scan reports@w
    @womni @Wreport                                @x173-- Immediately display known status@w
    @womni @Wreport all        [on|off]            @x173-- Toggle all room reporting options@w
    @womni @Wreport mob        [on|off]            @x173-- Include mob status in room scans@w
    @womni @Wreport grp        [on|off]            @x173-- Include in-room group players in scans@w
    @womni @Wreport ~grp       [on|off]            @x173-- Include in-room non-group players in scans@w
    @womni @Wreport grp-area   [on|off]            @x173-- Include in-area group players in scans@w
    @womni @Wreport ~grp-area  [on|off]            @x173-- Include in-area non-group players in scans@w
    @womni @Wreport hp         [on|off]            @x173-- Include hp% in scans (requires study)@w

  @cExecute commands on specific targets@w
    @womni @Wexecute <alias> (<target #>)          @x173-- Run commands as defined by an alias@w
    @womni @Wexecute next                          @x173-- Move to the next target in an alias@w
    @womni @Wexecute command <commands> query <query>

  @cAlias management@w
    @womni @Walias create  <alias> command <commands> query <query>
    @womni @Walias delete  <alias>                 @x173-- Delete an alias@w
    @womni @Walias display (<alias>)               @x173-- Display all aliases or a specific one@w
    @womni @Walias reset                           @x173-- Reset all aliases back to default values@w

  @cMob and player database@w
    @womni @Wdatabase reset                        @x173-- Clear all contents of your database@w
    @womni @Wdatabase clean                        @x173-- Compact database by cleaning it@w
    @womni @Wdatabase search  [sqlQuery]           @x173-- Search for mobs matching the SQL query@w
    @womni @Wdatabase keyword [keywords] query [sqlQuery]

  @cBackups@w
    @womni @Wbackup [on|off]                       @x173-- Enable/disable auto-backups@w
    @womni @Wbackup [create|delete|restore] <name> @x173-- Create, delete, or restore a backup@w
    @womni @Wbackup list                           @x173-- Display list of existing backups

  @cAdvanced options@w
    @womni @W          [on|off]                    @x173-- Enable/disable auto room/area/player scans@w
    @womni @Wdiscover ([on|off])                   @x173-- Auto-add mobs/players into database@w
    @womni @Wwin       [on|off|reset]              @x173-- Display reports in miniwindow@w
    @womni @Wscan      [players|area|room] (<sec>) @x173-- Scan mobs & characters (optional timer)@w
    @womni @Wverbose   [on|off]                    @x173-- Use detailed reporting messages@w
    @womni @Wcommlog   [on|off]                    @x173-- Mirror omni messages to the commlog@w
    @womni @Whelp      [on|off]                    @x173-- Display the usage screen at startup@w
    @womni @Woptions                               @x173-- Report state of all configurable options@w
    @womni @Wreload                                @x173-- Reload the omni plugin@w

  @cPlugin info@w
    @womni @Wversion                               @x173-- Report the omni plugin's version@w
    @womni @Whelp                                  @x173-- Display the usage screen@w

@x039-----------------------------------------------------------------------------------------------@w
]])
end -- omni.help.usage


----------------------------------------------------------------------------------------------------------
-- Plugin information
----------------------------------------------------------------------------------------------------------

function omni.version()
  omni.print("Version: " .. omni.ver)
end -- omni.version


----------------------------------------------------------------------------------------------------------
-- Configuration options
----------------------------------------------------------------------------------------------------------

omni.options = {}


function omni.options.report()
  local onStr  = "@GON @w"
  local offStr = "@ROFF@w"

  local omniEnable = offStr
  if omni.isEnabled() then
    omniEnable = onStr
  end -- if

  local omniDiscover = offStr
  if omni.discover.isEnabled() then
    omniDiscover = onStr
  end -- if

  local omniMiniwin = offStr
  if omni.miniwin.isEnabled() then
    omniMiniwin = onStr
  end -- if

  local omniBackup = offStr
  if omni.backup.isEnabled() then
    omniBackup = onStr
  end -- if

  local omniReportMob = offStr
  if omni.report.isEnabled("mob") then
    omniReportMob = onStr
  end -- if

  local omniReportGroup = offStr
  if omni.report.isEnabled("grp") then
    omniReportGroup = onStr
  end -- if

  local omniReportNotGroup = offStr
  if omni.report.isEnabled("~grp") then
    omniReportNotGroup = onStr
  end -- if

  local omniReportGroupArea = offStr
  if omni.report.isEnabled("grp-area") then
    omniReportGroupArea = onStr
  end -- if

  local omniReportNotGroupArea = offStr
  if omni.report.isEnabled("~grp-area") then
    omniReportNotGroupArea = onStr
  end -- if

  local omniReportHp = offStr
  if omni.report.isEnabled("hp") then
    omniReportHp = onStr
  end -- if

  local omniReportHpp = offStr
  if omni.report.isEnabled("hpp") then
    omniReportHpp = onStr
  end -- if

  local omniTimerArea = omni.scan.timer.get("area")
  if (omniTimerArea == 0) then
    omniTimerArea = offStr
  else
    omniTimerArea = string.format("@G%-3d@w", omniTimerArea)
  end -- if

  local omniTimerPlayers = omni.scan.timer.get("players")
  if (omniTimerPlayers == 0) then
    omniTimerPlayers = offStr
  else
    omniTimerPlayers = string.format("@G%-3d@w", omniTimerPlayers)
  end -- if
  
  local omniTimerRoom = omni.scan.timer.get("room")
  if (omniTimerRoom == 0) then
    omniTimerRoom = offStr
  else
    omniTimerRoom = string.format("@G%-3d@w", omniTimerRoom)
  end -- if

  local omniVerbose = offStr
  if omni.verbose.isEnabled() then
    omniVerbose = onStr
  end -- if

  local omniCommlog = offStr
  if omni.commlog.isEnabled() then
    omniCommlog = onStr
  end -- if

  local omniHelp = offStr
  if omni.help.isEnabled() then
    omniHelp = onStr
  end -- if

  local horiz=
    "@x039-----------------------------------------------------------------------------------------------@w\n"
  local reportStr = ""
  reportStr = reportStr .. "Configuration options"                           .. "\n"
  reportStr = reportStr .. horiz
  reportStr = reportStr .. "@womni @W                  [on|off] " .. omniEnable     ..
              " @x173-- Auto-scan rooms/area/players\n"
  reportStr = reportStr .. "@womni @Wdiscover          [on|off] " .. omniDiscover   ..
              " @x173-- Auto-discover players and mobs\n"
  reportStr = reportStr .. "@womni @Wwin               [on|off] " .. omniMiniwin   ..
              " @x173-- Display reports in a miniwindow\n"
  reportStr = reportStr .. "@womni @Wbackup            [on|off] " .. omniBackup   ..
              " @x173-- Perform automated backups\n"
  reportStr = reportStr .. horiz
  reportStr = reportStr .. "@womni @Wreport mob        [on|off] " .. omniReportMob   ..
              " @x173-- Include mob status in room scans\n"
  reportStr = reportStr .. "@womni @Wreport grp        [on|off] " .. omniReportGroup ..
              " @x173-- Include in-room group players in scans\n"
  reportStr = reportStr .. "@womni @Wreport ~grp       [on|off] " .. omniReportNotGroup ..
              " @x173-- Include in-room non-group players in scans\n"
  reportStr = reportStr .. "@womni @Wreport grp-area   [on|off] " .. omniReportGroupArea  ..
              " @x173-- Include in-area group players in scans\n"
  reportStr = reportStr .. "@womni @Wreport ~grp-area  [on|off] " .. omniReportNotGroupArea  ..
              " @x173-- Include in-area non-group players in scans\n"
  reportStr = reportStr .. "@womni @Wreport hp         [on|off] " .. omniReportHp  ..
              " @x173-- Include HP% in room scans (adds study overhead)\n"
--  reportStr = reportStr .. "@womni @Wreport hpp        [on|off] " .. omniReportHpp  ..
--              " @x173-- Show group HP total instead of missing HP\n"
  reportStr = reportStr .. horiz
  reportStr = reportStr .. "@womni @Wscan area         <period> " .. omniTimerArea    ..
              " @x173-- Auto-scan area players every <period> seconds\n"
  reportStr = reportStr .. "@womni @Wscan players      <period> " .. omniTimerPlayers ..
              " @x173-- Auto-scan online players every <period> seconds\n"
  reportStr = reportStr .. "@womni @Wscan room         <period> " .. omniTimerRoom    ..
              " @x173-- Auto-scan your room every <period> seconds\n"
  reportStr = reportStr .. horiz
  reportStr = reportStr .. "@womni @Wverbose           [on|off] " .. omniVerbose ..
              " @x173-- Use detailed reporting\n"
  reportStr = reportStr .. "@womni @Wcommlog           [on|off] " .. omniCommlog ..
              " @x173-- Mirror messages to the commlog\n"
  reportStr = reportStr .. "@womni @Whelp              [on|off] " .. omniHelp ..
              " @x173-- Display the usage screen at startup@w\n"
  reportStr = reportStr .. horiz

  omni.print(reportStr)

  return reportStr
end -- omni.options.report


----------------------------------------------------------------------------------------------------
-- Module to handle saving and backing up the database and state
----------------------------------------------------------------------------------------------------
--
-- MUSHclient
--   omni.sqlite
--   omni.sqlite.auto1-[date]
--   omni.sqlite.auto2-[date]
--   omni.sqlite.auto3-[date]
--   omni.sqlite.[name]-[date]
--
-- Functions:
--  omni.backup.init
--  omni.backup.fini
--
--  omni.backup.cli()
--  omni.backup.set(enable)
--  omni.backup.get()
--  omni.backup.isEnabled(enable)
--
--  omni.backup.getBackups() -- returns list of backup dir names
--  omni.backup.getFile(name)
--
--  omni.backup.current()    -- if auto1-date ~= current date, rotates current and the "autoN" backups
--
--  omni.backup.list()
--  omni.backup.create(name)
--  omni.backup.delete(name, isQuiet)
--  omni.backup.restore(name)
--
--  omni.backup.timer
--
----------------------------------------------------------------------------------------------------

omni.backup = {}

omni.backup.timer = {}
omni.backup.timer.name = "drlInvBackupTimer"
omni.backup.timer.hour = 4
omni.backup.timer.min  = 0
omni.backup.timer.sec  = 10

omni.backup.dir      = GetInfo(66)
omni.backup.name     = omni.charsdb.sqlBase
omni.backup.nameFull = omni.backup.dir .. omni.backup.name


function omni.backup.init()
  local retval = DRL_RET_SUCCESS

  -- Add a backup timer to periodically back up the plugin state.  We keep the timer running
  -- even if automatic backups are currently disabled.  The omni.backup.current() function
  -- only does the backup if automatic backups are enabled so it doesn't hurt to call it
  -- periodically from the timer.  Yes, I should probably redo this so that we start the
  -- timer when someone re-enables automatic backups but I'm feeling a bit lazy and this
  -- only runs once every 4 hours by default so there's not a ton of overhead...
  check (AddTimer(omni.backup.timer.name, 
                  omni.backup.timer.hour, omni.backup.timer.min, omni.backup.timer.sec, "",
                  timer_flag.Enabled + timer_flag.Replace,
                  "omni.backup.current"))

  return retval
end -- omni.backup.init


function omni.backup.fini()
  local retval = DRL_RET_SUCCESS

  DeleteTimer(omni.backup.timer.name)

  -- If auto-backups are enabled, perform a backup before we leave
  if (omni.isInitialized and omni.backup.isEnabled()) then
    omni.backup.current()
  end -- if

  return retval
end -- omni.backup.fini


function omni.backup.cli(mode, file)
  if (mode == "create") then
    --omni.print("Creating backup \"" .. (file or "nil") .. "\"")
    omni.backup.create(file)

  elseif (mode == "delete") then
    --omni.print("Deleting backup \"" .. (file or "nil") .. "\"")
    omni.backup.delete(file, false)

  elseif (mode == "restore") then
    --omni.print("Restoring backup \"" .. (file or "nil") .. "\"")
    omni.backup.restore(file)

  else
    omni.error("omni.backup.cli: Invalid mode \"" .. (mode or "nil") .. "\"")

  end -- if
end -- omni.backup.cli


function omni.backup.set(enable)
  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.backup.set: invalid help mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("backupState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WAutomated backups are " .. msg)

end -- omni.backup.set


function omni.backup.get()
  return (GetVariable("backupState") or "")
end -- omni.backup.get


function omni.backup.isEnabled()
  local status = omni.backup.get()

  if (status == nil) or (status == "") then
    -- Turn automatic backups on by default
    status = "on"
    omni.backup.set(status)
  end -- if

  if (status == "on") then
    return true
  else
    return false
  end -- if
end -- omni.backup.isEnabled


-- Returns an array of backup directory names
function omni.backup.getBackups()
  local backupNames = {}

  -- Read the backup list.  We use the unix-style pathname because the utils.readdir()
  -- function won't take the windows-style path.  Yeah, I know that seems crazy.  I'm probably
  -- doing something silly that prevents it from working.  The unix-style paths aren't too evil
  -- as a work-around though.
  local backupQuery = string.gsub(omni.backup.nameFull, "\\", "/") .. "*"
  local backupTable, error = utils.readdir(backupQuery)
  if (backupTable == nil) then
    return backupNames, DRL_RET_MISSING_ENTRY
  end -- if

  -- Loop through every directory entry and pull out all of the files that have the
  -- omni.sqlite.[name]-[timestamp] format.  Those are our backup candidates.
  for backName, backEntry in pairs(backupTable) do
    local _, _, baseName, baseTime = string.find(backName, omni.backup.name .. "%.(.*)-(%d+)$")
    baseTime = tonumber(baseTime or 0)

    if (baseName ~= nil) then
      table.insert(backupNames, { dirName  = omni.backup.dir,
                                  fullName = backName,
                                  baseName = baseName,
                                  baseTime = baseTime })
    end -- if
  end -- for

  -- Sort the backups by date from most recent to oldest
  if (#backupNames > 0) then
    table.sort(backupNames, function (back1, back2) return back1.baseTime > back2.baseTime end)
  end -- if

  return backupNames, DRL_RET_SUCCESS
end -- omni.backup.getBackups


-- Returns a table holding info on the specific backup or nil if it doesn't exist, error code
function omni.backup.getFile(name)

  local backupNames, retval = omni.backup.getBackups()
  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.backup.getFileName: Failed to get backup list: " .. omni.retval.getString(retval))
    return nil, retval
  end -- if

  for _, backupName in ipairs(backupNames) do
    if (backupName.baseName == name) then
      return backupName, DRL_RET_SUCCESS
    end -- if
  end -- for

  return nil, DRL_RET_SUCCESS
end -- omni.backup.getFile(name)


function omni.backup.list()
  local backupNames, retval = omni.backup.getBackups()

  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.backup.list: Failed to get backup list: " .. omni.retval.getString(retval))
  elseif (backupNames == nil) or 
         ((backupNames ~= nil) and (#backupNames == 0)) then
    omni.print("No backups detected")
  else
    local suffix = ""
    if (#backupNames ~= 1) then
      suffix = "s"
    end -- if

    local outMsg = "Detected " .. #backupNames .. " backup" .. suffix .. "\n"
    for _, backupName in ipairs(backupNames) do
      outMsg = outMsg .. "  @W(@c" .. os.date("%c", backupName.baseTime) .. "@W) @G" ..
               backupName.baseName .. "\n"
    end -- if
    omni.print(outMsg)
  end -- if

  return retval
end -- omni.backup.list


function omni.backup.create(name)
  local retval = DRL_RET_SUCCESS

  if (name == nil) or (name == "") then
    omni.error("omni.backup.create: Missing name parameter")
    return DRL_RET_INVALID_PARAM
  end -- if

  -- Remove any old backups with the same name.  Creating a backup "foo" will remove any previous
  -- backups that were created with the name "foo".
  retval = omni.backup.delete(name, nil, true)
  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.backup.create: Failed to remove old backup \"@G" .. name .. "@W\"" ..
              omni.retval.getString(retval))
    return retval
  end -- if

  -- We append the time to the end of the backup name to help track it
  local backupTime = omni.getTime()
  local cmd = "copy /B \"" .. omni.backup.nameFull .. "\" \"" .. omni.backup.nameFull .. "." ..
              name .. "-" .. backupTime .. "\" > nul"

  retval = omni.shell(cmd)
  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.backup.create: Failed to create backup, xcopy shell failed: " ..
              omni.retval.getString(retval))
  else
    omni.print("Created backup @W(@c" .. os.date("%c", backupTime) .. "@W) @G" .. name)
  end -- if

  return retval
end -- omni.backup.create


function omni.backup.delete(name, isQuiet)
  local retval = DRL_RET_SUCCESS

  if (name == nil) or (name == "") then
    omni.error("omni.backup.delete: Missing name parameter")
    return DRL_RET_INVALID_PARAM
  end -- if

  local backupNames, retval = omni.backup.getBackups()
  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.backup.delete: Failed to get backup list: " .. omni.retval.getString(retval))
    return retval
  end -- if

  -- Check if the backup name we want to delete is one of the available backups and whack it if it is
  local numBackupsDeleted = 0
  for _, backupName in ipairs(backupNames) do
    if (backupName.baseName == name) then

      local cmd = "del /Q \"" .. backupName.dirName .. backupName.fullName .. "\" > nul"
      omni.shell(cmd)

      -- Shell commands running in the background aren't guaranteed to complete in the order
      -- they were made.  As a result, we spin here until we know that the backup was actually
      -- renamed before we move on to the next backup.
      retval = omni.spinWhileExistsBusy("\"" .. backupName.dirName .. backupName.fullName .. "\"", 2)
      if (retval ~= DRL_RET_SUCCESS) then
        omni.error("omni.backup.delete: Failed to delete backup \"@G" .. name .. "@W\": " ..
                   omni.retval.getString(retval))
        break
      else
        if (isQuiet == false) then
          omni.print("Deleted backup @W(@c" .. os.date("%c", backupName.baseTime) ..
                     "@W) @G" .. backupName.baseName)
        end -- if
      end -- if
      numBackupsDeleted = numBackupsDeleted + 1
    end -- if
  end -- if

  if (numBackupsDeleted == 0) and (isQuiet == false) then
    omni.print("Failed to delete backup: No backups matching name \"@G" .. name .. "@w\" were found")
  end -- if

  return retval
end -- omni.backup.delete


function omni.backup.restore(name)
  local retval = DRL_RET_SUCCESS

  if (name == nil) or (name == "") then
    omni.error("omni.backup.restore: Missing name parameter")
    return DRL_RET_INVALID_PARAM
  end -- if

  local backupNames, retval = omni.backup.getBackups()
  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.backup.restore: Failed to get backup list: " .. omni.retval.getString(retval))
    omni.backup.restorePkg = nil
    return retval
  end -- if

  -- Check if the backup name we want to restore is one of the available backups and use it if it is
  local didRestore = false
  for _, backupName in ipairs(backupNames) do
    if (backupName.baseName == name) then
      omni.print("Restoring backup @W(@c" .. os.date("%c", backupName.baseTime) ..
                "@W) @G" .. backupName.baseName)

      local cmd = "copy /B \"" .. backupName.dirName .. backupName.fullName .. "\" \"" ..
                  omni.backup.nameFull .. "\" > nul"
      retval = omni.shell(cmd)

      didRestore = true
      break -- Don't restore multiple backups if they have the same name but a different date
    end -- if
  end -- if

  if (not didRestore) and (retval == DRL_RET_SUCCESS) then
    omni.error("Failed to restore backup \"@G" .. name .. "@W\": could not find backup")
    retval = DRL_RET_MISSING_ENTRY
  end -- if

  return retval
end -- omni.backup.restore


-- The automatic backup scheme: auto --> auto2 --> auto3
omni.backup.inProgress = false
function omni.backup.current()
  local retval
  local backupFile
  local autoPrefix = "auto"
  local maxNumAutoBackups = 3
  local newestBackupName = autoPrefix
  local oldestBackupName = autoPrefix .. maxNumAutoBackups

  if (not omni.backup.isEnabled()) then
    return DRL_RET_SUCCESS
  end -- if

  if omni.inCombat() then
    omni.print("Skipping automatic backup: You are in combat!  We'll try again later.")
    return DRL_RET_IN_COMBAT
  end -- if

  if omni.backup.inProgress then
    omni.print("Skipping backup request: another backup request is in progress")
    return DRL_RET_BUSY
  end -- if

  omni.backup.inProgress = true

  -- Check if the newest backup was made today.  If it was, update it with the current data, leave
  -- the other backups alone, and return.  Otherwise, rotate the backups down one slot chronologically.
  backupFile, retval = omni.backup.getFile(newestBackupName)
  if (backupFile ~= nil) then
    if (os.date("%x", omni.getTime()) == os.date("%x", backupFile.baseTime)) then
      retval = omni.backup.create(newestBackupName, nil)
      if (retval ~= DRL_RET_SUCCESS) then
        omni.error("omni.backup.current: Failed to create newest automatic backup \"@G" .. newestBackupName ..
                  "@W\": " .. omni.retval.getString(retval))
      end -- if
      omni.backup.inProgress = false
      return retval
    end -- if
  end -- if  

  -- We need to rotate the backups.  Whack the oldest auto backup if we have hit our max number of
  -- supported auto backups.
  backupFile, retval = omni.backup.getFile(oldestBackupName)
  if (backupFile ~= nil) then
    retval = omni.backup.delete(oldestBackupName)
    if (retval ~= DRL_RET_SUCCESS) then
      omni.error("omni.backup.current: Failed to delete backup \"@G" .. oldestBackupName .. "@W\"" ..
                omni.retval.getString(retval))
    end -- if
  end -- if

  -- Now rename any other auto backups by bumping them back in the order (e.g., auto2 --> auto3)
  for backupNum = (maxNumAutoBackups - 1), 1, -1 do
    local currentBackup = autoPrefix .. backupNum
    local olderBackup = autoPrefix .. (backupNum + 1)

    -- As a one-off, we don't call the most recent backup "auto1".  Instead, we just call it "auto".
    -- I think this is a little more clear and it looks cleaner when the user sees that we just made
    -- a backup named "auto".
    if (backupNum == 1) then
      currentBackup = autoPrefix
    end -- if

    currentFile, retval = omni.backup.getFile(currentBackup)
    if (currentFile ~= nil) then
      omni.print("Moving backup \"@G" .. currentBackup .. "@W\" to \"@G" .. olderBackup .. "@W\"")
      local currentFull = currentFile.dirName .. currentFile.fullName
      local olderFull = string.gsub(currentFull, currentBackup, olderBackup)

      local cmd = "copy /B \"" .. currentFull .. "\" \"" .. olderFull .. "\" > nul"
      --omni.print("omni.backup.current: cmd=" .. cmd)
      retval = omni.shell(cmd)

      -- Shell commands running in the background aren't guaranteed to complete in the order
      -- they were made.  As a result, we spin here until we know that the backup was actually
      -- renamed before we move on to the next backup.
      omni.spinUntilExistsBusy(olderFull, 2)
      omni.backup.delete(currentBackup)
    end -- if
  end -- for

  -- Finally, create a new auto backup by mirroring the current state
  retval = omni.backup.create(newestBackupName, nil)
  if (retval ~= DRL_RET_SUCCESS) then
    omni.error("omni.backup.current: Failed to create newest automatic backup \"@G" .. newestBackupName ..
              "@W\": " .. omni.retval.getString(retval))
  end -- if

  omni.backup.inProgress = false
  return retval
end -- omni.backup.current


----------------------------------------------------------------------------------------------------------
-- Core helper functions
----------------------------------------------------------------------------------------------------------

function omni.printFormat(msg)
  local formattedMsg = ""

  if (msg ~= nil) and (msg ~= "") then

    local outerColor = "@x105"
    local innerColor = "@x39"

    formattedMsg = outerColor .. "[" .. innerColor .. omni.name .. outerColor .. "]@w " .. msg .. "@w"
  end -- if

  return formattedMsg
end -- omni.printFormat


function omni.printColors(msg)
  print(AnsiNote(stylesToANSI(ColoursToStyles(msg))))
end -- omni.printColors


function omni.print(msg)
  if (msg ~= nil) and (msg ~= "") then
    local formattedMsg = omni.printFormat(msg)
    omni.printColors(formattedMsg)

    -- If the user wants us to mirror messages to the commlog, do it :)
    local commlogState = omni.commlog.get()
    if (commlogState == "on") then
      omni.commLog(formattedMsg)
    end -- if
  end -- if

end -- omni.print()


function omni.error(msg)
  if (msg ~= nil) and (msg ~= "") then
    omni.print("@RERROR@w " .. msg)
  end -- if
end -- omni.error


function omni.getRoom()
  return tonumber(gmcp("room.info.num") or "") or -1
--  return omni.gmcp.currentRoom or -1
end -- omni.getRoom


function omni.getArea()
  return gmcp("room.info.zone") or ""
end -- omni.getArea


function omni.getName()
  local name = ""
  local pretitle = ""
  local char = gmcp("char.base")

  if (char ~= nil) then
    name = (char.name or "nil")
    pretitle = (char.pretitle or "nil")
  end -- if

  return name, pretitle
end -- omni.getName


function omni.inCombat()
  if (gmcp("char.status.state") == "8") then
    return true
  else
    return false
  end -- if
end -- omni.inCombat


-- We don't want to send automated commands (e.g., "swho 12 area" from a timer) in certain char states
function omni.allowBackgroundSend()
  local state = gmcp("char.status.state")

  if (state == "3")  or   -- "active"
     (state == "8")  or   -- "combat"
     (state == "9")  or   -- "sleeping"
     (state == "11") then -- "resting"
    return true
  else
    return false
  end -- if
end -- omni.allowBackgroundSend


function omni.isActive()
  if (gmcp("char.status.state") == "3") then
    return true
  else
    return false
  end -- if
end -- omni.inCombat


function omni.inSafeRoom()
  local details = gmcp("room.info.details")

  if (string.find(details, "safe")) then
    return true
  else
    return false
  end -- if
end -- omni.inSafeRoom


function omni.commLog(msg)
  local clPlugin   = "b555825a4a5700c35fa80780"
  local clFunction = "storeFromOutside"

  if (msg == nil) or (msg == "") then
    print("omni.commLog: Missing message parameter")
    return error_code.eBadParameter
  end -- if

  local retval = CallPlugin(clPlugin, clFunction, msg)

  if (retval == error_code.eNoSuchPlugin) then
    print("omni.commLog: target plugin does not exist")

  elseif (retval == error_code.ePluginDisabled) then
    print("omni.commLog: target plugin is disabled")

  elseif (retval == error_code.eNoSuchRoutine) then
    print("omni.commLog: target routine does not exist")

  elseif (retval == error_code.eErrorCallingPluginRoutine) then
    print("omni.commLog: error calling plugin routine")

  elseif (retval ~= error_code.eOK) then
    print("omni.commLog: Unknown return value from CallPlugin: " .. (retval or "nil"))

  end -- if

  return retval
end -- omni.commLog


function omni.isWordInString(word, field)
  if (word == nil) or (word == "") or (field == nil) or (field == "") then
    return false
  end -- if

  for element in field:gmatch("%S+") do
    if (string.lower(word) == string.lower(element)) then
      return true
    end -- if
  end -- for

  return false
end -- omni.isWordInString


function omni.capitalize(word)
  if (word == nil) or (word == "") then
    return ""
  end -- if

  -- Get a string where the word has the first letter capitalized
  return string.upper(string.sub(word, 1, 1)) .. string.sub(word, 2, -1)
end -- omni.capitalize


function omni.getTime()
  return tonumber(os.time()) or 0
end -- omni.getTime


function omni.copy(origItem)
  local newItem

  if type(origItem) == 'table' then
    newItem = {}

    for origKey, origValue in next, origItem, nil do
      newItem[omni.copy(origKey)] = omni.copy(origValue)
    end -- for
    setmetatable(newItem, omni.copy(getmetatable(origItem)))
  else
    newItem = origItem
  end -- if

  return newItem
end -- omni.copy


----------------------------------------------------------------------------------------------------
-- omni.shell: Run a shell command in the background without pulling up a command prompt window
----------------------------------------------------------------------------------------------------

function omni.shell(shellCommand)
  local retval = DRL_RET_SUCCESS
  local mushRetval

  if (shellCommand == nil) or (shellCommand == "") then
    omni.error("omni.shell: Missing shell command")
    return DRL_RET_INVALID_PARAMETER
  end -- if

  --omni.print("omni.shell: Executing \"@G" .. "/C " .. shellCommand .. "@W\"")

  local ok, error = utils.shellexecute("cmd", "/C " .. shellCommand, GetInfo(64), "open", 0)
  if (not ok) then
    omni.error("omni.shell: Command \"@G" .. shellCommand .. "@W\" failed")
    retval = DRL_RET_INTERNAL_ERROR
  end -- if

  return retval
end -- omni.shell


----------------------------------------------------------------------------------------------------
-- omni.fileExists: Returns true if the specified file (or directory) exists and false otherwise
----------------------------------------------------------------------------------------------------

function omni.fileExists(fileName)
  if (fileName == nil) or (fileName == "") then
    return false
  end -- if

  local dirQuery = string.gsub(string.gsub(fileName, "\\", "/"), "/$", "")
  local dirTable, error = utils.readdir(dirQuery)

  if (dirTable == nil) then
    return false
  else
    --tprint(dirTable)
    return true
  end -- if

end -- omni.fileExists


----------------------------------------------------------------------------------------------------
-- omni.spinUntilExists: Spin in a sleep-loop waiting for the specified file to be created
----------------------------------------------------------------------------------------------------

function omni.spinUntilExists(fileName, timeoutSec)
  local totTime = 0

  -- Wait until either we detect that the file exists or until we time out
  while (not omni.fileExists(fileName)) do
    if (totTime > timeoutSec) then
      omni.error("omni.spinUntilExists: Timed out waiting for creation of \"@G" .. fileName .. "@W\"")
      return DRL_RET_TIMEOUT
    end -- if

    wait.time(drlSpinnerPeriodDefault)
    totTime = totTime + drlSpinnerPeriodDefault
  end -- while

  return DRL_RET_SUCCESS
end -- omni.spinUntilExists


----------------------------------------------------------------------------------------------------
-- omni.spinWhileExists: Spin in a sleep-loop waiting for the specified file to be deleted
----------------------------------------------------------------------------------------------------

function omni.spinWhileExists(fileName, timeoutSec)
  local totTime = 0

  -- Wait until either we detect that the file does not exist or until we time out
  while (omni.fileExists(fileName)) do
    if (totTime > timeoutSec) then
      omni.error("omni.spinWhileExists: Timed out waiting for deletion of \"@G" .. fileName .. "@W\"")
      return DRL_RET_TIMEOUT
    end -- if

    wait.time(drlSpinnerPeriodDefault)
    totTime = totTime + drlSpinnerPeriodDefault
  end -- while

  return DRL_RET_SUCCESS
end -- omni.spinWhileExists


----------------------------------------------------------------------------------------------------
-- omni.spinUntilExistsBusy: Spin in a busy-loop waiting for the specified file to be created
--
-- This is identical to omni.spinUntilExists() but it uses a busy loop instead of
-- scheduling a wait.  A busy loop is less efficient, but you have the option of 
-- using it outside of a co-routine and that comes in handy in certain circumstances.
----------------------------------------------------------------------------------------------------

function omni.spinUntilExistsBusy(fileName, timeoutSec)
  local startTime = omni.getTime()

  -- Wait until either we detect that the file exists or until we time out
  while (not omni.fileExists(fileName)) do

    -- We time out if we have been in a busy loop for over timeoutSec seconds.  This
    -- only has a resolution of 1 second so it's possible that we may timeout up to
    -- 1 second later than the user requested.  I'd rather take a chance of timing
    -- out a little late than timing out a little early.
    if (omni.getTime() - startTime > timeoutSec) then
      omni.error("omni.spinUntilExists: Timed out waiting for creation of \"@G" .. fileName .. "@W\"")
      return DRL_RET_TIMEOUT
    end -- if

  end -- while

  return DRL_RET_SUCCESS
end -- omni.spinUntilExistsBusy


----------------------------------------------------------------------------------------------------
-- omni.spinWhileExistsBusy: Spin in a busy-loop waiting for the specified file to be deleted
--
-- This is identical to omni.spinWhileExists() but it uses a busy loop instead of
-- scheduling a wait.  A busy loop is less efficient, but you have the option of 
-- using it outside of a co-routine and that comes in handy in certain circumstances.
----------------------------------------------------------------------------------------------------

function omni.spinWhileExistsBusy(fileName, timeoutSec)
  local startTime = omni.getTime()

  -- Wait until either we detect that the file is removed or until we time out
  while (omni.fileExists(fileName)) do

    -- We time out if we have been in a busy loop for over timeoutSec seconds.  This
    -- only has a resolution of 1 second so it's possible that we may timeout up to
    -- 1 second later than the user requested.  I'd rather take a chance of timing
    -- out a little late than timing out a little early.
    if (omni.getTime() - startTime > timeoutSec) then
      omni.error("omni.spinWhileExists: Timed out waiting for deletion of \"@G" .. fileName .. "@W\"")
      return DRL_RET_TIMEOUT
    end -- if

  end -- while

  return DRL_RET_SUCCESS
end -- omni.spinWhileExistsBusy


----------------------------------------------------------------------------------------------------
-- omni.reload: Reloads the current plugin
--
-- Note: This code was derived from part of a plugin by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

function omni.reload()
  local scriptPrefix = GetAlphaOption("script_prefix")
  local retval

  -- If the user has not already specified the script prefix for this version of mush, pick a
  -- reasonable default value
  if (scriptPrefix == "") then
    scriptPrefix = "\\\\\\"
    SetAlphaOption("script_prefix", scriptPrefix)
  end

  omni.print("@WReloading plugin...")

  -- Clean up
  omni.fini()

  -- Tell mush to reload the plugin later.  We can't do it directly here because a
  -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
  -- if it weren't installed? 
  retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
  if (retval ~= 0) then
    omni.error("omni.reload: Failed to reload the plugin: mush error " .. retval)
    retval = DRL_RET_INTERNAL_ERROR
  end -- if

  return retval
end -- omni.reload


----------------------------------------------------------------------------------------------------
-- Baseline trigger flags
----------------------------------------------------------------------------------------------------

drlTriggerFlagsBaseline = trigger_flag.Enabled + trigger_flag.RegularExpression +
                          trigger_flag.Replace + trigger_flag.KeepEvaluating


----------------------------------------------------------------------------------------------------
-- Return values
----------------------------------------------------------------------------------------------------

DRL_RET_SUCCESS        =  0
DRL_RET_UNINITIALIZED  = -1
DRL_RET_INVALID_PARAM  = -2
DRL_RET_MISSING_ENTRY  = -3
DRL_RET_BUSY           = -4
DRL_RET_UNSUPPORTED    = -5
DRL_RET_TIMEOUT        = -6
DRL_RET_HALTED         = -7
DRL_RET_INTERNAL_ERROR = -8
DRL_RET_UNIDENTIFIED   = -9
DRL_RET_NOT_ACTIVE     = -10
DRL_RET_IN_COMBAT      = -11
DRL_RET_VER_MISMATCH   = -12
DRL_RET_GENERIC_FAIL   = -13
DRL_RET_RETRY          = -14

omni.retval = {}
omni.retval.table = {}
omni.retval.table[DRL_RET_SUCCESS]        = "success"
omni.retval.table[DRL_RET_UNINITIALIZED]  = "component is not initialized"
omni.retval.table[DRL_RET_INVALID_PARAM]  = "invalid parameter"
omni.retval.table[DRL_RET_MISSING_ENTRY]  = "missing entry"
omni.retval.table[DRL_RET_BUSY]           = "resource is in use"
omni.retval.table[DRL_RET_UNSUPPORTED]    = "unsupported feature"
omni.retval.table[DRL_RET_TIMEOUT]        = "timeout"
omni.retval.table[DRL_RET_HALTED]         = "component is halted"
omni.retval.table[DRL_RET_INTERNAL_ERROR] = "internal error"
omni.retval.table[DRL_RET_UNIDENTIFIED]   = "item is not yet identified"
omni.retval.table[DRL_RET_NOT_ACTIVE]     = "you are not in the active state"
omni.retval.table[DRL_RET_IN_COMBAT]      = "you are in combat!"
omni.retval.table[DRL_RET_VER_MISMATCH]   = "version mismatch"
omni.retval.table[DRL_RET_GENERIC_FAIL]   = "general failure"
omni.retval.table[DRL_RET_RETRY]          = "retry the attempt"


function omni.retval.getString(retval)
  local string = omni.retval.table[retval]

  if (string == nil) then
    string = "Unknown return value"
  end -- if

  return string
end -- omni.retval.getString


----------------------------------------------------------------------------------------------------
-- Prompt gags
--
-- Start assuming the prompt is enabled.  If the numEnables variable transitions from 1 to 0, we
-- start gagging the prompt.  If it transitions from 0 to 1, we stop gagging the prompt.  If it is
-- less than 0 (i.e., we had the prompt turned off multiple times -- maybe in a nested loop) then
-- the prompt stays off.  Similarly, if it is greater than 1, the prompt stays on.
----------------------------------------------------------------------------------------------------

omni.prompt            = {}
omni.prompt.numEnables = 1

function omni.prompt.init()
  omni.prompt.numEnables = 1
  omni.prompt.dinv.isEnabled = false
end -- omni.prompt.init


function omni.prompt.fini()
  -- placeholder
end -- omni.prompt.fini


function omni.prompt.reset()
  omni.prompt.fini()
  omni.prompt.init()
end -- omni.prompt.reset


function omni.prompt.enable()

  -- Both dinv and omni hide the prompt to run background commands.  They can start fighting with each
  -- other if they don't know the other one is also toggling the prompt.  As a result, omni offers the
  -- option to synchronize prompts with dinv.  If this is enabled, omni will check if dinv is present
  -- and ask dinv to enable/disable the prompt if dinv is available.  Otherwise, omni handles toggling
  -- the prompt directly.
  if (omni.prompt.dinv.isEnabled == true) then
    if (omni.prompt.dinv.set("enable") ~= DRL_RET_SUCCESS) then
      omni.error("omni.prompt.enable: Failed to enable the prompt via dinv")
    end -- if

  else
    omni.prompt.numEnables = omni.prompt.numEnables + 1

    if (omni.prompt.numEnables == 1) then
      Execute("sendgmcp config prompt on")
    end -- if
  end -- if

end -- omni.prompt.enable


function omni.prompt.disable()

  -- Both dinv and omni hide the prompt to run background commands.  They can start fighting with each
  -- other if they don't know the other one is also toggling the prompt.  As a result, omni offers the
  -- option to synchronize prompts with dinv.  If this is enabled, omni will check if dinv is present
  -- and ask dinv to enable/disable the prompt if dinv is available.  Otherwise, omni handles toggling
  -- the prompt directly.
  if (omni.prompt.dinv.isEnabled == true) then
    if (omni.prompt.dinv.set("disable") ~= DRL_RET_SUCCESS) then
      omni.error("omni.prompt.disable: Failed to disable the prompt via dinv")
    end -- if

  else
    omni.prompt.numEnables = omni.prompt.numEnables - 1

    if (omni.prompt.numEnables == 0) then
      Execute("sendgmcp config prompt off")
    end -- if
  end -- if

end -- omni.prompt.disable


omni.prompt.dinv = {}

function omni.prompt.dinv.set(mode)
  local retval = DRL_RET_SUCCESS

  if (mode ~= "enable") and (mode ~= "disable") then
    omni.error("omni.prompt.dinv: Invalid mode \"" .. (mode or "nil") .. "\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  local cpFunction = "dbot.prompt." .. mode

  local retMush = CallPlugin(omni.plugins.dinv, cpFunction)
  if (retMush ~= error_code.eOK) then
    retval = DRL_RET_UNSUPPORTED
  end -- if

  return retval
end -- omni.prompt.dinv.set


----------------------------------------------------------------------------------------------------
-- Mob kill tracking
----------------------------------------------------------------------------------------------------

omni.kill = {}
omni.kill.msgArray = {
  -- Generic
  "^(.*) (is|are) DEAD!!$",

  ----------
  -- WEAPONS
  ----------
  -- light
    -- NOTE: matches the generic message
  -- magic
    -- NOTE: matches the generic message
  -- bash
  "^(.*) crumbles as (he|she|it|they) (is|are) battered to death!!$",
  -- pierce
  "^(.*) is slain by a final deadly stab!!$",
  -- mental:  A garden snake falls dead as its mind is destroyed!!
  "^(.*) falls dead as (his|her|its|their) mind(s|) (is|are) destroyed!!$",
  -- slash:  An Eldar farmer is slain by a final deadly slash!!
  "^(.*) (is|are) slain by a final deadly slash!!$",
  -- hammer: A vampire eating garlic collapses as the life is hammered out of him. He is DEAD!
  "^(.*) collapses as the life is hammered out of (him|her|it). (He|She|It) is DEAD!$",

  ------
  -- PSI
  ------
  -- ballistic attack
  "^A lethal kinetic missile slams into (.*) and finishes (him|her|it|them)!! (He|She|It|They) (is|are) DEAD!$",
  -- mind thrust:  A black ant's mind is destroyed by the sheer force of will!! It is DEAD!
  "^(.*)(\'s|\') mind (is|are) destroyed by the sheer force of will!! (He|She|It|They) (is|are) DEAD!$",
  -- ego whip:  A garden snake's ego is whipped so badly that it just decides to die! It is DEAD!
  "^(.*)(\'s|\') ego is whipped so badly that (he|she|it) just decides to die! (He|She|It|They) (is|are) DEAD!$",
  -- agitation:  A garden snake howls as its last spark of life is drained!!
    -- NOTE: same as death field
  -- inflict pain:  A tiny, brown mouse says 'Damn!! I just KNEW I should have stayed in bed today!' It is DEAD!
  "^(.*) says \'Damn!! I just KNEW I should have stayed in bed today!\' (He|She|It) is DEAD!$",
  -- telekinesis:  A flea beetle crumbles as it is battered to death!!
    -- NOTE: same as bash weapon message
  -- soften:  A fly howls as its last spark of life is drained!!
    -- NOTE: same as death field
  -- mind freeze:  A garden snake falls to the ground limply as its brain stops working! It is DEAD!
  "^(.*) falls to the ground limply as (his|her|its) brain stops working! (He|She|It) is DEAD!$",
  -- control flames:  A fly screams as the flames engulf it!!
  "^(.*) screams as the flames engulf (him|her|it)!!$",
  -- nerve shock:  A tiny, brown mouse's body writhes as its nerves cease to function! It is DEAD!
  "^(.*)(\'s|\') body writhes as (his|her|its) nerves cease to function! (He|She|It) is DEAD!$",
  -- psychic crush:  A black ant's brain explodes from its ears!! It is DEAD!
  "^(.*)(\'s|\') brain explodes from (his|her|its) ears!! (He|She|It) is DEAD!$",
  -- strike undead:
    -- TBD: 
  -- cause decay:  A grub's disease removes it from this world!!
  "^(.*)(\'s|\') disease removes (him|her|it) from this world!!$",
  -- zombify
    -- TBD: 
  -- acidic touch:  A flea beetle screams in agony as the acid consumes it!!
  "^(.*) screams in agony as the acid consumes (him|her|it)!!$",
  -- neural burn:  A flea beetle goes completely still as its brain is melted! It is DEAD!
    "^(.*) goes completely still as (his|her|its|their) brain (is|are) melted! (He|She|It|They) (is|are) DEAD!$",
  -- project force:  The mind force crushes a fly into a bloody pulp! It is DEAD!
    "^The mind force crushes (.*) into a bloody pulp! (He|She|It|They) (is|are) DEAD!$",
  -- ultrablast:  A fly screams as it is engulfed by the atomic force!! It is DEAD!
    "^(.*) screams as (he|her|it|they) (is|are) engulfed by the atomic force!! (He|She|It|They) (is|are) DEAD!$",
  -- psionic blast:  A black ant is destroyed by the blast!!
    -- NOTE: identical to detonate message
  -- raw flesh
    -- NOTE: identical to the messages from death field
  -- detonate
  "^(.*) (is|are) destroyed by the blast!!$",
  -- trauma
  "^(.*) (is|are) completely traumatized and fall[s]+ to the floor gasping! (It|He|She|They) (is|are) DEAD!$",
  -- death field
  "^(.*) howls as (his|her|its|their) last spark of life is drained!!$",
  -- psychosis:  A black ant shudders and then crumples as the blast slays it! It is DEAD!
  "^(.*) shudders and then crumples as the blast slays (him|her|it|them)! (He|She|It|They) (is|are) DEAD!$",
  -- spasm:  A flea beetle's body creaks loudly and slams to the ground HARD! It is DEAD!
  "^(.*)(\'s|\') body creaks loudly and slams to the ground HARD! (He|She|It|They) (is|are) DEAD!$",
  -- nightmare touch:  A giant ant is slain by his own worst nightmare, a pissed off adventurer with a big weapon! He is DEAD!
  "^(.*) is slain by (his|her|its|their) own worst nightmare, a pissed off adventurer with a big weapon! (He|She|It|They) (is|are) DEAD!$",
  -- megablast
    -- NOTE: identical to detonate message
  -- neural overload:  An Eldar master hunter starts to sound like Ivar as his brain explodes! He is DEAD!
  "^(.*) starts to sound like Ivar as (his|her|its|their) brain explodes! (He|She|It|They) (is|are) DEAD!$",
  -- pyromania
    -- NOTE: identical to detonate message
  -- desolation:  A fly feels so desolate that life itself leaves its wrecked form! It is DEAD!
  "^(.*) feels so desolate that life itself leaves (his|her|its) wrecked form! (He|She|It) is DEAD!$",
  -- blast undead
    -- TBD: 
  -- necrocide
    -- TBD: 

  ----------
  -- WARRIOR
  ----------
  -- kick:  A raven crumples as the last remaining breath is kicked out of her. She is DEAD!
  "^(.*) crumples as the last remaining breath is kicked out of (him|her|it). (He|She|It) is DEAD!$",
  -- bash (skill):  The body slam smashes into a maggot destroying its internal organs. It is DEAD!
  "^The body slam smashes into (.*) destroying (his|her|its) internal organs. (He|She|It) is DEAD!$",
  -- dirt kicking:  A large rock embeds itself in a wight's brain, resulting in death!! It is DEAD!
  "^A large rock embeds itself in (.*)(\'s|\') brain, resulting in death!! (He|She|It) is DEAD!$",
  -- stun:  The sudden violent blow to the head destroys a bat! She is DEAD!
  "^The sudden violent blow to the head destroys (.*)! (He|She|It) is DEAD!$",
  -- trip:  The trip causes a grave rat to break his skull on the ground! He is DEAD!
  "^The trip causes (.*) to break (his|her|its) skull on the ground! (He|She|It) is DEAD!$",
  -- sap:  A ghast crumbles as it is battered to death!!
    -- NOTE: same as bash weapon message
  -- scalp:  With a ripping sound the trophy is taken from a ghoul's head, and with it, his life! He is DEAD!
  "^With a ripping sound the trophy is taken from (.*)(\'s|\') head, and with it, (his|her|its) life! (He|She|It) is DEAD!$",
  -- assault:  With viciousness and a wicked blade, a wraith is slain! It is DEAD!
  "^With viciousness and a wicked blade, (.*) is slain! (He|She|It) is DEAD!$",
  -- uppercut:  The battered corpse of a grave rat falls to the floor lifeless. She is DEAD!
  "^The battered corpse of (.*) falls to the floor lifeless. (He|She|It) is DEAD!$",
  -- headbutt:  A skeleton is knocked lifeless like it just played soccer with Zidane. It is DEAD!
  "^(.*) is knocked lifeless like (he|she|it) just played soccer with Zidane. (He|She|It) is DEAD!$",
  -- gouge:  A ghost quivers briefly as its internals are gouged out. It is DEAD!
  "^(.*) quivers briefly as (his|her|its) internals are gouged out. (He|She|It) is DEAD!$",
  -- stomp:  The last shred of life is stomped out of a graverobber! He is DEAD!
  "^The last shred of life is stomped out of (.*)! (He|She|It) is DEAD!$",
  -- bodycheck:  A zombie is crushed by the fury of the bodycheck. It is DEAD!
  "^(.*) is crushed by the fury of the bodycheck. (He|She|It) is DEAD!$",
  -- cleave:  The awesome blow strikes right through a zombie hand's shield into the flesh! It is DEAD!
  "^The awesome blow strikes right through (.*)(\'s|\') shield into the flesh! (He|She|It) is DEAD!$",
  -- hammer: 
  "^(.*) is hammered to death by the force of the blow. (He|She|It) is DEAD!$",
  -- counter strike: many???  A weresquirrel is shattered by the stunning counter strike!! He is DEAD!
  "^(.*) is shattered by the stunning counter strike!! (He|She|It) is DEAD!$",

  --------
  -- THIEF
  --------
  -- Kobold stench:  A garden snake's disease removes it from this world!!
    -- NOTE: same as cause decay
  -- Circle:  The final deadly circle turns a black ant into food for the worms! It is DEAD!
  "^The final deadly circle turns (.*) into food for the worms! (He|She|It) is DEAD!$",
  -- Burnt marbu:  A farm hand's brain is destroyed as poison enters his skull. He is DEAD!
  "^(.*)(\'s|\') brain is destroyed as poison enters (his|her|its) skull. (He|She|It) is DEAD!$",
  -- backstab:  A black ant lets out a final rasp as its vital organs are pierced. It is DEAD!
  "^(.*) lets out a final rasp as (his|her|its) vital organs are pierced. (He|She|It) is DEAD!$",
  --  Black root:  The power of the root finds a vital spot on a garden snake. Death is swift! It is DEAD!
  "^The power of the root finds a vital spot on (.*). Death is swift! (He|She|It) is DEAD!$",
  --  Hydra blood:  The burning of hydra blood destroys a black ant from the inside out! It is DEAD!
  "^The burning of hydra blood destroys (.*) from the inside out! (He|She|It) is DEAD!$",
  --  Cobra bane:  As venom brings death, a black ant's face holds a passing look of terror as realization dawns. It is DEAD!
  "^As venom brings death, (.*)(\'s|\') face holds a passing look of terror as realization dawns. (He|She|It) is DEAD!$",
  --  Raven scourge:  The acidic venom flays a grub's skin from its bones. It is DEAD!
  "^The acidic venom flays (.*)(\'s|\') skin from (his|her|its) bones. (He|She|It) is DEAD!$",
  -- *Necrotic touch:
    -- TBD
  --  Green death:  The fire in a scraggly weed's eyes dies as the mist invades its lungs. It is DEAD!
  "^The fire in (.*)(\'s|\') eyes dies as the mist invades (his|her|its) lungs. (He|She|It) is DEAD!$",
  --  Kobold spray:
    -- TBD
  --  Marbu jet:  A rabbit's brain is destroyed as poison enters its skull. It is DEAD!
    -- NOTE: same we burnt marbu
  --  Sweep:  The impact of the fall shatters a rabbit's body! It is DEAD!
  "^The impact of the fall shatters (.*)(\'s|\') body! (He|She|It) is DEAD!$",
  -- *Balor spittle:
    -- TBD
  -- spiral:  Multiple slashes to the body end the life of a black ant! It is DEAD!
  "^Multiple slashes to the body end the life of (.*)! (He|She|It) is DEAD!$",
  -- assassinate
  "^You assassinate (.*) with cold efficiency.$",

  -------
  -- Mage
  -------
  -- odin: Broken branches is burnt to a crisp by Odin's spear! It is DEAD!
  "^(.*) is burnt to a crisp by Odin's spear! (He|She|It) is DEAD!$",

  ---------
  -- Ranger
  ---------
  -- eruption: The very fabric of the world rejects Gypsy bandit and Gypsy bandit's life is over!! He is DEAD!
  "^The very fabric of the world rejects (.*) and (.*)(\'s|\') life is over!! (He|She|It) is DEAD!$",

  -- Gaia's revenge (cold): Adaline goes stiff as she is frozen to death!!
  "^(.*) goes stiff as (he|she|it) is frozen to death!!$",

  -- Gaia's revenge (electric): Unrestrained Elvendar smoulders as the lightning destroys her!!
  "^(.*) smoulders as the lightning destroys (him|her|it)!!$",

  -- Gaia's revenge (air):

  -- Gaia's revenge (earth):

  -- Gaia's revenge (water): A treasure hunter is battered to death by the force of the water!
  "^(.*) is battered to death by the force of the water!$",

  -------------
  -- Insta-kill
  -------------
  -- slit:  You sneak behind a tiny, brown mouse and slit its throat.
  "^You sneak behind (.*) and slit (his|her|its) throat.$",
  -- banish
  "^You concentrate and banish (.*)$",
  -- disintegrate:  You have disintegrated a black ant!
  "^You have disintegrated (.*)!$",


}


function omni.kill.last(nameShort)
  --omni.print("Last kill: \"" .. (nameShort or "nil") .. "\"")

  omni.hitlist.lastKill = (nameShort or "nil")

  -- If room scans are enabled, we should schedule a rescan if something dies.  This won't force
  -- a rescan on every death, but if the room timer expires and at least one thing has died, this
  -- will tell it to do another scan.
  omni.scan.timer.room.requested = true

end -- omni.kill.last


----------------------------------------------------------------------------------------------------
-- Mob hitlist tracking for quests, campaigns, and gquests (so omni can highlight those target mobs)
----------------------------------------------------------------------------------------------------

omni.hitlist = {}

omni.hitlist.quest               = {}
omni.hitlist.campaign            = {}
omni.hitlist.gquest              = {}

omni.hitlist.quest.qmob          = {}
omni.hitlist.lastKill            = nil

omni.hitlist.callback            = {}
omni.hitlist.callback.param      = nil

omni.hitlist.trigger             = {}
omni.hitlist.trigger.qmobStart   = "omniHitlistTrigQmobStart"
omni.hitlist.trigger.qmobEnd     = "omniHitlistTrigQmobEnd"
omni.hitlist.trigger.qmobInfo1   = "omniHitlistTrigQmobInfo1"
omni.hitlist.trigger.qmobInfo2   = "omniHitlistTrigQmobInfo2"
omni.hitlist.trigger.qmobDead    = "omniHitlistTrigQmobDead"
omni.hitlist.trigger.qmobDone    = "omniHitlistTrigQmobDone"
omni.hitlist.trigger.qmobArea    = "omniHitlistTrigQmobArea"
omni.hitlist.trigger.qmobRoom    = "omniHitlistTrigQmobRoom"
omni.hitlist.trigger.qmobName    = "omniHitlistTrigQmobName"
omni.hitlist.trigger.qmobGroup   = "omniHitlistQmobTrigGroup"
omni.hitlist.trigger.lastKill    = "omniHitlistTrigLastKill"
omni.hitlist.trigger.cpLine      = "omniHitlistTrigCpLine"
omni.hitlist.trigger.cpEnd       = "omniHitlistTrigCpEnd"
omni.hitlist.trigger.cpDead      = "omniHitlistTrigCpDead"
omni.hitlist.trigger.cpSelect    = "omniHitlistTrigCpSelect"
omni.hitlist.trigger.gqLine      = "omniHitlistTrigGqLine"
omni.hitlist.trigger.gqEnd       = "omniHitlistTrigGqEnd"
omni.hitlist.trigger.gqDead      = "omniHitlistTrigGqDead"
omni.hitlist.trigger.gqSelect    = "omniHitlistTrigGqSelect"

omni.hitlist.trigger.lastKillGrp = "omniHitlistTrigLastKillGrp"

omni.hitlist.campaign.timer      = "omniHitlistTimerCampaign"
omni.hitlist.gquest.timer        = "omniHitlistTimerGquest"

omni.hitlist.cpLevel             = "omniHitlistCpLevelVar"


function omni.hitlist.init()
  omni.hitlist.quest.reset()
  omni.hitlist.campaign.reset()
  omni.hitlist.gquest.reset()

  -- Keep track of the most recent mob you killed.  This is a bit tricky since every skill/spell
  -- has its own unique kill message.  This uses an array of all supported kill messages to create
  -- triggers for each of them.  Each of those triggers must pass the mob's shortName as %1.
  for i, killRegex in ipairs(omni.kill.msgArray) do
    local trigName = omni.hitlist.trigger.lastKill .. i
    check (AddTriggerEx(trigName,
                        killRegex,
                        "omni.kill.last(\"%1\")",
                        drlTriggerFlagsBaseline,
                        custom_colour.NoChange, 0, "", "", sendto.script, 100))
    SetTriggerOption(trigName, "group", omni.hitlist.trigger.lastKillGrp)
  end -- for

  -- CP selection
  check (AddTriggerEx(omni.hitlist.trigger.cpSelect,
                      "^.* tells you \\'I have selected .* for you to hunt.*$",
                      "",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "",
                      "omni.hitlist.cpStart", sendto.script, 100))

  -- CP mob is dead
  check (AddTriggerEx(omni.hitlist.trigger.cpDead,
                      "^Congratulations, that was one of your CAMPAIGN mobs\\!$",
                      "omni.hitlist.update(\"campaign\")",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))

  -- CP mob line from "cp check" and "cp request"
  check (AddTriggerEx(omni.hitlist.trigger.cpLine,
                      "^You still have to kill \\* (.*?) \\((.*?)( - Dead)*\\).*$",
                      "omni.hitlist.addMob(\"campaign\", \"1\", \"%1\", \"%2\", nil, nil, \"%3\")",
	                  drlTriggerFlagsBaseline,
	                  custom_colour.NoChange, 0, "", "", sendto.script, 0))
  EnableTrigger(omni.hitlist.trigger.cpLine, false)

  -- GQ mob is dead
  check (AddTriggerEx(omni.hitlist.trigger.gqDead,
                      "^Congratulations, that was one of the GLOBAL QUEST mobs!$",
                      "omni.hitlist.update(\"gquest\")",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))

  -- GQ mob line from "gq check"
  check (AddTriggerEx(omni.hitlist.trigger.gqLine,
                      "^You still have to kill ([0-9]+) \\* (.*?) \\((.*?)( - Dead)*\\).*$",
                      "omni.hitlist.addMob(\"gquest\", \"%1\", \"%2\", \"%3\", nil, nil, \"%4\")",
	                  drlTriggerFlagsBaseline,
	                  custom_colour.NoChange, 0, "", "", sendto.script, 0))
  EnableTrigger(omni.hitlist.trigger.gqLine, false)

  -- Quest request start
  check (AddTriggerEx(omni.hitlist.trigger.qmobStart,
                      "^You ask (.*) for a quest.$",
                      "omni.hitlist.quest.start()",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))
  
  -- Quest info mob/room line
  check (AddTriggerEx(omni.hitlist.trigger.qmobInfo1,
                      "^(.*) can be found in the vicinity of (.*?)( which)?$",
                      "omni.hitlist.quest.qmob.name = omni.capitalize(\"%1\") " ..
                      "omni.hitlist.quest.qmob.room = omni.capitalize(\"%2\")",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))
  
  -- Quest info area line
  check (AddTriggerEx(omni.hitlist.trigger.qmobInfo2,
                      "^(?:which )?is in the general area of (.*).$",
                      "omni.hitlist.quest.qmob.area = omni.capitalize(\"%1\") " ..
                      "omni.hitlist.quest.stop()",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))
  
  -- Quest request stop
  check (AddTriggerEx(omni.hitlist.trigger.qmobEnd,
                      "^.*tells you \\'You have .* to complete your quest.\\'$",
                      "omni.hitlist.quest.stop()",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))

  -- Quest mob dead
  check (AddTriggerEx(omni.hitlist.trigger.qmobDead,
                      "^QUEST: You have almost completed your QUEST.$",
                      "omni.hitlist.update(\"quest\")",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))

  -- Quest mob done
  check (AddTriggerEx(omni.hitlist.trigger.qmobDone,
                      "^.*tells you \\'I thought you could handle such a simple task.\\'$" ..
                      "|^.*tells you \\'Congratulations, ([^ ]+), on completing your quest!\\'$",
                      "omni.hitlist.quest.done()",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))

  -- Quest mob name
  check (AddTriggerEx(omni.hitlist.trigger.qmobName,
                      "^.*tells you \\'Seek (.*) out somewhere in the vicinity\\'$",
                      "omni.hitlist.quest.qmob.name = omni.capitalize(\"%1\")",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))
  SetTriggerOption(omni.hitlist.trigger.qmobName, "group", omni.hitlist.trigger.qmobGroup)

  -- Quest mob room
  check (AddTriggerEx(omni.hitlist.trigger.qmobRoom,
                      "^.*tells you \\'of (.*?) which is in the general area\\'$",
                      "omni.hitlist.quest.qmob.room = \"%1\"",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))
  SetTriggerOption(omni.hitlist.trigger.qmobRoom, "group", omni.hitlist.trigger.qmobGroup)

  -- Quest mob area
  check (AddTriggerEx(omni.hitlist.trigger.qmobArea,
                      "^.* \\'of (.*?)\\.\\'$",
                      "omni.hitlist.quest.qmob.area = \"%1\"",
                      drlTriggerFlagsBaseline,
                      custom_colour.NoChange, 0, "", "", sendto.script, 100))
  SetTriggerOption(omni.hitlist.trigger.qmobArea, "group", omni.hitlist.trigger.qmobGroup)

  EnableTriggerGroup(omni.hitlist.trigger.qmobGroup, false)

  -- If another plugin requested callbacks, prep the callback call
  local cbData = GetVariable(omni.hitlist.callback.varName)
  if (cbData ~= nil) and (cbData ~= "") then
    loadstring(cbData)()
  end -- if

end -- omni.hitlist.init


function omni.hitlist.fini()
  DeleteTriggerGroup(omni.hitlist.trigger.qmobGroup)

  DeleteTrigger(omni.hitlist.trigger.qmobStart)
  DeleteTrigger(omni.hitlist.trigger.qmobEnd)
  DeleteTrigger(omni.hitlist.trigger.qmobInfo1)
  DeleteTrigger(omni.hitlist.trigger.qmobInfo2)
  DeleteTrigger(omni.hitlist.trigger.qmobDead) 
  DeleteTrigger(omni.hitlist.trigger.qmobDone) 
  DeleteTrigger(omni.hitlist.trigger.qmobArea) 
  DeleteTrigger(omni.hitlist.trigger.qmobRoom) 
  DeleteTrigger(omni.hitlist.trigger.qmobName) 

  DeleteTrigger(omni.hitlist.trigger.lastKill)

  DeleteTrigger(omni.hitlist.trigger.cpLine)
  DeleteTrigger(omni.hitlist.trigger.cpEnd)
  DeleteTrigger(omni.hitlist.trigger.cpDead)
  DeleteTrigger(omni.hitlist.trigger.cpSelect)

  DeleteTrigger(omni.hitlist.trigger.gqLine)
  DeleteTrigger(omni.hitlist.trigger.gqEnd)
  DeleteTrigger(omni.hitlist.trigger.gqDead)
  DeleteTrigger(omni.hitlist.trigger.gqSelect)

  DeleteTriggerGroup(omni.hitlist.trigger.lastKillGrp)

  DeleteTimer(omni.hitlist.campaign.timer)
  DeleteTimer(omni.hitlist.gquest.timer)

end -- omni.hitlist.fini


omni.hitlist.callback.varName = "hlCallbackState"
function omni.hitlist.callback.register(cbData)
  if (cbData ~= nil) then
    --omni.print("omni.hitlist.callback.register: \"" .. (cbData or "nil") .. "\"")
    SetVariable(omni.hitlist.callback.varName, cbData)
    loadstring(cbData)()
  end -- if

  -- Pass back initial values for all supported types
  omni.hitlist.callback.reply("quest")
  omni.hitlist.callback.reply("campaign")
  omni.hitlist.callback.reply("gquest")

end -- omni.hitlist.callback.register


function omni.hitlist.callback.reply(hlType)
  if (omni.hitlist.callback.param == nil) then
    return DRL_RET_SUCCESS
  end -- if

  local retval, data, hlLevel = omni.hitlist.status(hlType)

  if (retval == DRL_RET_SUCCESS) then
    if (omni.hitlist.callback.param ~= nil) then
      local msg     = serialize.save(omni.hitlist.callback.param.name,
                                     { level = hlLevel, mode = hlType, mobs = data })
      local retMush = CallPlugin(omni.hitlist.callback.param.plugin, omni.hitlist.callback.param.fn, msg)
      if (retMush ~= error_code.eOK) then
        retval = DRL_RET_UNSUPPORTED
      end -- if
    end -- if
  end -- if

  return retval
end -- omni.hitlist.callback.reply


function omni.hitlist.status(hlType)
  local retval = DRL_RET_SUCCESS

  if (hlType == "quest") or (hlType == "q") then
    return retval, omni.hitlist.quest.mobs, omni.hitlist.quest.level
  elseif (hlType == "campaign") or (hlType == "cp") then
    return retval, omni.hitlist.campaign.mobs, GetVariable(omni.hitlist.cpLevel)
  elseif (hlType == "gquest") or (hlType == "gq") then
    return retval, omni.hitlist.gquest.mobs, omni.hitlist.gquest.level
  else
    return DRL_RET_INVALID_PARAMETER, nil
  end -- if

end -- omni.hitlist.status


function omni.hitlist.display(hlType)
  local retval, displayData = omni.hitlist.status(hlType)

  if (displayData == nil) then
    omni.error("omni.hitlist.display: No mob data available for type \"@C" .. (hlType or "nil") .. "@W\"")
    return DRL_RET_INVALID_PARAM
  end -- if

  -- Sort the hitlist data by area alphabetically
  local sortedMobs = {}
  for shortName, entry in pairs(displayData) do
    table.insert(sortedMobs, { shortName = shortName, isDead = entry.isDead,
                               where = entry.where, room = entry.room, area = entry.area,
                               completed = entry.completed, total = entry.total })
  end -- for
  table.sort(sortedMobs, function (e1, e2) return e1.where < e2.where end)

  local output = "@WHITLIST: " .. hlType .. "\n"
  for idx,entry in ipairs(sortedMobs) do
    local truncName = string.format("%24s", string.sub(entry.shortName, 1, 24))
    local mainColor, mobColor, roomColor, areaColor = "@W", "@x039", "@C", "@c"
    if (entry.isDead) then
      mainColor, mobColor, roomColor, areaColor = "@R", "@m", "@M", "@x164"
    end -- if

    local location = ""
    if (entry.where ~= nil) then
      location = roomColor .. entry.where
    else
      location = roomColor .. (entry.room or "nil") .. " " .. mainColor .. "in " ..
                 areaColor .. (entry.area or "nil")
    end -- if

    output = output .. mainColor .. (entry.completed or 0) .. "/" .. (entry.total or 0) ..
             " " .. mobColor .. truncName .. mainColor .. " @@ " .. location

    if (idx < #sortedMobs) then
       output = output .. "\n"
    end -- if
  end -- for

  if (#sortedMobs > 0) then
    omni.print(output)
    --omni.charsdb.search("nameShort = \"" .. (sortedMobs[1].shortName or "nil")  .. "\"", true)

  else
    omni.print("@WNo mobs are in the \"@C" .. (hlType or "nil") .. "@W\" hitlist queue")
  end -- if

end -- omni.hitlist.display


function omni.hitlist.addMob(hlType, numMobs, shortName, where, room, area, isDead)
  if (hlType ~= "campaign") and (hlType ~= "quest") and (hlType ~= "gquest") then
    omni.error("omni.hitlist.addMob: invalid hlType \"" .. (hlType or "nil") .. "\"")
    return DRL_RET_INVALID_PARAMETER
  end -- if

  if (shortName ~= nil) and (shortName ~= "") then
    local normalizedName = ""

    -- Strip out single and double quotes from the shortName since those are not present in DB names
    normalizedName = string.gsub(shortName, "%\"", "")
    normalizedName = string.gsub(normalizedName, "%\'", "")

    -- Store the mob name in a capitalized format
    normalizedName = omni.capitalize(normalizedName)

    -- One-offs.  E.g., Fenix has (Helper) in his name...which sux for parsing since it looks like a flag :P
    if (normalizedName == "(Helper) Fenix") then
      normalizedName = "Fenix"
    end -- if

    omni.hitlist[hlType].mobs[normalizedName]           = {}
    omni.hitlist[hlType].mobs[normalizedName].completed = 0
    omni.hitlist[hlType].mobs[normalizedName].total     = tonumber(numMobs)
    omni.hitlist[hlType].mobs[normalizedName].where     = where
    omni.hitlist[hlType].mobs[normalizedName].room      = room
    omni.hitlist[hlType].mobs[normalizedName].area      = area
    if (isDead == "") or (isDead == nil) then
      omni.hitlist[hlType].mobs[normalizedName].isDead  = false
    else
      omni.hitlist[hlType].mobs[normalizedName].isDead  = true
    end -- if

  end -- if
end -- omni.hitlist.addMob


-- Update the popularity of the mob whose nameShort is provided.  This function can be used for a quest,
-- campaign, or gquest mob.
function omni.hitlist.update(hlType)

  if (hlType ~= "campaign") and (hlType ~= "quest") and (hlType ~= "gquest") then
    omni.error("omni.hitlist.update: Invalid hlType \"@C" .. (hlType or "nil") .. "@W\"")
    return DRL_RET_INVALID_PARAMETER
  end -- if

  -- It's possible that we killed the mob in a manner that we didn't notice (each spell/skill has 
  -- a unique kill message and not all are supported yet).  If this (hopefully rare) case happens,
  -- then our lastKill mob may not match the mob we just killed in our current room.  As a result,
  -- we do a little sanity check below to ensure that the lastKill is at least a mob that has been
  -- detected in our current room.  This makes the odds pretty low that we will update a mob's
  -- popularity by mistake.  But...even if we do, it's not a huge issue.  Similarly, if we fail to
  -- update an actual cp mob's popularity very very very rarely it's not a big issue either.
  local killName = omni.hitlist.lastKill or "nil"

  -- Strip out single and double quotes from the killName since those are not present in DB names
  killName = string.gsub(killName, "%\"", "")
  killName = string.gsub(killName, "%\'", "")

  local killNameCap = omni.capitalize(killName)
  local room = omni.getRoom()

  -- We should already have this quest/cp/gq mob in the DB.  If for some reason this room isn't discovered
  -- yet, we skip the popularity update.
  local sqlSelect = "SELECT nameKey, nameShort, nameLong, area, room,     " ..
                    "charType, popularity, align, levelFloor, levelCeiling, resists "  ..
                    "FROM chars WHERE " ..
                    "(nameShort = \"" .. (killName or "nil") .. "\" OR " ..
                    "nameShort = \"" .. (killNameCap or "nil") .. "\") " ..
                    "AND room = " .. (room or 0)

  local retval, searchTab = omni.charsdb.select(sqlSelect)

  -- If there are multiple matches for nameShort in this room, update the popularity for all of the matches
  -- since we can't distinguish them.  There's probably a better way to handle this...
  if (#searchTab > 0) then
    for i,entry in ipairs(searchTab) do
      omni.charsdb.set(entry.nameKey, entry.nameShort, entry.nameLong, entry.area, entry.room, entry.charType,
                       entry.popularity + 1, entry.align, entry.levelFloor, entry.levelCeiling, entry.resists)

      local popReport = "\"@C" .. entry.nameShort .. "@w\" in room @C" .. entry.room ..
                        "@w has popularity=@C" .. entry.popularity + 1
    end -- for
  else
    --omni.print("Skipping popularity update: no matches found for sqlSelect=\"" .. sqlSelect .. "\"")
  end -- if

  if (omni.hitlist[hlType] ~= nil) and (omni.hitlist[hlType].mobs[killNameCap] ~= nil) then
    omni.hitlist[hlType].mobs[killNameCap].completed = omni.hitlist[hlType].mobs[killNameCap].completed + 1
  end -- if

  omni.hitlist.callback.reply(hlType)

  return DRL_RET_SUCCESS
end -- omni.hitlist.update


function omni.hitlist.cpStart()
  -- Remember when we took this level so that we can prune out potential targets that are out of level range
  local level = tonumber(gmcp("char.status.level") or "") or 1
  SetVariable(omni.hitlist.cpLevel, level)

  -- We're ready.  Go!
  Execute("campaign check")
end -- omni.hitlist.cpStart


function omni.hitlist.quest.reset()
  omni.hitlist.quest.mobs = {}

  -- Triggers for quest mobs don't see the whole picture.  Instead, each trigger catches just a part of
  -- what we want to know.  After we have all of the .qmob data, we consolidate it into the quest.mobs
  -- array to be consistent with how we handle campaigns and gquests.
  omni.hitlist.quest.qmob.name = ""
  omni.hitlist.quest.qmob.room = ""
  omni.hitlist.quest.qmob.area = ""

end -- omni.hitlist.quest.reset


function omni.hitlist.quest.start()
  omni.hitlist.quest.reset()
  EnableTriggerGroup(omni.hitlist.trigger.qmobGroup, true)
end -- omni.hitlist.quest.start


function omni.hitlist.quest.stop()
  EnableTriggerGroup(omni.hitlist.trigger.qmobGroup, false)

  -- Consolidate all of the qmob info into a single array entry in the format we use for campaigns and gquest
  omni.hitlist.addMob("quest", 1, omni.hitlist.quest.qmob.name, nil,
                       omni.hitlist.quest.qmob.room, omni.hitlist.quest.qmob.area, "")

  omni.hitlist.callback.reply("quest")

end -- omni.hitlist.quest.stop


function omni.hitlist.quest.done()
  omni.hitlist.quest.reset()
  omni.hitlist.callback.reply("quest")
end -- omni.hitlist.quest.done


function omni.hitlist.campaign.reset()
  omni.hitlist.campaign.mobs = {}
end -- omni.hitlist.campaign.reset


function omni.hitlist.campaign.refresh(command, mode)
  --omni.print("campaign.refresh")
  omni.hitlist.campaign.reset()

  EnableTrigger(omni.hitlist.trigger.cpLine, true)

  -- CP end line(s) from "cp check" and "cp request"
  check (AddTriggerEx(omni.hitlist.trigger.cpEnd,
                      "^(You have .* left to finish this campaign."           ..
                         "|" .. "You cannot take another campaign for .*"     ..
                         "|" .. "You are already on an active campaign!"      ..
                         "|" .. "You are not currently on a campaign."        ..
                         "|" .. "You have already had a campaign this level." ..
                      ")$",
                      "omni.hitlist.campaign.refreshDone(false)",
	                  drlTriggerFlagsBaseline + trigger_flag.OneShot,
                      custom_colour.NoChange, 0, "", "", sendto.script, 0))

  -- Start a timer to clean things up if something happens and we never see the end line (e.g., a disconnect)
  AddTimer(omni.hitlist.campaign.timer, 0, 0, 15, "",
           timer_flag.Enabled + timer_flag.Replace + timer_flag.OneShot,
           "omni.hitlist.campaign.refreshTimeout")

  SendNoEcho(command .. " " .. mode)
end -- omni.hitlist.campaign.refresh


function omni.hitlist.campaign.refreshTimeout()
  omni.hitlist.campaign.refreshDone(true)
end -- omni.hitlist.campaign.refreshTimeout


function omni.hitlist.campaign.refreshDone(didTimeout)
  --omni.print("campaign.refreshDone")

  EnableTrigger(omni.hitlist.trigger.cpLine, false)

  -- We can either be in this function because we detected the end of the refresh or because we timed out
  -- before detecting the refresh completion.  If we didn't time out, remove the cleanup timer so that it
  -- doesn't duplicate a call here.
  if (didTimeout) then
    omni.print("omni.hitlist.campaign.refreshDone: Timed out while waiting for a cp request or cp check")
  else
    DeleteTimer(omni.hitlist.campaign.timer)
  end -- if

  --omni.hitlist.display("campaign")
  omni.hitlist.callback.reply("campaign")

end -- omni.hitlist.campaign.refreshDone


function omni.hitlist.gquest.reset()
  omni.hitlist.gquest.mobs = {}
end -- omni.hitlist.gquest.reset


function omni.hitlist.gquest.refresh(command, mode)
  --omni.print("gquest.refresh")
  omni.hitlist.gquest.reset()

  EnableTrigger(omni.hitlist.trigger.gqLine, true)

  -- GQ end line(s) from "gq check"
  local gqCheckDone = "OMNI gquest check DONE"
  check (AddTriggerEx(omni.hitlist.trigger.gqEnd,
                      "^(" .. gqCheckDone .. ")$",
                      "omni.hitlist.gquest.refreshDone(false)",
	                  drlTriggerFlagsBaseline + trigger_flag.OneShot + trigger_flag.OmitFromOutput,
                      custom_colour.Custom14, 0, "", "", sendto.script, 0))

  -- Start a timer to clean things up if something happens and we never see the end line (e.g., a disconnect)
  AddTimer(omni.hitlist.gquest.timer, 0, 0, 15, "",
           timer_flag.Enabled + timer_flag.Replace + timer_flag.OneShot,
           "omni.hitlist.gquest.refreshTimeout")

  SendNoEcho(command .. " " .. mode)
  SendNoEcho("echo " .. gqCheckDone)
end -- omni.hitlist.gquest.refresh


function omni.hitlist.gquest.refreshTimeout()
  omni.hitlist.gquest.refreshDone(true)
end -- omni.hitlist.gquest.refreshTimeout


function omni.hitlist.gquest.refreshDone(didTimeout)
  --omni.print("gquest.refreshDone")

  EnableTrigger(omni.hitlist.trigger.gqLine, false)

  -- We can either be in this function because we detected the end of the refresh or because we timed out
  -- before detecting the refresh completion.  If we didn't time out, remove the cleanup timer so that it
  -- doesn't duplicate a call here.
  if (didTimeout) then
    omni.print("omni.hitlist.gquest.refreshDone: Timed out while waiting for a gq check")
  else
    DeleteTimer(omni.hitlist.gquest.timer)
  end -- if

  --omni.hitlist.display("gquest")
  omni.hitlist.callback.reply("gquest")

end -- omni.hitlist.gquest.refreshDone


function omni.hitlist.isHitlist(nameShort)
  local isHitlist = false
  local queueList = "quest campaign gquest"

  for queue in queueList:gmatch("%S+") do
    local qEntry = omni.hitlist[queue].mobs[omni.capitalize(nameShort)]
    if (qEntry ~= nil) and (qEntry.completed < qEntry.total) then
      isHitlist = true
      break
    end -- if
  end -- for

  if omni.hitlist.isBlocker(nameShort) then
    isHitlist = true
  end -- if

  return isHitlist
end -- omni.hitlist.isHitlist


omni.hitlist.blockerTable = {
  { room = 11088, nameShort = "John Little" },              -- nottingham
  { room = 11124, nameShort = "The sheriff" },              -- nottingham
  { room = 4423,  nameShort = "An earth elemental" },       -- mistridge
  { room = 4384,  nameShort = "William" },                  -- gallows
  { room = 43197, nameShort = "The captain of the guard" }, -- ascent
  { room = 6088,  nameShort = "The Balrog's Adept" },       -- volcano
  { room = 28229, nameShort = "Princess Ariadne" },         -- knossos
  { room = 16813, nameShort = "The lich" },                 -- ruins
  { room = 16817, nameShort = "The Temporal Crystal" },     -- ruins
  { room = 14992, nameShort = "A unicorn" },                -- citadel (light side)
  { room = 14977, nameShort = "A chimera" },                -- citadel (dark side)
  { room = 14997, nameShort = "A stone gargoyle" },         -- citadel (to clouds)
  { room = 14968, nameShort = "A HUGE hellhound" },         -- citadel (below labyrinth)
}


function omni.hitlist.isBlocker(nameShort)
  local isBlocker = false
  local room      = omni.getRoom()

  if (nameShort == nil) or (nameShort == "") then
    omni.error("omni.hitlist.isBlocker: Missing nameShort parameter")
    return isBlocker
  end -- if

  --omni.print("DEBUG: nameShort=\"" .. (nameShort or "nil") .. "\"")

  for _,entry in ipairs(omni.hitlist.blockerTable) do
    if ((entry.room == room) and (entry.nameShort == nameShort)) then
      isBlocker = true
      break
    end -- if
  end -- for

  return isBlocker
end -- omni.hitlist.isBlocker


function omni.hitlist.isPresent()
  local isPresent = "no"

  for i,entry in ipairs(omni.scan.table) do
    if omni.hitlist.isHitlist(entry.nameShort) then
      isPresent = "yes"
      break
    end -- if
  end -- for

  return isPresent
end -- omni.hitlist.isPresent


----------------------------------------------------------------------------------------------------
-- Room cache:  Cache mobs from the most recent N rooms so that we don't need to go to the DB
----------------------------------------------------------------------------------------------------

omni.cache             = {}
omni.cache.room        = {}
omni.cache.room.table  = {}
omni.cache.room.size   = 100
omni.cache.room.count  = 0
omni.cache.room.thresh = math.floor(omni.cache.room.size * 0.8)


function omni.cache.room.reset()
  omni.cache.room.table = {}
end -- omni.cache.room.reset


function omni.cache.room.display()
  tprint(omni.cache.room.table)
end -- omni.cache.room.display


function omni.cache.room.get(curRoom, nameLong)
  local entry = nil
  
  if (omni.cache.room.table[curRoom] ~= nil) then
    entry = omni.cache.room.table[curRoom][nameLong]
    omni.cache.room.table[curRoom].timestamp = omni.getTime()
  end -- if  

  return entry
end -- omni.cache.room.get


function omni.cache.room.set(curRoom, entry)
  if (omni.cache.room.table[curRoom] == nil) then
    omni.cache.room.clean()
    omni.cache.room.table[curRoom] = {}
    omni.cache.room.count = omni.cache.room.count + 1
  end -- if

  if (omni.cache.room.table[curRoom][entry.nameLong] == nil) then
    omni.cache.room.table[curRoom][entry.nameLong] = omni.copy(entry)
  end -- if
  
  omni.cache.room.table[curRoom].timestamp = omni.getTime()
end -- omni.cache.room.set


function omni.cache.room.clean()
  if (omni.cache.room.count < omni.cache.room.size) then
    return
  end -- if

  -- Get a sorted list of rooms with their most recent access timestamp
  local sortedRooms = {}
  for room, entry in pairs(omni.cache.room.table) do
    table.insert(sortedRooms, { room = room, timestamp = entry.timestamp })
  end -- for
  table.sort(sortedRooms, function (e1, e2) return e1.timestamp < e2.timestamp end)

  -- Calculate the number of cache entries to expel.  It is cheaper to expel several in one batch
  -- so that we don't need to pay the sorting overhead every time we expel an entry out of the cache.
  local numExpel = omni.cache.room.count - omni.cache.room.thresh

  -- Remove the required number of room entries.  This is sorted with oldest entries first.
  for i, entry in ipairs(sortedRooms) do
    if (i > numExpel) then
      break
    else
      omni.cache.room.table[entry.room] = nil
      omni.cache.room.count = omni.cache.room.count - 1
    end -- if
  end -- for

end -- omni.cache.room.clean


----------------------------------------------------------------------------------------------------
-- Miniwin!
----------------------------------------------------------------------------------------------------

require "mw_theme_base"
require "movewindow"
require "text_rect"


omni.miniwin               = {}

omni.miniwin.reset         = {}
omni.miniwin.titlebar      = {}
omni.miniwin.optionbar     = {}
omni.miniwin.summarybar    = {}

omni.miniwin.win           = "omni" .. GetPluginID()

omni.miniwin.resize        = {}
omni.miniwin.resize.startX = 0
omni.miniwin.resize.startY = 0

omni.miniwin.report        = {}
omni.miniwin.report.menu   = {}

omni.miniwin.font          = {}
omni.miniwin.font.table    = {}

omni.miniwin.isInitialized = false

omni.miniwin.drawTimer     = "omniMiniwinDrawBatchTimer"

omni.miniwin.hotspots             = {}
omni.miniwin.hotspots.graph       = "graph"
omni.miniwin.hotspots.resize      = "resize"
omni.miniwin.hotspots.modeBox     = "modeBox"
omni.miniwin.hotspots.groupText   = "groupText"
omni.miniwin.hotspots.ngroupText  = "ngroupText"
omni.miniwin.hotspots.mobRoom     = "mobRoom"
omni.miniwin.hotspots.groupRoom   = "groupRoomBox"
omni.miniwin.hotspots.groupArea   = "groupAreaBox"
omni.miniwin.hotspots.ngroupRoom  = "ngroupRoomBox"
omni.miniwin.hotspots.ngroupArea  = "ngroupAreaBox"
omni.miniwin.hotspots.discBox     = "discBox"
omni.miniwin.hotspots.hpBox       = "hpBox"
omni.miniwin.hotspots.hppBox      = "hppBox"
omni.miniwin.hotspots.qtBox       = "qtBox"
omni.miniwin.hotspots.tnlBox      = "tnlBox"
omni.miniwin.hotspots.mvBox       = "mvBox"
omni.miniwin.hotspots.mnBox       = "mnBox"
omni.miniwin.hotspots.tgtBox      = "tgtBox"
omni.miniwin.hotspots.dmgBox      = "dmgBox"
omni.miniwin.hotspots.nareaBox    = "nareaBox"


function omni.miniwin.init()
  local result

  omni.miniwin.reset.defaults()

  omni.miniwin.load()

  omni.miniwin.windowInfo = movewindow.install(omni.miniwin.win, 
                                               miniwin.pos_top_right,
                                               miniwin.create_absolute_location,
                                               false,
                                               nil,
                                               {mouseup=MouseUp, mousedown=LeftClickOnly,
                                                dragmove=LeftClickOnly, dragrelease=LeftClickOnly},
                                               {x = omni.miniwin.dims.x, y = omni.miniwin.dims.y})

  check (WindowCreate(omni.miniwin.win,
                      omni.miniwin.windowInfo.window_left,
                      omni.miniwin.windowInfo.window_top,
                      omni.miniwin.dims.width,
                      omni.miniwin.dims.height,
                      omni.miniwin.windowInfo.window_mode,
                      omni.miniwin.windowInfo.window_flags,
                      Theme.SECONDARY_BODY))

  omni.miniwin.font.add()
  omni.miniwin.optionbar.calc() -- need fonts before we can calc this
  omni.miniwin.summarybar.calc() -- need fonts before we can calc this

  -- Add handler for resizing
  WindowAddHotspot(omni.miniwin.win,
                   omni.miniwin.hotspots.resize,
                   omni.miniwin.dims.width - Theme.RESIZER_SIZE,
                   omni.miniwin.dims.height - Theme.RESIZER_SIZE,
                   omni.miniwin.dims.width,
                   omni.miniwin.dims.height,
                   nil, nil, "omni.miniwin.mouseDown", nil, nil, "", 6, 0)

  WindowDragHandler(omni.miniwin.win,
                    omni.miniwin.hotspots.resize,
                    "omni.miniwin.resize.moveCallback",
                    "omni.miniwin.resize.releaseCallback",
                    0)

  omni.miniwin.report.calc()
  omni.miniwin.report.rect = TextRect.new(omni.miniwin.win,
                                          "tr",
                                          omni.miniwin.report.left,
                                          omni.miniwin.report.top,
                                          omni.miniwin.report.right,
                                          omni.miniwin.report.bottom,
                                          1000, false, Theme.PRIMARY_BODY, 3,
                                          omni.miniwin.font.table.report.name,
                                          omni.miniwin.font.table.report.size)
  omni.miniwin.report.rect:setExternalMenuFunction(omni.miniwin.report.menu.string,
                                                   omni.miniwin.report.menu.result)
                                                   
  WindowSetZOrder(omni.miniwin.win, 20) -- Put the window on the 20th layer (hopefully the top!)

  omni.miniwin.graph.init()

  omni.miniwin.isInitialized = true

  if omni.miniwin.isEnabled() then
    omni.miniwin.show()
  end -- if

end -- omni.miniwin.init


function omni.miniwin.fini()
  DeleteTimer(omni.miniwin.drawTimer)
  omni.miniwin.isInitialized = false
  omni.miniwin.hide()
  omni.miniwin.graph.fini()
  WindowDelete(omni.miniwin.win)
end -- omni.miniwin.fini


function omni.miniwin.reset.all()
  omni.miniwin.fini()
  omni.miniwin.init()
end -- omni.miniwin.reset.all


function omni.miniwin.reset.defaults()
  omni.miniwin.font.table.option = { id = "optionFont", name = "Consolas", size = 11 }
  omni.miniwin.font.table.report = { id = "reportFont", name = "Consolas", size = 11 }
  omni.miniwin.font.table.title  = { id = "titleFont",  name = "Consolas", size = 10 }
  omni.miniwin.font.table.graph  = { id = "graphFont",  name = "Consolas", size = 10 }

  omni.miniwin.windowInfo  = nil

  omni.miniwin.dims        = {}
  omni.miniwin.dims.width  = 600
  omni.miniwin.dims.height = 400
  omni.miniwin.dims.x      = 100
  omni.miniwin.dims.y      = 100

  omni.miniwin.lastRefresh = 0

  omni.miniwin.titlebar.left   = 0
  omni.miniwin.titlebar.right  = 0
  omni.miniwin.titlebar.top    = 0
  omni.miniwin.titlebar.bottom = 0

  local hotspotList = "modeBox groupText ngroupText mobRoom groupRoom groupArea ngroupRoom ngroupArea " ..
                      "discBox hpBox hppBox qtBox tnlBox mvBox mnBox tgtBox dmgBox nareaBox"
  for hs in hotspotList:gmatch("%S+") do
    omni.miniwin[hs] = {}
    omni.miniwin[hs].mouseOver = false
  end -- for

end -- omni.miniwin.reset.defaults


function omni.miniwin.reset.aard()
  omni.miniwin.reset.all()

  WindowPosition(omni.miniwin.win,
                 omni.miniwin.dims.x,
                 omni.miniwin.dims.y,
                 miniwin.pos_stretch_to_view,
                 miniwin.create_absolute_location + miniwin.create_keep_hotspots)
  WindowResize(omni.miniwin.win,
               omni.miniwin.dims.width,
               omni.miniwin.dims.height,
               Theme.SECONDARY_BODY)
  Repaint() -- hack because WindowPosition doesn't immediately update coordinates
  SaveState()
  OnPluginInstall()
end -- omni.miniwin.reset.aard


function omni.miniwin.save()

  movewindow.save_state(omni.miniwin.win)

  omni.miniwin.dims.x      = WindowInfo(omni.miniwin.win, 17) or omni.miniwin.dims.x      or 100
  omni.miniwin.dims.y      = WindowInfo(omni.miniwin.win, 18) or omni.miniwin.dims.y      or 200
  omni.miniwin.dims.width  = WindowInfo(omni.miniwin.win, 3)  or omni.miniwin.dims.width  or 400
  omni.miniwin.dims.height = WindowInfo(omni.miniwin.win, 4)  or omni.miniwin.dims.height or 200

  SetVariable("omniMiniwinDims", serialize.save("omni.miniwin.dims", omni.miniwin.dims))

  SetVariable("omniMiniwinFont", serialize.save("omni.miniwin.font.table", omni.miniwin.font.table))

end -- omni.miniwin.save


function omni.miniwin.load()

  -- If we have stored font or window dimension info, grab it.  Otherwise, use the defaults.
  loadstring(GetVariable("omniMiniwinFont") or "")()
  loadstring(GetVariable("omniMiniwinDims") or "")()

  -- This mode was added after other fonts so some installations may not have it stored
  if (omni.miniwin.font.table.graph == nil) then
    omni.miniwin.font.table.graph  = { id = "graphFont",  name = "Consolas", size = 8 }
  end -- if

end -- omni.miniwin.load


function omni.miniwin.set(enable)
  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.miniwin.set: invalid miniwin mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("miniwinState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
    omni.miniwin.show()
  else
    msg = "@RDISABLED@w"
    omni.miniwin.hide()
  end -- if

  omni.print("@WMini-window is " .. msg)

end -- omni.miniwin.set


function omni.miniwin.get()
  return (GetVariable("miniwinState") or "")
end -- omni.miniwin.get


function omni.miniwin.isEnabled()
  if (omni.miniwin.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.miniwin.isEnabled


function omni.miniwin.show()
  WindowShow(omni.miniwin.win, true)
  omni.miniwin.draw()
end -- omni.miniwin.show


function omni.miniwin.hide()
  omni.miniwin.save()
  WindowShow(omni.miniwin.win, false)
end -- omni.miniwin.hide


function omni.miniwin.font.add()
  local fonts = utils.getfontfamilies ()

  if not fonts.Dina then
    AddFont(GetInfo(66) .. "\\Dina.fon")
  end -- if
  if not fonts.Consolas then
    AddFont(GetInfo(66) .. "\\Consolas.fon")
  end -- if

  local fontList = "option report title graph"
  for font in fontList:gmatch("%S+") do
    local fontEntry = omni.miniwin.font.table[font]
    if (fontEntry ~= nil) then
      local mushRet = WindowFont(omni.miniwin.win, fontEntry.id, fontEntry.name, fontEntry.size,
                                 false, false, false, false, 0)
      if (mushRet ~= 0) then
        omni.error("omni.miniwin.font.add: failed to add font \"" .. (fontEntry.name or "nil") .. 
                   "\", returned " .. mushRet)
      else
        omni.miniwin.font.table[font].height = Theme.TextHeight(omni.miniwin.win, fontEntry.id)
        omni.miniwin.font.table[font].width  = WindowTextWidth(omni.miniwin.win, fontEntry.id, "x")
      end -- if
    end -- if
  end -- for

end -- omni.miniwin.font.add


function omni.miniwin.font.update(loc, name, size)
  if (loc == nil) or (omni.miniwin.font.table[loc] == nil) then
    omni.error("omni.miniwin.font.update: invalid font location \"" .. (loc or "nil") .. "\"")
    return
  end -- if

  -- Put a floor on the font size
  if ((loc == "report") and (size < 7)) or
     ((loc == "option") and (size < 7)) or
     ((loc == "graph")  and (size < 7)) or
     ((loc == "title")  and (size < 6)) then
    return
  end -- if

  omni.miniwin.font.table[loc].name = name
  omni.miniwin.font.table[loc].size = size
  omni.miniwin.font.add()

  omni.miniwin.save()

  if (loc == "report") then
    omni.miniwin.report.rect:loadFont(name, size)
    omni.miniwin.report.rect:reWrapLines()
  end -- if

  omni.miniwin.draw()

end -- omni.miniwin.font.update


function omni.miniwin.report.scrollwheel(flags, hotspotId)

  if (bit.band(flags, 0x100) ~= 0) then
    omni.miniwin.font.update("report",
                             omni.miniwin.font.table.report.name, omni.miniwin.font.table.report.size + 1)
    omni.miniwin.font.update("option",
                             omni.miniwin.font.table.option.name, omni.miniwin.font.table.option.size + 1)
    omni.miniwin.font.update("graph",
                             omni.miniwin.font.table.graph.name,  omni.miniwin.font.table.graph.size  + 1)
    omni.miniwin.font.update("title",
                             omni.miniwin.font.table.title.name,  omni.miniwin.font.table.title.size  + 1)
  else
    omni.miniwin.font.update("report",
                             omni.miniwin.font.table.report.name, omni.miniwin.font.table.report.size - 1)
    omni.miniwin.font.update("option",
                             omni.miniwin.font.table.option.name, omni.miniwin.font.table.option.size - 1)
    omni.miniwin.font.update("graph",
                             omni.miniwin.font.table.graph.name,  omni.miniwin.font.table.graph.size  - 1)
    omni.miniwin.font.update("title",
                             omni.miniwin.font.table.title.name,  omni.miniwin.font.table.title.size  - 1)
  end -- if

  return 0
end -- omni.miniwin.report.scrollwheel


function omni.miniwin.report.menu.string(trect)
  local titlebarView = ""
  if omni.miniwin.titlebar.isEnabled() then
    titlebarView = "+"
  end -- if

  local optionbarView = ""
  if omni.miniwin.optionbar.isEnabled() then
    optionbarView = "+"
  end -- if

  local summarybarView = ""
  if omni.miniwin.summarybar.isEnabled() then
    summarybarView = "+"
  end -- if

  local discPrefix = ""
  if omni.discover.isEnabled() then
    discPrefix = "+"
  end -- if

  local prefixList = "hp hpp qt tnl mv mn tgt dmg"
  local prefixTable = {}
  for prefix in prefixList:gmatch("%S+") do
    if omni.report.isEnabled(prefix) then
      prefixTable[prefix] = "+"
    else
      prefixTable[prefix] = ""
    end -- if
  end -- for

  local basicPrefix, graphPrefix = "", ""
  if omni.miniwin.mode.isEnabled("basic") then
    basicPrefix = "+"
  else
    graphPrefix = "+"
  end -- if

  local menuTable = {
    "!" .. titlebarView .. "Title Bar",
    optionbarView .. "Option Bar",
    summarybarView .. "Summary Bar",
    "-",
    discPrefix         .. "Auto-Discover Mobs",
    "-",
    ">Mode",
    basicPrefix .. "Basic",
    graphPrefix .. "Graphical",
    "<",
    "-",
    ">Report",
    prefixTable["hp"]  .. "HP % (adds study overhead)",
    prefixTable["hpp"] .. "HP +/-",
    prefixTable["qt"]  .. "Quest Time",
    prefixTable["tnl"] .. "TNL XP",
    prefixTable["mv"]  .. "Moves",
    prefixTable["mn"]  .. "Mana",
    prefixTable["tgt"] .. "Mob Targets",
    prefixTable["dmg"] .. "Player Damage",
    "<",
    "-",
    ">Scan",
      ">Room (sec)",
      omni.miniwin.report.menu.select(0, 10, omni.scan.timer.get("room")),
      "<",
      ">Area (sec)",
      omni.miniwin.report.menu.select(0, 10, omni.scan.timer.get("area")),
      "<",
      ">Players (min)",
      omni.miniwin.report.menu.select(0, 10, omni.scan.timer.get("players") / 60),
      "<",
    "<",
    "-",
    "Configure Font",
    "Screenshot",
    "-",
    "Bring to Front",
    "Send to Back"
  }

  return table.concat(menuTable, "|")
end -- omni.miniwin.report.menu.string


function omni.miniwin.report.menu.select(startNum, endNum, selectNum)
  local selStr = ""

  for i = startNum, endNum do
    if (i == selectNum) then
      selStr = selStr .. "+" .. i
    else
      selStr = selStr .. i
    end -- if

    if (i ~= endNum) then
      selStr = selStr .. "|"
    end -- if
  end -- for

  return selStr
end -- omni.miniwin.report.menu.select


omni.miniwin.rclick = { titlebar    = 1,
                        optionbar   = 2,
                        summarybar  = 3,
                        discover    = 4,
                        basic       = 5,
                        graphical   = 6,
                        hp          = 7,
                        hpp         = 8,
                        qt          = 9,
                        tnl         = 10,
                        mv          = 11,
                        mn          = 12,
                        tgt         = 13,
                        dmg         = 14,
                        roomStart   = 15,
                        roomEnd     = 25,
                        areaStart   = 26,
                        areaEnd     = 36,
                        playerStart = 37,
                        playerEnd   = 47,
                        configFont  = 48,
                        screenshot  = 49,
                        bringFront  = 50,
                        sendBack    = 51 }


function omni.miniwin.report.menu.result(sender, hotspotId, result)
  local rct = omni.miniwin.rclick

  if (result == rct.titlebar) then
    if omni.miniwin.titlebar.isEnabled() then
      omni.miniwin.titlebar.set("off")
    else
      omni.miniwin.titlebar.set("on")
    end -- if

  elseif (result == rct.optionbar) then
    if omni.miniwin.optionbar.isEnabled() then
      omni.miniwin.optionbar.set("off")
    else
      omni.miniwin.optionbar.set("on")
    end -- if

  elseif (result == rct.summarybar) then
    if omni.miniwin.summarybar.isEnabled() then
      omni.miniwin.summarybar.set("off")
    else
      omni.miniwin.summarybar.set("on")
    end -- if

  elseif (result == rct.discover) then
    if omni.discover.isEnabled() then
      omni.discover.set("off")
    else
      omni.discover.set("on")
    end -- if

  elseif (result == rct.basic) then
    omni.miniwin.mode.set("basic")

  elseif (result == rct.graphical) then
    omni.miniwin.mode.set("graphic")

  elseif (result == rct.hp) then
    if omni.report.isEnabled("hp") then
      omni.report.set("hp", "off")
    else
      omni.report.set("hp", "on")
    end -- if

  elseif (result == rct.hpp) then
    if omni.report.isEnabled("hpp") then
      omni.report.set("hpp", "off")
    else
      omni.report.set("hpp", "on")
    end -- if

  elseif (result == rct.qt) then
    if omni.report.isEnabled("qt") then
      omni.report.set("qt", "off")
    else
      omni.report.set("qt", "on")
    end -- if

  elseif (result == rct.tnl) then
    if omni.report.isEnabled("tnl") then
      omni.report.set("tnl", "off")
    else
      omni.report.set("tnl", "on")
    end -- if

  elseif (result == rct.mv) then
    if omni.report.isEnabled("mv") then
      omni.report.set("mv", "off")
    else
      omni.report.set("mv", "on")
    end -- if

  elseif (result == rct.mn) then
    if omni.report.isEnabled("mn") then
      omni.report.set("mn", "off")
    else
      omni.report.set("mn", "on")
    end -- if

  elseif (result == rct.tgt) then
    if omni.report.isEnabled("tgt") then
      omni.report.set("tgt", "off")
    else
      omni.report.set("tgt", "on")
    end -- if

  elseif (result == rct.dmg) then
    if omni.report.isEnabled("dmg") then
      omni.report.set("dmg", "off")
    else
      omni.report.set("dmg", "on")
    end -- if

  elseif (result >= rct.roomStart) and (result <= rct.roomEnd) then
    local roomTimerSec = result - rct.roomStart
    Execute("omni scan room " .. roomTimerSec)

  elseif (result >= rct.areaStart) and (result <= rct.areaEnd) then
    local areaTimerSec = result - rct.areaStart
    Execute("omni scan area " .. areaTimerSec)

  elseif (result >= rct.playerStart) and (result <= rct.playerEnd) then
    local playerTimerMin = result - rct.playerStart
    Execute("omni scan players " .. (60 * playerTimerMin))

  elseif (result == rct.configFont) then
    newFont = utils.fontpicker(omni.miniwin.font.table.report.name, omni.miniwin.font.table.report.size)
    if (newFont ~= nil) then
      omni.miniwin.font.update("report", newFont.name, newFont.size)

      -- We allow the option to change size, but we keep it the default font (for now at least)
      omni.miniwin.font.update("option", omni.miniwin.font.table.option.name, newFont.size)
    end -- if

  elseif (result == rct.screenshot) then
    local fileName = utils.filepicker("OMNI Screenshot", "OMNI_screenshot", "png", nil, true)
    if (fileName ~= nil) then
      WindowWrite(omni.miniwin.win, fileName)
      omni.print("Saving screenshot \"" .. (fileName or "nil") .. "\"")
    end -- if

  elseif (result == rct.bringFront) then
    WindowSetZOrder(omni.miniwin.win, 100)

  elseif (result == rct.sendBack) then
    WindowSetZOrder(omni.miniwin.win, -100)

  end -- if

  omni.miniwin.draw()
end -- omni.miniwin.report.menu.result


function omni.miniwin.report.calc()
  local pad = 5

  omni.miniwin.report.left   = pad
  omni.miniwin.report.right  = omni.miniwin.dims.width - pad
  omni.miniwin.report.top    = omni.miniwin.titlebar.bottom  +
                               omni.miniwin.optionbar.height +
                               omni.miniwin.summarybar.height 
  omni.miniwin.report.bottom = omni.miniwin.dims.height - pad - Theme.RESIZER_SIZE

end -- omni.miniwin.report.calc


function omni.miniwin.write(msg, doClear)
  if (doClear == true) then
    omni.miniwin.report.rect:clear()
  end -- if

  -- Trim the message to fit in the rect (we don't use scrollbars here)
  local lineCount = 0
  for line in msg:gmatch("[^\n]+") do
    if (lineCount < omni.miniwin.report.rect.rect_lines) then
      omni.miniwin.report.rect:addColorLine(line or "")
    else
      break
    end -- if

    lineCount = lineCount + 1
  end -- if

end -- omni.miniwin.write


function omni.miniwin.mouseOver(flags, hotspotId)

  if (hotspotId == omni.miniwin.hotspots.modeBox) then
    omni.miniwin.modeBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.mobRoom) then
    omni.miniwin.mobRoom.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.groupRoom) then
    omni.miniwin.groupRoom.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.groupArea) then
    omni.miniwin.groupArea.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.ngroupRoom) then
    omni.miniwin.ngroupRoom.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.ngroupArea) then
    omni.miniwin.ngroupArea.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.discBox) then
    omni.miniwin.discBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.hpBox) then
    omni.miniwin.hpBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.hppBox) then
    omni.miniwin.hppBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.qtBox) then
    omni.miniwin.qtBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.tnlBox) then
    omni.miniwin.tnlBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.mvBox) then
    omni.miniwin.mvBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.mnBox) then
    omni.miniwin.mnBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.tgtBox) then
    omni.miniwin.tgtBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.dmgBox) then
    omni.miniwin.dmgBox.mouseOver = true
  elseif (hotspotId == omni.miniwin.hotspots.nareaBox) then
    omni.miniwin.nareaBox.mouseOver = true
  end -- if

  omni.miniwin.draw()
end -- omni.miniwin.mouseOver


function omni.miniwin.mouseOverCancel(flags, hotspotId)

  if (hotspotId == omni.miniwin.hotspots.modeBox) then
    omni.miniwin.modeBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.mobRoom) then
    omni.miniwin.mobRoom.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.groupRoom) then
    omni.miniwin.groupRoom.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.groupArea) then
    omni.miniwin.groupArea.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.ngroupRoom) then
    omni.miniwin.ngroupRoom.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.ngroupArea) then
    omni.miniwin.ngroupArea.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.discBox) then
    omni.miniwin.discBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.hpBox) then
    omni.miniwin.hpBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.hppBox) then
    omni.miniwin.hppBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.qtBox) then
    omni.miniwin.qtBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.tnlBox) then
    omni.miniwin.tnlBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.mvBox) then
    omni.miniwin.mvBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.mnBox) then
    omni.miniwin.mnBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.tgtBox) then
    omni.miniwin.tgtBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.dmgBox) then
    omni.miniwin.dmgBox.mouseOver = false
  elseif (hotspotId == omni.miniwin.hotspots.nareaBox) then
    omni.miniwin.nareaBox.mouseOver = false
  end -- if

  omni.miniwin.draw()
end -- omni.miniwin.mouseOverCancel


function omni.miniwin.mouseDown(flags, hotspotId)

  if (hotspotId == omni.miniwin.hotspots.resize) then
    omni.miniwin.resize.startX = WindowInfo(omni.miniwin.win, 17)
    omni.miniwin.resize.startY = WindowInfo(omni.miniwin.win, 18)

  elseif (hotspotId == omni.miniwin.hotspots.modeBox) then
    if omni.miniwin.mode.isEnabled("basic") then
      omni.miniwin.mode.set("graphic")
    else
      omni.miniwin.mode.set("basic")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.mobRoom) then
    if omni.report.isEnabled("mob") then
      omni.report.set("mob", "off")
    else
      omni.report.set("mob", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.groupRoom) then
    if omni.report.isEnabled("grp") then
      omni.report.set("grp", "off")
    else
      omni.report.set("grp", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.groupArea) then
    if omni.report.isEnabled("grp-area") then
      omni.report.set("grp-area", "off")
    else
      omni.report.set("grp-area", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.ngroupRoom) then
    if omni.report.isEnabled("~grp") then
      omni.report.set("~grp", "off")
    else
      omni.report.set("~grp", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.ngroupArea) then
    if omni.report.isEnabled("~grp-area") then
      omni.report.set("~grp-area", "off")
    else
      omni.report.set("~grp-area", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.discBox) then
    if omni.discover.isEnabled() then
      omni.discover.set("off")
    else
      omni.discover.set("on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.hpBox) then
    if omni.report.isEnabled("hp") then
      omni.report.set("hp", "off")
    else
      omni.report.set("hp", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.hppBox) then
    if omni.report.isEnabled("hpp") then
      omni.report.set("hpp", "off")
    else
      omni.report.set("hpp", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.qtBox) then
    if omni.report.isEnabled("qt") then
      omni.report.set("qt", "off")
    else
      omni.report.set("qt", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.tnlBox) then
    if omni.report.isEnabled("tnl") then
      omni.report.set("tnl", "off")
    else
      omni.report.set("tnl", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.mvBox) then
    if omni.report.isEnabled("mv") then
      omni.report.set("mv", "off")
    else
      omni.report.set("mv", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.mnBox) then
    if omni.report.isEnabled("mn") then
      omni.report.set("mn", "off")
    else
      omni.report.set("mn", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.tgtBox) then
    if omni.report.isEnabled("tgt") then
      omni.report.set("tgt", "off")
    else
      omni.report.set("tgt", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.dmgBox) then
    if omni.report.isEnabled("dmg") then
      omni.report.set("dmg", "off")
    else
      omni.report.set("dmg", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.nareaBox) then
    if omni.report.isEnabled("narea") then
      omni.report.set("narea", "off")
    else
      omni.report.set("narea", "on")
    end -- if

  elseif (hotspotId == omni.miniwin.hotspots.groupText) then
    -- placeholder

  elseif (hotspotId == omni.miniwin.hotspots.ngroupText) then
    -- placeholder

  elseif (hotspotId == omni.miniwin.hotspots.graph) then
    -- placeholder
  end -- if

  omni.miniwin.draw()
end -- omni.miniwin.mouseDown


function omni.miniwin.mouseDownCancel(flags, hotspotId)

  if (hotspotId == omni.miniwin.hotspots.modeBox) then

  elseif (hotspotId == omni.miniwin.hotspots.mobRoom) then

  elseif (hotspotId == omni.miniwin.hotspots.groupRoom) then

  elseif (hotspotId == omni.miniwin.hotspots.groupArea) then

  elseif (hotspotId == omni.miniwin.hotspots.ngroupRoom) then

  elseif (hotspotId == omni.miniwin.hotspots.ngroupArea) then

  elseif (hotspotId == omni.miniwin.hotspots.discBox) then

  elseif (hotspotId == omni.miniwin.hotspots.hpBox) then

  elseif (hotspotId == omni.miniwin.hotspots.hppBox) then

  elseif (hotspotId == omni.miniwin.hotspots.qtBox) then

  elseif (hotspotId == omni.miniwin.hotspots.tnlBox) then

  elseif (hotspotId == omni.miniwin.hotspots.mvBox) then

  elseif (hotspotId == omni.miniwin.hotspots.mnBox) then

  elseif (hotspotId == omni.miniwin.hotspots.tgtBox) then

  elseif (hotspotId == omni.miniwin.hotspots.dmgBox) then

  elseif (hotspotId == omni.miniwin.hotspots.nareaBox) then

  end -- if

  omni.miniwin.draw()
end -- omni.miniwin.mouseDownCancel


function omni.miniwin.mouseUp(flags, hotspotId)

  if (hotspotId == omni.miniwin.hotspots.modeBox) then

  elseif (hotspotId == omni.miniwin.hotspots.mobRoom) then

  elseif (hotspotId == omni.miniwin.hotspots.groupRoom) then

  elseif (hotspotId == omni.miniwin.hotspots.groupArea) then

  elseif (hotspotId == omni.miniwin.hotspots.ngroupRoom) then

  elseif (hotspotId == omni.miniwin.hotspots.ngroupArea) then

  elseif (hotspotId == omni.miniwin.hotspots.discBox) then

  elseif (hotspotId == omni.miniwin.hotspots.hpBox) then

  elseif (hotspotId == omni.miniwin.hotspots.hppBox) then

  elseif (hotspotId == omni.miniwin.hotspots.qtBox) then

  elseif (hotspotId == omni.miniwin.hotspots.tnlBox) then

  elseif (hotspotId == omni.miniwin.hotspots.mvBox) then

  elseif (hotspotId == omni.miniwin.hotspots.mnBox) then

  elseif (hotspotId == omni.miniwin.hotspots.tgtBox) then

  elseif (hotspotId == omni.miniwin.hotspots.dmgBox) then

  elseif (hotspotId == omni.miniwin.hotspots.nareaBox) then

  elseif (hotspotId == omni.miniwin.hotspots.graph) then
    -- Pop up a menu if this is a right-click
    if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      local result = WindowMenu(omni.miniwin.win, WindowInfo(omni.miniwin.win, 14),
                                WindowInfo(omni.miniwin.win, 15), omni.miniwin.report.menu.string())
      omni.miniwin.report.menu.result(nil, hotspotId, (tonumber(result or "") or 0))
    else
      omni.miniwin.graph.dims.splitX = WindowInfo(omni.miniwin.win, 14)
      omni.miniwin.graph.split.set(omni.miniwin.graph.dims.splitX)
    end -- if

  end -- if

  omni.miniwin.draw()
end -- omni.miniwin.mouseUp


function omni.miniwin.resize.moveCallback()

  if GetPluginVariable("c293f9e7f04dde889f65cb90", "lock_down_miniwindows") == "1" then
    return
  end

  local currentX = WindowInfo(omni.miniwin.win, 17)
  local currentY = WindowInfo(omni.miniwin.win, 18)

  omni.miniwin.dims.width = omni.miniwin.dims.width + currentX - omni.miniwin.resize.startX
  omni.miniwin.resize.startX = currentX

  -- The window's minimum width is the larger of the optionbar width and summarybar width
  local minWidth = omni.miniwin.optionbar.minWidth
  if (omni.miniwin.optionbar.minWidth > omni.miniwin.summarybar.minWidth) then
    minWidth = omni.miniwin.optionbar.minWidth
  else
    minWidth = omni.miniwin.summarybar.minWidth
  end -- if

  if (minWidth > omni.miniwin.dims.width) then
    omni.miniwin.dims.width = minWidth
    omni.miniwin.resize.startX = omni.miniwin.windowInfo.window_left + omni.miniwin.dims.width
  elseif (omni.miniwin.windowInfo.window_left + omni.miniwin.dims.width > GetInfo(281)) then
    omni.miniwin.dims.width = GetInfo(281) - omni.miniwin.windowInfo.window_left
    omni.miniwin.resize.startX = GetInfo(281)
  end -- if

  omni.miniwin.dims.height = omni.miniwin.dims.height + currentY - omni.miniwin.resize.startY
  omni.miniwin.resize.startY = currentY

  local minHeight = 3 * Theme.RESIZER_SIZE + 70
  if (minHeight > omni.miniwin.dims.height) then
    omni.miniwin.dims.height = minHeight
    omni.miniwin.dims.y      = omni.miniwin.windowInfo.window_top + omni.miniwin.dims.height
  elseif (omni.miniwin.windowInfo.window_top + omni.miniwin.dims.height > GetInfo(280)) then
    omni.miniwin.dims.height = GetInfo(280) - omni.miniwin.windowInfo.window_top
    omni.miniwin.resize.startY = GetInfo(280)
  end -- if

  omni.miniwin.report.calc()

  if (utils.timer() - omni.miniwin.lastRefresh > 0.0333) then
    omni.miniwin.draw()
    omni.miniwin.lastRefresh = utils.timer()
  end
end -- omni.miniwin.resize.moveCallback


function omni.miniwin.resize.releaseCallback()
  omni.miniwin.report.rect:reWrapLines()
  omni.miniwin.draw()

  WindowMoveHotspot(omni.miniwin.win,
                    omni.miniwin.hotspots.resize,
                    omni.miniwin.dims.width - Theme.RESIZER_SIZE,
                    omni.miniwin.dims.height - Theme.RESIZER_SIZE,
                    0, 0)
end -- omni.miniwin.resize.releaseCallback


function omni.miniwin.optionbar.calc()
  omni.miniwin.optionbar.padding  = Theme.TITLE_PADDING + 2
  omni.miniwin.optionbar.height   = omni.miniwin.font.table.option.height + (4 * omni.miniwin.optionbar.padding)
  omni.miniwin.optionbar.width    = omni.miniwin.dims.width - 2 -- leave room for a 1-pixel border
  omni.miniwin.optionbar.minWidth = omni.miniwin.optionbar.width
end -- omni.miniwin.optionbar.calc


function omni.miniwin.optionbar.draw()

  omni.miniwin.optionbar.calc()

  -- Delete hotspots that are not common to all modes (we don't want them to be active in a mode where
  -- they are not used)
  if omni.miniwin.mode.isEnabled("basic") or (not omni.miniwin.optionbar.isEnabled()) then
    local hotspotList = "hppBox qtBox tnlBox mvBox mnBox tgtBox dmgBox"
    for hs in hotspotList:gmatch("%S+") do
      WindowDeleteHotspot(omni.miniwin.win, omni.miniwin.hotspots[hs])
    end -- for
  end -- if

  if (not omni.miniwin.optionbar.isEnabled()) then
    local hotspotList = "modeBox discBox hpBox"
    for hs in hotspotList:gmatch("%S+") do
      WindowDeleteHotspot(omni.miniwin.win, omni.miniwin.hotspots[hs])
    end -- for

    omni.miniwin.optionbar.width    = 0
    omni.miniwin.optionbar.height   = 0
    omni.miniwin.optionbar.minWidth = 0
    return
  end -- if

  local currentX = 1

  WindowGradient(omni.miniwin.win, currentX, omni.miniwin.titlebar.bottom, omni.miniwin.optionbar.width,
                 omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height / 2,
                 0x002000, 0x004000, 2)

  WindowGradient(omni.miniwin.win, currentX, omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height / 2,
                 omni.miniwin.optionbar.width, omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height,
                 0x004000, 0x002000, 2)

  WindowRectOp(omni.miniwin.win, 1, currentX, omni.miniwin.titlebar.bottom, omni.miniwin.optionbar.width,
               omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height,
               0x000000, 0)

  local textColorDeselected = 0x00C000
  local textColorSelected   = 0x10F010
  local textColorHover      = 0xFFFFFF
  local backColorDeselected = 0x103010
  local backColorSelected   = 0x205020

  currentX = omni.miniwin.font.table.option.width

  local modeBox   = {}
  modeBox.text    = (omni.miniwin.mode.table[omni.miniwin.mode.get() or ""] or "ERROR")
  modeBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, modeBox.text)
  modeBox.left    = currentX
  modeBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  modeBox.right   = modeBox.left + modeBox.textLen + (2 * omni.miniwin.optionbar.padding)
  modeBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.miniwin.modeBox.mouseOver then
    modeBox.textColor = textColorHover
    modeBox.backColor = backColorDeselected
  else
    modeBox.textColor = textColorDeselected
    modeBox.backColor = backColorDeselected
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.modeBox,
                   modeBox.left, modeBox.top, modeBox.right, modeBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Select OMNI mode", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, modeBox.left, modeBox.top, modeBox.right, modeBox.bottom,
               modeBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, modeBox.left, modeBox.top, modeBox.right, modeBox.bottom,
               backColorDeselected, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, modeBox.text,
             modeBox.left + omni.miniwin.optionbar.padding, modeBox.top + omni.miniwin.optionbar.padding,
             modeBox.right - omni.miniwin.optionbar.padding, modeBox.bottom - omni.miniwin.optionbar.padding,
             modeBox.textColor, false)

  currentX = modeBox.right + omni.miniwin.font.table.option.width

  local discBox   = {}
  discBox.text    = "Disc"
  discBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, discBox.text)
  discBox.left    = currentX
  discBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  discBox.right   = discBox.left + discBox.textLen + (2 * omni.miniwin.optionbar.padding)
  discBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.discover.isEnabled() then
    discBox.textColor = textColorSelected
    discBox.backColor = backColorSelected
  else
    discBox.textColor = textColorDeselected
    discBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.discBox.mouseOver then
    discBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.discBox,
                   discBox.left, discBox.top, discBox.right, discBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting mob and player DISCOVER", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, discBox.left, discBox.top, discBox.right, discBox.bottom,
               discBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, discBox.left, discBox.top, discBox.right, discBox.bottom,
               discBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, discBox.text,
             discBox.left + omni.miniwin.optionbar.padding, discBox.top + omni.miniwin.optionbar.padding,
             discBox.right - omni.miniwin.optionbar.padding, discBox.bottom - omni.miniwin.optionbar.padding,
             discBox.textColor, false)             

  currentX = discBox.right + omni.miniwin.font.table.option.width

  local hpBox   = {}
  hpBox.text    = "HP%"
  hpBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, hpBox.text)
  hpBox.left    = currentX
  hpBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  hpBox.right   = hpBox.left + hpBox.textLen + (2 * omni.miniwin.optionbar.padding)
  hpBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("hp") then
    hpBox.textColor = textColorSelected
    hpBox.backColor = backColorSelected
  else
    hpBox.textColor = textColorDeselected
    hpBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.hpBox.mouseOver then
    hpBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.hpBox,
                   hpBox.left, hpBox.top, hpBox.right, hpBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting mob and player HP", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, hpBox.left, hpBox.top, hpBox.right, hpBox.bottom,
               hpBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, hpBox.left, hpBox.top, hpBox.right, hpBox.bottom,
               hpBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, hpBox.text,
             hpBox.left + omni.miniwin.optionbar.padding, hpBox.top + omni.miniwin.optionbar.padding,
             hpBox.right - omni.miniwin.optionbar.padding, hpBox.bottom - omni.miniwin.optionbar.padding,
             hpBox.textColor, false)             

  currentX = hpBox.right + omni.miniwin.font.table.option.width

  -- This is as far as we go in basic mode
  if omni.miniwin.mode.isEnabled("basic") then
    omni.miniwin.optionbar.minWidth = currentX +
                                      omni.miniwin.font.table.option.width +
                                      omni.miniwin.optionbar.padding
    return
  end -- if

  local hppBox   = {}
  hppBox.text    = "HP+"
  hppBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, hppBox.text)
  hppBox.left    = currentX
  hppBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  hppBox.right   = hppBox.left + hppBox.textLen + (2 * omni.miniwin.optionbar.padding)
  hppBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("hpp") then
    hppBox.textColor = textColorSelected
    hppBox.backColor = backColorSelected
  else
    hppBox.textColor = textColorDeselected
    hppBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.hppBox.mouseOver then
    hppBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.hppBox,
                   hppBox.left, hppBox.top, hppBox.right, hppBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting player HP as total or missing", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, hppBox.left, hppBox.top, hppBox.right, hppBox.bottom,
               hppBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, hppBox.left, hppBox.top, hppBox.right, hppBox.bottom,
               hppBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, hppBox.text,
             hppBox.left + omni.miniwin.optionbar.padding, hppBox.top + omni.miniwin.optionbar.padding,
             hppBox.right - omni.miniwin.optionbar.padding, hppBox.bottom - omni.miniwin.optionbar.padding,
             hppBox.textColor, false)             

  currentX = hppBox.right + omni.miniwin.font.table.option.width

  local qtBox   = {}
  qtBox.text    = "QT"
  qtBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, qtBox.text)
  qtBox.left    = currentX
  qtBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  qtBox.right   = qtBox.left + qtBox.textLen + (2 * omni.miniwin.optionbar.padding)
  qtBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("qt") then
    qtBox.textColor = textColorSelected
    qtBox.backColor = backColorSelected
  else
    qtBox.textColor = textColorDeselected
    qtBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.qtBox.mouseOver then
    qtBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.qtBox,
                   qtBox.left, qtBox.top, qtBox.right, qtBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle displaying player quest timer", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, qtBox.left, qtBox.top, qtBox.right, qtBox.bottom,
               qtBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, qtBox.left, qtBox.top, qtBox.right, qtBox.bottom,
               qtBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, qtBox.text,
             qtBox.left + omni.miniwin.optionbar.padding, qtBox.top + omni.miniwin.optionbar.padding,
             qtBox.right - omni.miniwin.optionbar.padding, qtBox.bottom - omni.miniwin.optionbar.padding,
             qtBox.textColor, false)             

  currentX = qtBox.right + omni.miniwin.font.table.option.width

  local tnlBox   = {}
  tnlBox.text    = "TNL"
  tnlBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, tnlBox.text)
  tnlBox.left    = currentX
  tnlBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  tnlBox.right   = tnlBox.left + tnlBox.textLen + (2 * omni.miniwin.optionbar.padding)
  tnlBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("tnl") then
    tnlBox.textColor = textColorSelected
    tnlBox.backColor = backColorSelected
  else
    tnlBox.textColor = textColorDeselected
    tnlBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.tnlBox.mouseOver then
    tnlBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.tnlBox,
                   tnlBox.left, tnlBox.top, tnlBox.right, tnlBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle displaying player to-next-level XP", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, tnlBox.left, tnlBox.top, tnlBox.right, tnlBox.bottom,
               tnlBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, tnlBox.left, tnlBox.top, tnlBox.right, tnlBox.bottom,
               tnlBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, tnlBox.text,
             tnlBox.left + omni.miniwin.optionbar.padding, tnlBox.top + omni.miniwin.optionbar.padding,
             tnlBox.right - omni.miniwin.optionbar.padding, tnlBox.bottom - omni.miniwin.optionbar.padding,
             tnlBox.textColor, false)             

  currentX = tnlBox.right + omni.miniwin.font.table.option.width

  local mvBox   = {}
  mvBox.text    = "MV"
  mvBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, mvBox.text)
  mvBox.left    = currentX
  mvBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  mvBox.right   = mvBox.left + mvBox.textLen + (2 * omni.miniwin.optionbar.padding)
  mvBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("mv") then
    mvBox.textColor = textColorSelected
    mvBox.backColor = backColorSelected
  else
    mvBox.textColor = textColorDeselected
    mvBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.mvBox.mouseOver then
    mvBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.mvBox,
                   mvBox.left, mvBox.top, mvBox.right, mvBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle displaying player moves", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, mvBox.left, mvBox.top, mvBox.right, mvBox.bottom,
               mvBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, mvBox.left, mvBox.top, mvBox.right, mvBox.bottom,
               mvBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, mvBox.text,
             mvBox.left + omni.miniwin.optionbar.padding, mvBox.top + omni.miniwin.optionbar.padding,
             mvBox.right - omni.miniwin.optionbar.padding, mvBox.bottom - omni.miniwin.optionbar.padding,
             mvBox.textColor, false)             

  currentX = mvBox.right + omni.miniwin.font.table.option.width

  local mnBox   = {}
  mnBox.text    = "MN"
  mnBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, mnBox.text)
  mnBox.left    = currentX
  mnBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  mnBox.right   = mnBox.left + mnBox.textLen + (2 * omni.miniwin.optionbar.padding)
  mnBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("mn") then
    mnBox.textColor = textColorSelected
    mnBox.backColor = backColorSelected
  else
    mnBox.textColor = textColorDeselected
    mnBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.mnBox.mouseOver then
    mnBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.mnBox,
                   mnBox.left, mnBox.top, mnBox.right, mnBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle displaying player mana", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, mnBox.left, mnBox.top, mnBox.right, mnBox.bottom,
               mnBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, mnBox.left, mnBox.top, mnBox.right, mnBox.bottom,
               mnBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, mnBox.text,
             mnBox.left + omni.miniwin.optionbar.padding, mnBox.top + omni.miniwin.optionbar.padding,
             mnBox.right - omni.miniwin.optionbar.padding, mnBox.bottom - omni.miniwin.optionbar.padding,
             mnBox.textColor, false)             

  currentX = mnBox.right + omni.miniwin.font.table.option.width

  local tgtBox   = {}
  tgtBox.text    = "TGT"
  tgtBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, tgtBox.text)
  tgtBox.left    = currentX
  tgtBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  tgtBox.right   = tgtBox.left + tgtBox.textLen + (2 * omni.miniwin.optionbar.padding)
  tgtBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("tgt") then
    tgtBox.textColor = textColorSelected
    tgtBox.backColor = backColorSelected
  else
    tgtBox.textColor = textColorDeselected
    tgtBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.tgtBox.mouseOver then
    tgtBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.tgtBox,
                   tgtBox.left, tgtBox.top, tgtBox.right, tgtBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle displaying mob targets", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, tgtBox.left, tgtBox.top, tgtBox.right, tgtBox.bottom,
               tgtBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, tgtBox.left, tgtBox.top, tgtBox.right, tgtBox.bottom,
               tgtBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, tgtBox.text,
             tgtBox.left + omni.miniwin.optionbar.padding, tgtBox.top + omni.miniwin.optionbar.padding,
             tgtBox.right - omni.miniwin.optionbar.padding, tgtBox.bottom - omni.miniwin.optionbar.padding,
             tgtBox.textColor, false)             

  currentX = tgtBox.right + omni.miniwin.font.table.option.width

  local dmgBox   = {}
  dmgBox.text    = "DMG"
  dmgBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.option.id, dmgBox.text)
  dmgBox.left    = currentX
  dmgBox.top     = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.padding
  dmgBox.right   = dmgBox.left + dmgBox.textLen + (2 * omni.miniwin.optionbar.padding)
  dmgBox.bottom  = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height - omni.miniwin.optionbar.padding

  if omni.report.isEnabled("dmg") then
    dmgBox.textColor = textColorSelected
    dmgBox.backColor = backColorSelected
  else
    dmgBox.textColor = textColorDeselected
    dmgBox.backColor = backColorDeselected
  end -- if

  if omni.miniwin.dmgBox.mouseOver then
    dmgBox.textColor = textColorHover 
  end -- if

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.dmgBox,
                   dmgBox.left, dmgBox.top, dmgBox.right, dmgBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle displaying player damage dealt/received", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, dmgBox.left, dmgBox.top, dmgBox.right, dmgBox.bottom,
               dmgBox.backColor, 0)
  WindowRectOp(omni.miniwin.win, 4, dmgBox.left, dmgBox.top, dmgBox.right, dmgBox.bottom,
               dmgBox.backColor, backColorSelected)
  WindowText(omni.miniwin.win, omni.miniwin.font.table.option.id, dmgBox.text,
             dmgBox.left + omni.miniwin.optionbar.padding, dmgBox.top + omni.miniwin.optionbar.padding,
             dmgBox.right - omni.miniwin.optionbar.padding, dmgBox.bottom - omni.miniwin.optionbar.padding,
             dmgBox.textColor, false)             

  currentX = dmgBox.right + omni.miniwin.font.table.option.width

  omni.miniwin.optionbar.minWidth = currentX +
                                    omni.miniwin.font.table.option.width +
                                    omni.miniwin.optionbar.padding

end -- omni.miniwin.optionbar.draw


function omni.miniwin.summarybar.calc()
  omni.miniwin.summarybar.paddingY = Theme.TITLE_PADDING + 2
  omni.miniwin.summarybar.paddingX = omni.miniwin.font.table.report.width * 2 / 3
  omni.miniwin.summarybar.height   = omni.miniwin.font.table.report.height + (4 * omni.miniwin.summarybar.paddingY)
  omni.miniwin.summarybar.width    = omni.miniwin.dims.width - Theme.TITLE_PADDING
  omni.miniwin.summarybar.minWidth = omni.miniwin.summarybar.width
end -- omni.miniwin.summarybar.calc


function omni.miniwin.summarybar.draw()

  omni.miniwin.summarybar.calc()

  if (not omni.miniwin.summarybar.isEnabled()) then
    omni.miniwin.summarybar.width    = 0
    omni.miniwin.summarybar.height   = 0
    omni.miniwin.summarybar.minWidth = 0
    return
  end -- if

  local backColor      = 0x101010
  local textColorHover = 0xFFFFFF
  local selectColor1   = 0xB0B0B0
  local selectColor2   = 0xFFFFFF
  local colorNonGroup  = 0xFF80C0
  local colorGroup     = 0xFFFF80

  local top = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height
  local bot = top + omni.miniwin.summarybar.height
  local currentX = Theme.TITLE_PADDING

  WindowGradient(omni.miniwin.win, currentX, top, omni.miniwin.summarybar.width,
                 top + omni.miniwin.summarybar.height / 2, 0x002000, 0x004000, 2)

  WindowGradient(omni.miniwin.win, currentX, top + omni.miniwin.summarybar.height / 2,
                 omni.miniwin.summarybar.width, bot, 0x004000, 0x002000, 2)

  WindowRectOp(omni.miniwin.win, 1, currentX, top, omni.miniwin.summarybar.width, bot, 0x000000, 0)

  currentX = omni.miniwin.summarybar.paddingX

  local groupText   = {}
  groupText.text    = "Grp"
  groupText.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, groupText.text)
  groupText.left    = currentX
  groupText.top     = top + omni.miniwin.summarybar.paddingY
  groupText.right   = groupText.left + groupText.textLen + (2 * omni.miniwin.summarybar.paddingX)
  groupText.bottom  = bot - omni.miniwin.summarybar.paddingY

  groupText.textColor = 0xFFFFFF

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, groupText.text,
             groupText.left + omni.miniwin.summarybar.paddingX,
             groupText.top + omni.miniwin.summarybar.paddingY,
             groupText.right - omni.miniwin.summarybar.paddingX,
             groupText.bottom - omni.miniwin.summarybar.paddingY,
             groupText.textColor, false)

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.groupText,
                   groupText.left, groupText.top, groupText.right, groupText.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Select how often to scan your current room", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  currentX = groupText.right + omni.miniwin.summarybar.paddingX


  local groupRoom   = {}
  groupRoom.text    = "Rm " .. string.format("%2d", (omni.report.roomGroup or 0))
  groupRoom.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, groupRoom.text)
  groupRoom.left    = currentX
  groupRoom.top     = top + omni.miniwin.summarybar.paddingY
  groupRoom.right   = groupRoom.left + groupRoom.textLen + (2 * omni.miniwin.summarybar.paddingX)
  groupRoom.bottom  = bot - omni.miniwin.summarybar.paddingY

  if omni.miniwin.groupRoom.mouseOver then
    groupRoom.textColor = textColorHover 
  else
    groupRoom.textColor = colorGroup
  end -- if
  groupRoom.backColor = backColor

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.groupRoom,
                   groupRoom.left, groupRoom.top, groupRoom.right, groupRoom.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting for group members in your room", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2,
               groupRoom.left, groupRoom.top, groupRoom.right, groupRoom.bottom,
               groupRoom.backColor, 0)

  if omni.report.isEnabled("grp") then
    WindowRectOp(omni.miniwin.win, 4, groupRoom.left, groupRoom.top, groupRoom.right,
                 groupRoom.bottom, selectColor1, selectColor2)
  end -- if

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, groupRoom.text,
             groupRoom.left + omni.miniwin.summarybar.paddingX,
             groupRoom.top + omni.miniwin.summarybar.paddingY,
             groupRoom.right - omni.miniwin.summarybar.paddingX,
             groupRoom.bottom - omni.miniwin.summarybar.paddingY,
             groupRoom.textColor, false)

  currentX = groupRoom.right + omni.miniwin.summarybar.paddingX


  local groupArea   = {}
  groupArea.text    = "Ar " .. string.format("%2d", (omni.report.areaGroup or 0))

  groupArea.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, groupArea.text)
  groupArea.left    = currentX
  groupArea.top     = top + omni.miniwin.summarybar.paddingY
  groupArea.right   = groupArea.left + groupArea.textLen + (2 * omni.miniwin.summarybar.paddingX)
  groupArea.bottom  = bot - omni.miniwin.summarybar.paddingY

  if omni.miniwin.groupArea.mouseOver then
    groupArea.textColor = textColorHover 
  else
    groupArea.textColor = colorGroup
  end -- if
  groupArea.backColor = backColor

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.groupArea,
                   groupArea.left, groupArea.top, groupArea.right, groupArea.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting for group members in your area", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2,
               groupArea.left, groupArea.top, groupArea.right, groupArea.bottom,
               groupArea.backColor, 0)

  if omni.report.isEnabled("grp-area") then
    WindowRectOp(omni.miniwin.win, 4, groupArea.left, groupArea.top, groupArea.right,
                 groupArea.bottom, selectColor1, selectColor2)
  end -- if

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, groupArea.text,
             groupArea.left + omni.miniwin.summarybar.paddingX,
             groupArea.top + omni.miniwin.summarybar.paddingY,
             groupArea.right - omni.miniwin.summarybar.paddingX,
             groupArea.bottom - omni.miniwin.summarybar.paddingY,
             groupArea.textColor, false)

  currentX = groupArea.right + omni.miniwin.summarybar.paddingX


  local nareaBox   = {}
  nareaBox.text    = "~Ar "
  if (omni.miniwin.graph.chars ~= nil) then
    nareaBox.text = nareaBox.text .. string.format("%2d", #omni.miniwin.graph.chars.groupNAreaArray or 0)
  else
    nareaBox.text = nareaBox.text .. "0"
  end -- if
  nareaBox.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, nareaBox.text)
  nareaBox.left    = currentX
  nareaBox.top     = top + omni.miniwin.summarybar.paddingY
  nareaBox.right   = nareaBox.left + nareaBox.textLen + (2 * omni.miniwin.summarybar.paddingX)
  nareaBox.bottom  = bot - omni.miniwin.summarybar.paddingY

  if omni.miniwin.nareaBox.mouseOver then
    nareaBox.textColor = textColorHover 
  else
    nareaBox.textColor = colorGroup
  end -- if
  nareaBox.backColor = backColor

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.nareaBox,
                   nareaBox.left, nareaBox.top, nareaBox.right, nareaBox.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle displaying players in your group that are not in your area", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2,
               nareaBox.left, nareaBox.top, nareaBox.right, nareaBox.bottom,
               nareaBox.backColor, 0)

  if omni.report.isEnabled("narea") then
    WindowRectOp(omni.miniwin.win, 4, nareaBox.left, nareaBox.top, nareaBox.right,
                 nareaBox.bottom, selectColor1, selectColor2)
  end -- if

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, nareaBox.text,
             nareaBox.left + omni.miniwin.summarybar.paddingX,
             nareaBox.top + omni.miniwin.summarybar.paddingY,
             nareaBox.right - omni.miniwin.summarybar.paddingX,
             nareaBox.bottom - omni.miniwin.summarybar.paddingY,
             nareaBox.textColor, false)

  currentX = nareaBox.right + omni.miniwin.summarybar.paddingX


  local ngroupText   = {}
  ngroupText.text    = "~Grp"
  ngroupText.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, ngroupText.text)
  ngroupText.left    = currentX
  ngroupText.top     = top + omni.miniwin.summarybar.paddingY
  ngroupText.right   = ngroupText.left + ngroupText.textLen + (2 * omni.miniwin.summarybar.paddingX)
  ngroupText.bottom  = bot - omni.miniwin.summarybar.paddingY

  ngroupText.textColor = 0xFFFFFF

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, ngroupText.text,
             ngroupText.left + omni.miniwin.summarybar.paddingX,
             ngroupText.top + omni.miniwin.summarybar.paddingY,
             ngroupText.right - omni.miniwin.summarybar.paddingX,
             ngroupText.bottom - omni.miniwin.summarybar.paddingY,
             ngroupText.textColor, false)

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.ngroupText,
                   ngroupText.left, ngroupText.top, ngroupText.right, ngroupText.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Select how often to scan your current area", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  currentX = ngroupText.right + omni.miniwin.summarybar.paddingX


  local ngroupRoom   = {}
  ngroupRoom.text    = "Rm " .. string.format("%2d", (omni.report.roomNGroup or 0))

  ngroupRoom.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, ngroupRoom.text)
  ngroupRoom.left    = currentX
  ngroupRoom.top     = top + omni.miniwin.summarybar.paddingY
  ngroupRoom.right   = ngroupRoom.left + ngroupRoom.textLen + (2 * omni.miniwin.summarybar.paddingX)
  ngroupRoom.bottom  = bot - omni.miniwin.summarybar.paddingY

  if omni.miniwin.ngroupRoom.mouseOver then
    ngroupRoom.textColor = textColorHover 
  else
    ngroupRoom.textColor = colorNonGroup
  end -- if
  ngroupRoom.backColor = backColor

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.ngroupRoom,
                   ngroupRoom.left, ngroupRoom.top, ngroupRoom.right, ngroupRoom.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting for non-group players in your room", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2,
               ngroupRoom.left, ngroupRoom.top, ngroupRoom.right, ngroupRoom.bottom,
               ngroupRoom.backColor, 0)

  if omni.report.isEnabled("~grp") then
    WindowRectOp(omni.miniwin.win, 4, ngroupRoom.left, ngroupRoom.top, ngroupRoom.right,
                 ngroupRoom.bottom, selectColor1, selectColor2)
  end -- if

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, ngroupRoom.text,
             ngroupRoom.left + omni.miniwin.summarybar.paddingX,
             ngroupRoom.top + omni.miniwin.summarybar.paddingY,
             ngroupRoom.right - omni.miniwin.summarybar.paddingX,
             ngroupRoom.bottom - omni.miniwin.summarybar.paddingY,
             ngroupRoom.textColor, false)

  currentX = ngroupRoom.right + omni.miniwin.summarybar.paddingX


  local ngroupArea   = {}
  ngroupArea.text    = "Ar " .. string.format("%2d", (omni.report.areaNGroup or 0))
  ngroupArea.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, ngroupArea.text)
  ngroupArea.left    = currentX
  ngroupArea.top     = top + omni.miniwin.summarybar.paddingY
  ngroupArea.right   = ngroupArea.left + ngroupArea.textLen + (2 * omni.miniwin.summarybar.paddingX)
  ngroupArea.bottom  = bot - omni.miniwin.summarybar.paddingY

  if omni.miniwin.ngroupArea.mouseOver then
    ngroupArea.textColor = textColorHover 
  else
    ngroupArea.textColor = colorNonGroup
  end -- if
  ngroupArea.backColor = backColor

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.ngroupArea,
                   ngroupArea.left, ngroupArea.top, ngroupArea.right, ngroupArea.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting for non-group players in your area", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2,
               ngroupArea.left, ngroupArea.top, ngroupArea.right, ngroupArea.bottom,
               ngroupArea.backColor, 0)

  if omni.report.isEnabled("~grp-area") then
    WindowRectOp(omni.miniwin.win, 4, ngroupArea.left, ngroupArea.top, ngroupArea.right,
                 ngroupArea.bottom, selectColor1, selectColor2)
  end -- if

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, ngroupArea.text,
             ngroupArea.left + omni.miniwin.summarybar.paddingX,
             ngroupArea.top + omni.miniwin.summarybar.paddingY,
             ngroupArea.right - omni.miniwin.summarybar.paddingX,
             ngroupArea.bottom - omni.miniwin.summarybar.paddingY,
             ngroupArea.textColor, false)

  currentX = ngroupArea.right + omni.miniwin.summarybar.paddingX


  local mobRoom   = {}
  mobRoom.text    = "Mob " .. string.format("%2d", (omni.report.roomMobs or 0))
  mobRoom.textLen = WindowTextWidth(omni.miniwin.win, omni.miniwin.font.table.report.id, mobRoom.text)
  mobRoom.left    = currentX
  mobRoom.top     = top + omni.miniwin.summarybar.paddingY
  mobRoom.right   = mobRoom.left + mobRoom.textLen + (2 * omni.miniwin.summarybar.paddingX)
  mobRoom.bottom  = bot - omni.miniwin.summarybar.paddingY

  if omni.miniwin.mobRoom.mouseOver then
    mobRoom.textColor = textColorHover 
  else
    mobRoom.textColor = omni.miniwin.graph.color.mob
  end -- if
  mobRoom.backColor = backColor

  WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.mobRoom,
                   mobRoom.left, mobRoom.top, mobRoom.right, mobRoom.bottom,
                   "omni.miniwin.mouseOver",
                   "omni.miniwin.mouseOverCancel",
                   "omni.miniwin.mouseDown",
                   "omni.miniwin.mouseDownCancel",
                   "omni.miniwin.mouseUp",
                   "Toggle reporting for mobs in your current room", -- TooltipText
                   miniwin.cursor_arrow,
                   0)   -- flags (currently none)

  WindowRectOp(omni.miniwin.win, 2, mobRoom.left, mobRoom.top, mobRoom.right, mobRoom.bottom,
               backColor, 0)

  if omni.report.isEnabled("mob") then
    WindowRectOp(omni.miniwin.win, 4, mobRoom.left, mobRoom.top, mobRoom.right, mobRoom.bottom,
                 selectColor1, selectColor2)
  end -- if

  WindowText(omni.miniwin.win, omni.miniwin.font.table.report.id, mobRoom.text,
             mobRoom.left + omni.miniwin.summarybar.paddingX, mobRoom.top + omni.miniwin.summarybar.paddingY,
             mobRoom.right - omni.miniwin.summarybar.paddingX, mobRoom.bottom - omni.miniwin.summarybar.paddingY,
             mobRoom.textColor, false)

  currentX = mobRoom.right

  omni.miniwin.summarybar.minWidth = currentX + (2 * omni.miniwin.summarybar.paddingX) + Theme.TITLE_PADDING

end -- omni.miniwin.summarybar.draw


function omni.miniwin.titlebar.draw()
  if omni.miniwin.titlebar.isEnabled() then
    local group = gmcp("group")
    local title = ""
    if (group ~= nil) then
      if (group.groupname == "") or (group.groupname == nil) then
        groupName = "Ungrouped"
      else
        groupName = string.sub(strip_colours(group.groupname), 1, 25)
      end -- if
      title = groupName
      title = title .. " | " .. (group.leader or "No leader")
      title = title .. " | " .. (group.status or "No status")
      title = title .. " | " .. (group.kills  or "No kills")
      title = title .. " | " .. (group.exp    or "No exp")
    end -- if

    omni.miniwin.titlebar.top   = 0
    omni.miniwin.titlebar.right = omni.miniwin.dims.width
    omni.miniwin.titlebar.left, omni.miniwin.titlebar.bottom = 
      Theme.DressWindow(omni.miniwin.win, omni.miniwin.font.table.title.id, title, nil)

  else
    omni.miniwin.titlebar.left   = 0
    omni.miniwin.titlebar.right  = 0
    omni.miniwin.titlebar.top    = 0
    omni.miniwin.titlebar.bottom = 1 -- leave a 1-pixel border even if we don't display the titlebar

    -- We still would like a border around the window even if the titlebar isn't present
    WindowRectOp(omni.miniwin.win, 1, 0, 0, omni.miniwin.dims.width, omni.miniwin.dims.height,
                 omni.miniwin.graph.color.borderTitle, 0)
  end -- if

end -- omni.miniwin.titlebar.draw


function omni.miniwin.draw()
  -- Throttle the insanity by limiting the redraw to once every 100ms
  AddTimer("omniMiniwinDrawBatchTimer", 0, 0, 0.1, "",
           timer_flag.Enabled + timer_flag.OneShot,
           "omni.miniwin.drawBatched")
end -- omni.miniwin.draw


function omni.miniwin.drawBatched()

  if (not omni.miniwin.isInitialized) then
    return
  end -- if

  -- Full window
  WindowResize(omni.miniwin.win, omni.miniwin.dims.width, omni.miniwin.dims.height, 0x000000)
  WindowRectOp(omni.miniwin.win, 2, 0, 0, omni.miniwin.dims.width, omni.miniwin.dims.height, 0x000000, 0)

  -- Titlebar
  omni.miniwin.titlebar.draw()

  -- Option bar
  omni.miniwin.optionbar.draw()

  -- Summary bar
  omni.miniwin.summarybar.draw()

  -- Main window
  if omni.miniwin.mode.isEnabled("basic") then
    WindowDeleteHotspot(omni.miniwin.win, omni.miniwin.hotspots.graph) -- this isn't present in "basic" mode

    omni.miniwin.report.calc()
    omni.miniwin.report.rect:setRect(omni.miniwin.report.left,
                                     omni.miniwin.report.top,
                                     omni.miniwin.report.right,
                                     omni.miniwin.report.bottom)
    omni.miniwin.report.rect:loadFont(omni.miniwin.font.table.report.name, omni.miniwin.font.table.report.size)
    omni.miniwin.report.rect:initArea()
    omni.miniwin.report.rect:draw()

    WindowScrollwheelHandler(omni.miniwin.win,
                             omni.miniwin.report.rect.area_hotspot,
                             "omni.miniwin.report.scrollwheel")

  else
    omni.miniwin.report.rect:unInit() -- Clear hotspots in the "basic" mode textRect

    -- Leave a 1-pixel border on each side
    local mainLeft   = 1
    local mainTop    = omni.miniwin.titlebar.bottom + omni.miniwin.optionbar.height +
                       omni.miniwin.summarybar.height + 1
    local mainRight  = omni.miniwin.dims.width - 2
    local mainBottom = omni.miniwin.dims.height - 2

    omni.miniwin.graph.categorize()
    omni.miniwin.graph.calc()

    local leftGradCol, rightGradCol = 0x302000, 0x330015
    local roomDetails = gmcp("room.info.details")
    if string.match(roomDetails, "pk") then
      leftGradCol  = 0x000066 
      rightGradCol = 0x000066 
    end -- if

    -- Add a pleasant gradient background
    WindowGradient(omni.miniwin.win, mainLeft, mainTop, omni.miniwin.graph.dims.splitX, mainBottom,
                   0x000000, leftGradCol, 1)
    WindowGradient(omni.miniwin.win, omni.miniwin.graph.dims.splitX, mainTop, mainRight, mainBottom,
                   rightGradCol, 0x000000, 1)

    omni.miniwin.graph.draw(mainLeft, mainTop, mainRight, mainBottom)

    WindowAddHotspot(omni.miniwin.win, omni.miniwin.hotspots.graph,
                     mainLeft, mainTop, mainRight - Theme.RESIZER_SIZE, mainBottom,
                     nil, -- "omni.miniwin.mouseOver",
                     nil, -- "omni.miniwin.mouseOverCancel",
                     nil, -- "omni.miniwin.mouseDown",
                     nil, -- "omni.miniwin.mouseDownCancel",
                     "omni.miniwin.mouseUp",
                     "", -- TooltipText
                     miniwin.cursor_arrow,
                     0)   -- flags (currently none)
    WindowScrollwheelHandler(omni.miniwin.win, omni.miniwin.hotspots.graph, "omni.miniwin.report.scrollwheel")

  end -- if

  -- Resizer at the bottom right of the main window
  Theme.AddResizeTag(omni.miniwin.win, 2, nil, nil, "omni.miniwin.mouseDown",
                     "omni.miniwin.resize.moveCallback", "omni.miniwin.resize.releaseCallback")

  CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
end -- omni.miniwin.drawBatched


omni.miniwin.mode = {}
omni.miniwin.mode.table = { basic   = "  Basic  ",
                            graphic = "Graphical" }
function omni.miniwin.mode.set(mode)

  if (mode == nil) or (omni.miniwin.mode.table[mode] == nil) then
    omni.error("omni.miniwin.mode.set: invalid miniwin mode \"" .. (mode or "nil") .. "\"")
    return
  end -- if

  SetVariable("miniwinModeState", mode)

  omni.print("@WMini-window mode is \"@c" .. mode .. "@W\"")

  if omni.miniwin.isEnabled() then
    omni.miniwin.draw()
  end -- if

  -- Request a rescan if the mode changed
  omni.scan.timer.room.requested = true

end -- omni.miniwin.mode.set


function omni.miniwin.mode.get()
  local mode = GetVariable("miniwinModeState") or ""

  if (mode == "") then
    mode = "basic"
    omni.miniwin.mode.set(mode)
  end -- if

  return mode
end -- omni.miniwin.mode.get


function omni.miniwin.mode.isEnabled(mode)
  if (omni.miniwin.mode.get() == mode) then
    return true
  else
    return false
  end -- if
end -- omni.miniwin.mode.isEnabled


function omni.miniwin.titlebar.set(enable)

  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.miniwin.titlebar.set: invalid miniwin titlebar mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("miniwinTitlebarState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WMini-window titlebar is " .. msg)

end -- omni.miniwin.titlebar.set


function omni.miniwin.titlebar.get()
  local enable = GetVariable("miniwinTitlebarState") or ""

  if (enable == "") then
    enable = "on"
    omni.miniwin.titlebar.set(enable)
  end -- if

  return enable
end -- omni.miniwin.titlebar.get


function omni.miniwin.titlebar.isEnabled()
  if (omni.miniwin.titlebar.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.miniwin.titlebar.isEnabled

        
function omni.miniwin.optionbar.set(enable)

  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.miniwin.optionbar.set: invalid miniwin optionbar mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("miniwinOptionbarState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WMini-window optionbar is " .. msg)

end -- omni.miniwin.optionbar.set


function omni.miniwin.optionbar.get()
  local enable = GetVariable("miniwinOptionbarState") or ""

  if (enable == "") then
    enable = "on"
    omni.miniwin.optionbar.set(enable)
  end -- if

  return enable
end -- omni.miniwin.optionbar.get


function omni.miniwin.optionbar.isEnabled()
  if (omni.miniwin.optionbar.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.miniwin.optionbar.isEnabled


function omni.miniwin.summarybar.set(enable)

  if (enable ~= "on") and (enable ~= "off") then
    omni.error("omni.miniwin.summarybar.set: invalid miniwin summarybar mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("miniwinSummarybarState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  omni.print("@WMini-window summarybar is " .. msg)

end -- omni.miniwin.summarybar.set


function omni.miniwin.summarybar.get()
  local enable = GetVariable("miniwinSummarybarState") or ""

  if (enable == "") then
    enable = "on"
    omni.miniwin.summarybar.set(enable)
  end -- if

  return enable
end -- omni.miniwin.summarybar.get


function omni.miniwin.summarybar.isEnabled()
  if (omni.miniwin.summarybar.get() == "on") then
    return true
  else
    return false
  end -- if
end -- omni.miniwin.summarybar.isEnabled


omni.miniwin.graph                = {}

omni.miniwin.graph.group          = {}
omni.miniwin.graph.group.area     = {}
omni.miniwin.graph.group.narea    = {}

omni.miniwin.graph.ngroup         = {}
omni.miniwin.graph.ngroup.area    = {}
omni.miniwin.graph.ngroup.mob     = {}

omni.miniwin.graph.dims           = {}
omni.miniwin.graph.dims.pad       = {}
omni.miniwin.graph.dims.len       = {}

omni.miniwin.graph.color          = {}

omni.miniwin.graph.split          = {}


function omni.miniwin.graph.init()
  omni.miniwin.graph.dims.pad.x         = 8 -- this is overwritten once we know the font
  omni.miniwin.graph.dims.pad.y         = 2
  omni.miniwin.graph.dims.pad.yMed      = 4
  omni.miniwin.graph.dims.pad.yBig      = 10

  omni.miniwin.graph.dims.len.level     = 3
  omni.miniwin.graph.dims.len.hp        = 6
  omni.miniwin.graph.dims.len.name      = 5 -- (can expand if who/numAtk aren't fully populated)
  omni.miniwin.graph.dims.len.nameNA    = 8
  omni.miniwin.graph.dims.len.nameMob   = 12
  omni.miniwin.graph.dims.len.stats     = 4
  omni.miniwin.graph.dims.len.who       = 3
  omni.miniwin.graph.dims.len.clan      = 7
  omni.miniwin.graph.dims.len.damOut    = 5
  omni.miniwin.graph.dims.len.damIn     = 5
  omni.miniwin.graph.dims.len.healOut   = 5
  omni.miniwin.graph.dims.len.target    = 10 -- 16 in basic mode
  omni.miniwin.graph.dims.len.arrow     = 2
  omni.miniwin.graph.dims.len.numAtk    = 2

  omni.miniwin.graph.color.bg           = 0x000000
  omni.miniwin.graph.color.qtime        = 0xFFFFCC
  omni.miniwin.graph.color.tnl          = 0x99CCFF
  omni.miniwin.graph.color.moves        = 0x99FFFF
  omni.miniwin.graph.color.mana         = 0xFFB266
  omni.miniwin.graph.color.level        = 0xFFFFFF
  omni.miniwin.graph.color.flags        = 0x7F00FF
  omni.miniwin.graph.color.hp           = 0xFFFFFF
  omni.miniwin.graph.color.good         = 0x00FFFF
  omni.miniwin.graph.color.neutral      = 0xFFFFFF
  omni.miniwin.graph.color.evil         = 0x0000FF
  omni.miniwin.graph.color.divine       = 0xE0E000
  omni.miniwin.graph.color.pet          = 0xE0E000
  omni.miniwin.graph.color.highlight    = 0x3399FF
  omni.miniwin.graph.color.target       = 0x7FFF00
  omni.miniwin.graph.color.wantedOrHC   = 0x0000FF
  omni.miniwin.graph.color.mob          = 0xFF9933
  omni.miniwin.graph.color.group        = 0xFFFF80
  omni.miniwin.graph.color.ngroup       = 0xFF80C0
  omni.miniwin.graph.color.ngroupBg     = 0xCC0066
  omni.miniwin.graph.color.stats        = 0xFFFFFF
  omni.miniwin.graph.color.sanc         = 0xFFFFFF
  omni.miniwin.graph.color.border       = 0x00FF00
  omni.miniwin.graph.color.borderChar   = 0x999900
  omni.miniwin.graph.color.borderTitle  = 0xA0A0A0
  omni.miniwin.graph.color.damOut       = 0x00FF00
  omni.miniwin.graph.color.damIn        = 0x0000FF
  omni.miniwin.graph.color.healOut      = 0xFF8000
  omni.miniwin.graph.color.numAtk       = 0x0000FF
  omni.miniwin.graph.color.arrow        = 0x0000FF
  omni.miniwin.graph.color.hpHiBright   = 0x009900
  omni.miniwin.graph.color.hpHiDim      = 0x006600
  omni.miniwin.graph.color.hpMedBright  = 0x00CCCC
  omni.miniwin.graph.color.hpMedDim     = 0x004040
  omni.miniwin.graph.color.hpLowBright  = 0x0000CC
  omni.miniwin.graph.color.hpLowDim     = 0x000066
  omni.miniwin.graph.color.gradientDark = 0x202020
  omni.miniwin.graph.color.bgDark       = 0x606060
  omni.miniwin.graph.color.bgPlayer     = 0x505000
  omni.miniwin.graph.color.bgMob        = 0x804000
  omni.miniwin.graph.color.bgWounded    = 0x000044

end -- omni.miniwin.graph.init


function omni.miniwin.graph.fini()
  -- placeholder for now
end -- omni.miniwin.graph.fini()


function omni.miniwin.graph.reset()
  omni.miniwin.graph.fini()
  omni.miniwin.graph.init()
end -- omni.miniwin.graph.reset


function omni.miniwin.graph.draw(left, top, right, bottom)
  local padX = omni.miniwin.graph.dims.pad.x
  local splitX = omni.miniwin.graph.dims.splitX

  -- Group
  omni.miniwin.graph.group.draw(left + padX, top, splitX - padX)

  -- Not in group (both players and mobs)
  omni.miniwin.graph.ngroup.draw(splitX + padX, top, 
                                 omni.miniwin.dims.width - splitX - 1 - (2 *padX))

end -- omni.miniwin.graph.draw


function omni.miniwin.graph.calc()
  omni.miniwin.graph.dims.pad.x    = math.floor(omni.miniwin.font.table.graph.width  * 3 / 4)
  omni.miniwin.graph.dims.pad.yMed = math.floor(omni.miniwin.font.table.graph.height * 1 / 2)
  omni.miniwin.graph.dims.pad.yBig = omni.miniwin.font.table.graph.height

  omni.miniwin.graph.group.area.calc()
  omni.miniwin.graph.group.narea.calc()
  omni.miniwin.graph.ngroup.area.calc()
  omni.miniwin.graph.ngroup.mob.calc()

  -- Check if the user already saved a split and use that if so.
  omni.miniwin.graph.dims.splitX = omni.miniwin.graph.split.get()

  -- If we haven't defined a split yet, split the window right down the middle
  if (omni.miniwin.graph.dims.splitX == nil) then
    omni.miniwin.graph.dims.splitX = math.floor((omni.miniwin.dims.width - 2 * omni.miniwin.graph.dims.pad.x) / 2)
    omni.miniwin.graph.split.set(omni.miniwin.graph.dims.splitX)
  end -- if

  -- Find the widest entries on both the left and right sides (including the pad)
  local grWidth   = omni.miniwin.graph.group.area.width
  local gaWidth   = omni.miniwin.graph.group.area.width
  local gnaWidth  = omni.miniwin.graph.group.narea.width
  local ngrWidth  = omni.miniwin.graph.group.area.width
  local ngaWidth  = omni.miniwin.graph.group.area.width
  local mobWidth  = omni.miniwin.graph.ngroup.mob.width
  local leftMaxEntryWidth  = math.max(grWidth, gaWidth, gnaWidth)   + omni.miniwin.graph.dims.pad.x
  local rightMaxEntryWidth = math.max(ngrWidth, ngaWidth, mobWidth) + omni.miniwin.graph.dims.pad.x

  -- We pick the split between the left and right sides by using a multiple of the widest left entry
  -- width.  We start by assuming that there isn't a right side and get the max number of columns.
  -- Then we back off of that based on whether or not the right side is enabled.  If it is enabled,
  -- then we leave room for at least one of the largest right-side entries.
  local colMax = math.floor((omni.miniwin.dims.width - (2 * omni.miniwin.graph.dims.pad.x)) / leftMaxEntryWidth)
  if omni.report.isEnabled("~grp")      or
     omni.report.isEnabled("~grp-area") or
     omni.report.isEnabled("mob")       then
    colMax = colMax - math.ceil(rightMaxEntryWidth / leftMaxEntryWidth)
  end -- if

  -- Snap the split to the nearest valid boundary
  local col = math.floor(omni.miniwin.graph.dims.splitX / leftMaxEntryWidth)
  if (col > colMax) then
    col = colMax
  end -- if
  if (col < 1) then
    col = 1
  end -- if

  omni.miniwin.graph.dims.splitX = (col * leftMaxEntryWidth) + (3 * omni.miniwin.graph.dims.pad.x)
  omni.miniwin.graph.split.set(omni.miniwin.graph.dims.splitX)

end -- omni.miniwin.graph.calc


function omni.miniwin.graph.split.set(value)
  if (value ~= nil) then
    local numVal = tonumber(value)
    if (numVal ~= nil) then
      SetVariable("omniMiniwinGraphSplitX", value)
    end -- if
  end -- if
end -- omni.miniwin.graph.split.set


function omni.miniwin.graph.split.get(value)
  return GetVariable("omniMiniwinGraphSplitX")
end -- omni.miniwin.graph.split.get


function omni.miniwin.graph.categorize()

  -- Populate 6 tables based on if the entry is:
  --   Grouped player:     in-room, in-area, not-in-area
  --   Non-grouped player: in-room, in-area
  --   Mob:                in-room
  local groupRoomArray  = {}
  local groupAreaArray  = {}
  local groupNAreaArray = {}
  local ngroupRoomArray = {}
  local ngroupAreaArray = {}
  local mobRoomArray    = {}

  -- This is convenient because direct lookups allow us avoid extra linear searches
  local groupGmcpTable  = {}

  -- First, handle everything we've scanned in the room: groupies, non-groupies, mobs
  for i, entry in ipairs(omni.scan.table) do
    if entry.isPlayer then
      if (entry.stats == nil) then
        entry.stats = 0
        if (omni.scan.swho.area.table[entry.nameKey] ~= nil) then
          entry.stats = omni.scan.swho.area.table[entry.nameKey].stats
        end -- if
      end -- if

      local qt = gmcp("comm.quest.wait")
      if (qt == "") or (qt == nil) then
        qt = "0"
      end -- if

      local myChar = gmcp("char")
      if (myChar == nil) or (myChar.vitals == nil) or (myChar.status == nil) or (myChar.maxstats == nil) then
        -- It's possible that myChar is not populated at startup (before gmcp gets rolling)
        myChar = { vitals = {}, maxstats = {}, status = {} }
      end -- if

      local gmcpStub = { mn    = myChar.vitals.mana or 0,
                         mmn   = myChar.maxstats.maxmana or 0,
                         here  = "1",
                         qt    = qt,
                         lvl   = myChar.status.level or 0,
                         hp    = myChar.vitals.hp or 0,
                         align = myChar.status.align or 0,
                         mmv   = myChar.maxstats.maxmoves or 0,
                         mv    = myChar.vitals.moves or 0,
                         tnl   = myChar.status.tnl or 0,
                         mhp   = myChar.maxstats.maxhp or 0
                       }

      groupGmcpTable[entry.nameKey] = gmcpStub  -- placeholder that we can fill in later

      if entry.inGroup then
        table.insert(groupRoomArray, entry)
      elseif (entry.nameKey == gmcp("char.base.name")) then
        -- We always consider you to be part of your own group even if it's not an official group
        table.insert(groupRoomArray, entry)
      else
        table.insert(ngroupRoomArray, entry)
      end -- if
    else
      table.insert(mobRoomArray, entry)
    end -- if
  end -- for

  -- Search gmcp group data to find groupies that may not have been scanned yet because they aren't in your room
  -- or they just entered your room and haven't been seen yet
  if (omni.gmcp.group ~= nil) and (omni.gmcp.group.members ~= nil) then
    for i, entry in ipairs(omni.gmcp.group.members) do

      if (entry.stats == nil) then
        entry.stats = 0
        if (omni.scan.swho.area.table[entry.name] ~= nil) then
          entry.stats = omni.scan.swho.area.table[entry.name].stats
        end -- if
      end -- if

      if (groupGmcpTable[entry.name] == nil) then
        local stubEntry = { nameKey = entry.name, numAttackers = 0, target = "",
                            sanc = false, level = tonumber(entry.info.lvl or 0) }

        if (entry.info.here == "1") then

          -- This is a groupmate in your room that hasn't been detected by an omni scan yet.  Add it!
          local scanEntry = { nameKey=entry.name,
                              nameShort=entry.name,
                              nameLong=entry.name,
                              dotName=entry.name,
                              inGroup=true,
                              charType="player",
                              isDivine=false,
                              isPlayer=true,
                              sanc=false,
                              align="nil",
                              target="",
                              area="" }
          table.insert(groupRoomArray, scanEntry)

        else -- This is a groupmate that isn't in your room.  Check if they are in your area next.          

          if (omni.scan.swho.area.table[entry.name] ~= nil) then
            -- This is a groupie who is in the area.
            table.insert(groupAreaArray, stubEntry)
          else
            -- This is a groupie who is not in the area
            table.insert(groupNAreaArray, stubEntry)
          end -- if

        end -- if
      end -- if

      groupGmcpTable[entry.name] = omni.copy(entry.info) -- make a copy in case they leave the group

    end -- for
  end -- if

  -- Search for non-grouped players in your area that we haven't already found in a room scan
  if (omni.scan.swho.area.table ~= nil) then

    for player, areaEntry in pairs(omni.scan.swho.area.table) do
      -- This really has nothing to do with GMCP.  However, checking if a gmcp table entry exists for the
      -- player is a convenient kludge because we have stub gmcp entries for all non-grouped players in
      -- the room.  If we haven't seen this player already that means they aren't in our room so they must
      -- be just in the area.
      if (groupGmcpTable[player] == nil) then
        table.insert(ngroupAreaArray, areaEntry)
      end -- if
    end -- for

  end -- if

  -- Sort groupNAreaArray by level and all other tables by the player's stats
  table.sort(groupNAreaArray, function (e1, e2) return e1.nameKey < e2.nameKey end)
  omni.report.sortByStats(ngroupRoomArray)
  omni.report.sortByStats(ngroupAreaArray)
  omni.report.sortByStats(groupRoomArray)
  omni.report.sortByStats(groupAreaArray)

  -- Make sure you are the first entry in the room (the rest can be sorted normally)
  for i, entry in ipairs(groupRoomArray) do
    if (entry.nameKey == gmcp("char.base.name")) then
      table.insert(groupRoomArray, 1, table.remove(groupRoomArray, i))
      break
    end -- if
  end -- for

  omni.miniwin.graph.chars = { groupRoomArray  = groupRoomArray,
                               groupAreaArray  = groupAreaArray,
                               groupNAreaArray = groupNAreaArray,
                               ngroupRoomArray = ngroupRoomArray,
                               ngroupAreaArray = ngroupAreaArray,
                               mobRoomArray    = mobRoomArray,
                               groupGmcpTable  = groupGmcpTable }

end -- omni.miniwin.graph.categorize


function omni.miniwin.graph.getAlignColor(align)
  if (align == nil) then
    return omni.miniwin.graph.color.neutral
  elseif (align < -874) then
    return omni.miniwin.graph.color.evil
  elseif (align < 875) then
    return omni.miniwin.graph.color.neutral
  else
    return omni.miniwin.graph.color.good
  end -- if
end -- omni.miniwin.graph.getAlignColor


function omni.miniwin.graph.group.draw(startX, startY, width)
  local dims     = omni.miniwin.graph.dims
  local currentX = startX + dims.pad.x
  local currentY = startY + dims.pad.yMed

  -- In Room
  if omni.report.isEnabled("grp") then
    local numInRow = math.floor(width / (omni.miniwin.graph.group.area.width + dims.pad.x))
    for i, entry in ipairs(omni.miniwin.graph.chars.groupRoomArray) do
      if (((i - 1) % numInRow) == 0) or (numInRow == 0) then
        -- Move to the beginning of a row
        currentX = startX + dims.pad.x
      else
        -- Move to the next spot in a row
        currentX = currentX + dims.pad.x + omni.miniwin.graph.group.area.width     
      end -- if
      if (((i - 1) % numInRow) == 0) and (i ~= 1) then
        -- Move to the beginning of the next row
        currentY = currentY + dims.pad.y + omni.miniwin.graph.group.area.height
      end -- if

      local info = omni.miniwin.graph.chars.groupGmcpTable[entry.nameKey]
      if (info ~= nil) then
        omni.miniwin.graph.group.drawEntry(currentX, currentY, entry, info, true, true)
      else
        omni.error("omni.miniwin.graph.group.draw: Failed to find gmcp info for player \"" ..
                   (entry.nameKey or "nil") .. "\"")
      end -- if
    end -- for
    currentY = currentY + omni.miniwin.graph.group.area.height + dims.pad.yBig
  end -- if

  -- In Area
  if omni.report.isEnabled("grp-area") then
    numInRow = math.floor(width / (omni.miniwin.graph.group.area.width + dims.pad.x))
    local numInArea = 0
    for i, entry in ipairs(omni.miniwin.graph.chars.groupAreaArray) do
      if (((i - 1) % numInRow) == 0) or (numInRow == 0) then
        -- Move to the beginning of a row
        currentX = startX + dims.pad.x
      else
        -- Move to the next spot in a row
        currentX = currentX + dims.pad.x + omni.miniwin.graph.group.area.width     
      end -- if
      if (((i - 1) % numInRow) == 0) and (i ~= 1) then
        -- Move to the beginning of the next row
        currentY = currentY + dims.pad.y + omni.miniwin.graph.group.area.height
      end -- if

      local info = omni.miniwin.graph.chars.groupGmcpTable[entry.nameKey]
      if (info ~= nil) then
        omni.miniwin.graph.group.drawEntry(currentX, currentY, entry, info, false, true)
      else
        omni.error("omni.miniwin.graph.group.draw: Failed to find gmcp info for player \"" ..
                   (entry.nameKey or "nil") .. "\"")
      end -- if

      numInArea = numInArea + 1
    end -- for
    if (numInArea > 0) then
      currentY = currentY + omni.miniwin.graph.group.area.height + dims.pad.yBig
    end -- if
  end -- if

  -- Not in Area
  if omni.report.isEnabled("narea") then
    numInRow = math.floor(width / (omni.miniwin.graph.group.narea.width + dims.pad.x))
    for i, entry in ipairs(omni.miniwin.graph.chars.groupNAreaArray) do

      if (((i - 1) % numInRow) == 0) or (numInRow == 0) then
        -- Move to the beginning of a row
        currentX = startX + dims.pad.x
      else
        -- Move to the next spot in a row
        currentX = currentX + dims.pad.x + omni.miniwin.graph.group.narea.width     
      end -- if
      if (((i - 1) % numInRow) == 0) and (i ~= 1) then
        -- Move to the beginning of the next row
        currentY = currentY + dims.pad.yMed + omni.miniwin.graph.group.narea.height
      end -- if

      local info = omni.miniwin.graph.chars.groupGmcpTable[entry.nameKey]
      if (info ~= nil) then
        omni.miniwin.graph.group.drawEntry(currentX, currentY, { nameKey = entry.nameKey }, info, false, false)
      else
        omni.error("omni.miniwin.graph.group.draw: Failed to find gmcp info for player \"" ..
                   (entry.nameKey or "nil") .. "\"")
      end -- if
    end -- for
    currentY = currentY + omni.miniwin.graph.group.narea.height + dims.pad.yMed
  end -- if

end -- omni.miniwin.graph.group.draw


function omni.miniwin.graph.group.drawEntry(x, y, entry, info, isBright, isArea)
  local color = omni.miniwin.graph.color

  if (isArea) then
    local stats = 0
    local flags = ""
    local clan  = ""

    local areaEntry = omni.scan.swho.area.table[entry.nameKey]
    if (areaEntry ~= nil) then
      stats = areaEntry.stats
      flags = strip_colours(areaEntry.flags)
      clan  = string.sub(areaEntry.clanShort, 1, omni.miniwin.graph.dims.len.clan)
    end -- if

    local targetColorStr, targetColorVal = omni.report.getColor(entry.target or "")

    omni.miniwin.graph.group.area.draw(x,
                                       y,
                                       tonumber(info.qt),
                                       tonumber(info.tnl),
                                       1000,  -- tnlMax -- FIXME: this isn't included in gmcp?!?
                                       tonumber(info.mv),
                                       tonumber(info.mmv),
                                       tonumber(info.mn),
                                       tonumber(info.mmn),
                                       tonumber(info.hp),
                                       tonumber(info.mhp),
                                       tonumber(info.lvl),
                                       entry.nameKey,
                                       stats,
                                       flags,
                                       clan,
                                       99999, -- damOut,   --FIXME TODO: track actual damage dealt/received
                                       99, -- damOutNum,
                                       99999, -- damIn,
                                       entry.numAttackers or 0, -- damInNum
                                       entry.target or "",
                                       targetColorVal,
                                       omni.miniwin.graph.getAlignColor(tonumber(info.align)),   -- char color
                                       entry.sanc,
                                       isBright)
  else
    omni.miniwin.graph.group.narea.draw(x,
                                        y,
                                        tonumber(info.lvl),
                                        entry.nameKey,
                                        omni.miniwin.graph.getAlignColor(tonumber(info.align)),   -- char color
                                        tonumber(info.hp),
                                        tonumber(info.mhp))
  end -- if
end -- omni.miniwin.graph.group.drawEntry


-- Returns height, width
function omni.miniwin.graph.group.area.calc()
  -- shortcuts to cut down on typing
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height

  local width, height = 0, 0

  local shortOptions = "qt tnl mv mn"
  for option in shortOptions:gmatch("%S+") do
    if omni.report.isEnabled(option) then
      width = width + charWidth
    end -- if
  end -- for

  -- Name box
  local rowMaxChars = dims.len.stats + 1 + dims.len.clan
  width = width + charWidth * rowMaxChars
  width = width + (2 * dims.pad.x) -- allow pads on left and right of the name box

  -- Damage box (also includes current target)
  if omni.report.isEnabled("dmg") then
    width = width + (2 * dims.pad.x) -- target
    width = width + (charWidth * dims.len.target)
  end -- if

  height = height + (3 * charHeight) -- 3 layers in the entry

  -- Add a 1-pixel border
  height = height + 2
  width  = width + 2

  omni.miniwin.graph.group.area.height = height
  omni.miniwin.graph.group.area.width  = width

  return height, width
end -- omni.miniwin.graph.group.area.calc


-- Returns retval, height, width
function omni.miniwin.graph.group.area.draw(startX, startY,
                                            qt, tnl, tnlMax, mv, mvMax, mn, mnMax, hp, hpMax,
                                            lvl, name, stats, flags, clan,
                                            damOut, damOutNum, damIn, damInNum, target, targetColor,
                                            charColor, isSanc, isBright)

  -- Get shortcuts to common values to save on typing
  local width      = omni.miniwin.graph.group.area.width
  local widthTrim  = width - 2 -- We leave a 1-pixel border on each side
  local height     = omni.miniwin.graph.group.area.height
  local heightTrim = height - 2 -- We leave a 1-pixel border on each side
  local color      = omni.miniwin.graph.color
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height
  local fontId     = omni.miniwin.font.table.graph.id

  local borderColor = color.group
  if isSanc then
    borderColor = color.sanc
  end -- if

  local curX, curY = startX + 1, startY + 1

  -- Fill the background for the entire entry
  WindowRectOp(omni.miniwin.win, 2, startX, startY, startX + width, startY + height, color.bg, 0)

  -- Quest timer
  if omni.report.isEnabled("qt") then
    local qtMax = 30
    if (qt > qtMax) then
      qt = qtMax
    end -- if
    local qtStartY = curY + (height * (qtMax - qt) / qtMax)
    local qtColor = color.qtime 
    if (qt == 0) then
      qtStartY = curY
      qtColor = 0x0000FF -- Flag it red if the qtimer is ready
    end -- if
    WindowGradient(omni.miniwin.win, curX, qtStartY, curX + charWidth/2, curY + heightTrim,
                   color.bg, qtColor, 1)
    WindowGradient(omni.miniwin.win, curX + charWidth/2, qtStartY, curX + charWidth,
                   curY + heightTrim, qtColor, color.bg, 1)
    curX = curX + charWidth
  end -- if

  -- TNL
  if omni.report.isEnabled("tnl") then
    local tnlCap = tnl
    if (tnl > tnlMax) then
      tnlCap = tnlMax
    end -- if
    local tnlStartY = curY + (height * (tnlMax - tnlCap) / tnlMax)
    WindowGradient(omni.miniwin.win, curX, tnlStartY, curX + charWidth/2, curY + heightTrim,
                   color.bg, color.tnl, 1)
    WindowGradient(omni.miniwin.win, curX + charWidth/2, tnlStartY, curX + charWidth,
                   curY + heightTrim, color.tnl, color.bg, 1)
    curX = curX + charWidth
  end -- if

  -- Moves
  if omni.report.isEnabled("mv") then
    local mvStartY = curY + (height * (mvMax - mv) / mvMax)
    WindowGradient(omni.miniwin.win, curX, mvStartY, curX + charWidth/2, curY + heightTrim,
                   color.bg, color.moves, 1)
    WindowGradient(omni.miniwin.win, curX + charWidth/2, mvStartY, curX + charWidth,
                   curY + heightTrim, color.moves, color.bg, 1)
    curX = curX + charWidth
  end -- if

  -- Mana
  if omni.report.isEnabled("mn") then
    local mnStartY = curY + (height * (mnMax - mn) / mnMax)
    WindowGradient(omni.miniwin.win, curX, mnStartY, curX + charWidth/2, curY + heightTrim,
                   color.bg, color.mana, 1)
    WindowGradient(omni.miniwin.win, curX + charWidth/2, mnStartY, curX + charWidth,
                   curY + heightTrim, color.mana, color.bg, 1)
    curX = curX + charWidth
  end -- if

  -- Name box
  local rowMaxChars = dims.len.stats + 1 + dims.len.clan
  local nameBoxWidth = (2 * dims.pad.x) + (charWidth * rowMaxChars)
  local hpPercent = hp / hpMax
  local hpWidth = nameBoxWidth * hpPercent
  local hpColorBase = color.gradientDark
  local hpColor = color.bgDark
  if (isBright) then
    if (hpPercent > 0.5) then
      if isBright then
        hpColor = color.hpHiBright
      else
        hpColor = color.hpHiDim
      end -- if
    elseif (hpPercent > 0.25) then
      if isBright then
        hpColor = color.hpMedBright
      else
        hpColor = color.hpMedDim
      end -- if
    else
      if isBright then
        hpColor = color.hpLowBright
      else
        hpColor = color.hpLowDim
      end -- if
    end -- if
  end -- if

  WindowGradient(omni.miniwin.win, curX, curY, curX + hpWidth, curY + (heightTrim / 2),
                 hpColor, hpColorBase, 2)
  WindowGradient(omni.miniwin.win, curX, curY + (heightTrim / 2), curX + hpWidth,
                 curY + heightTrim, hpColorBase, hpColor, 2)
  WindowRectOp(omni.miniwin.win, 1, curX, startY, curX + nameBoxWidth, startY + height, borderColor, 0)

  -- Name box contents
  -- 10 chars: level(3) hp(6)
  -- 12 chars: who(3) name(5) numAtk(2)  -- name can expand if who and numAtk aren't full
  -- 12 chars: stats(4) clan(7)
  local rowWidth    = charWidth * rowMaxChars
  local rowHeight   = charHeight
  local rowX        = curX + dims.pad.x
  local row1Y       = curY

  -- We can display HP either as the amount missing (negHP) or the total HP left
  local negHp = true
  if omni.report.isEnabled("hpp") then
    negHp = false
  end -- if

  local hpStr = ""
  if (negHp) then
    if (hpMax > hp) then
      hpStr = string.format("-%d", hpMax - hp)
    end -- if
  else
    hpStr = string.format("%d", hp)
  end -- if
  local row1Text = string.format("%-3d%s%s",
                                 lvl, string.rep(" ", rowMaxChars - dims.len.level - string.len(hpStr)), hpStr)
  WindowText(omni.miniwin.win, fontId, row1Text, rowX, row1Y, rowX + rowWidth, row1Y + rowHeight,
             color.level, false)
  
  local row2Y = row1Y + rowHeight
  local row2aText = strip_colours(flags)
  local row2cText = ""
  if (damInNum > 0) then
    row2cText = string.format("%d", damInNum)
  end -- if

  local row2aLen, row2cLen = string.len(row2aText), string.len(row2cText)
  local numBorderChars = row2aLen
  if (row2cLen > numBorderChars) then
    numBorderChars = row2cLen
  else
    row2cText = string.rep(" ", row2aLen - row2cLen) .. row2cText  -- pad the front with spaces if necessary
  end -- if

  local maxNameWidth = rowMaxChars - (2 * numBorderChars) - 2 -- subtract 2 for spaces on either side
  local nameTrunc = string.sub(name, 1, maxNameWidth) 

  -- Center the name
  local row2bText = " " .. string.rep(" ", (maxNameWidth - string.len(nameTrunc)) / 2) .. nameTrunc .. " "

  local row2aWidth = charWidth * numBorderChars
  local row2bWidth = charWidth * string.len(row2bText)
  local row2cWidth = charWidth * numBorderChars

  WindowText(omni.miniwin.win, fontId, row2aText, rowX, row2Y, rowX + row2aWidth,
             row2Y + rowHeight, color.flags, false)

  WindowText(omni.miniwin.win, fontId, row2bText, rowX + row2aWidth, row2Y, rowX + row2aWidth + row2bWidth,
             row2Y + rowHeight, charColor, false)

  WindowText(omni.miniwin.win, fontId, row2cText, rowX + rowWidth - row2cWidth, row2Y,
             rowX + rowWidth, row2Y + rowHeight, color.numAtk, false)

  local row3Y = row2Y + rowHeight
  local clanTrunc = omni.capitalize(string.sub(clan, 1, dims.len.clan))
  local statStr = "    "
  if (stats > 0) then
    statStr = string.format("%-4d", stats)
  end -- if
  local row3Text = string.format("%s%s%s",
                                 statStr,
                                 string.rep(" ", rowMaxChars - dims.len.stats - string.len(clanTrunc)),
                                 clanTrunc)
  WindowText(omni.miniwin.win, fontId, row3Text, rowX, row3Y,
             rowX + rowWidth, row3Y + rowHeight, color.stats, false)

  curX = curX + nameBoxWidth

  -- Target, damage out, damage in
  if omni.report.isEnabled("dmg") then
    local tgtWidth = (2 * dims.pad.x) + (charWidth * dims.len.target)
    local tgtHeight = charHeight
    local tgtX = curX + dims.pad.x
    local tgtY = curY
    local targetStr = string.sub(target or "", 1, dims.len.target)
    WindowText(omni.miniwin.win, fontId, targetStr, tgtX, tgtY, curX + tgtWidth, curY + tgtHeight,
               targetColor, false)
    WindowRectOp(omni.miniwin.win, 1, curX - 1, startY, startX + width, curY + (2 * charHeight),
                 borderColor, 0)
    curX = tgtX
    curY = curY + charHeight

    local doX, doY = curX, curY
    local damOutStr = ""
    if (damOut == 0) then
      if (damOutNum > 0) then
        -- Center the # of targets in the output
        damOutStr = string.format("%s%-2d", string.rep(" ", (dims.len.target - dims.len.numAtk) / 2), damOutNum)
      end -- if
    else
      damOutStr = string.format("%-5d : %-2d", damOut, damOutNum)
    end -- if
    WindowText(omni.miniwin.win, fontId, damOutStr, doX, doY, doX + tgtWidth, curY + tgtHeight,
               color.damOut, false)
    curY = curY + tgtHeight

    local damInStr = ""
    if (damIn == 0) then
      if (damInNum > 0) then
        -- Center the # of attackers in the output
        damInStr = string.format("%s%-2d", string.rep(" ", (dims.len.target - dims.len.numAtk) / 2), damInNum)
      end -- if
    else
      damInStr = string.format("%-5d : %-2d", damIn, damInNum)
    end -- if
    WindowText(omni.miniwin.win, fontId, damInStr, curX, curY, curX + tgtWidth, curY + tgtHeight,
               color.damIn, false)
    curY = curY + tgtHeight
  end -- if

  -- Border around entire entry
  WindowRectOp(omni.miniwin.win, 1, startX, startY, startX + width, startY + height, borderColor, 0)

end -- omni.miniwin.graph.group.area.draw


function omni.miniwin.graph.group.narea.calc()
  -- shortcuts to cut down on typing
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height

  local width, height = 0, 0

  local rowMaxChars = dims.len.level + 1 + dims.len.nameNA

  width = width + charWidth * rowMaxChars
  width = width + (2 * dims.pad.x) -- allow pads on left and right of the name box

  height = height + charHeight

  -- Add a 1-pixel border
  height = height + 2
  width  = width + 2

  omni.miniwin.graph.group.narea.height = height
  omni.miniwin.graph.group.narea.width  = width

  return height, width
end -- omni.miniwin.graph.group.narea.calc


function omni.miniwin.graph.group.narea.draw(startX, startY, level, name, nameColor, hp, hpMax)
  local width      = omni.miniwin.graph.group.narea.width
  local widthTrim  = width - 2 -- We leave a 1-pixel border on each side
  local height     = omni.miniwin.graph.group.narea.height
  local heightTrim = height - 2 -- We leave a 1-pixel border on each side
  local color      = omni.miniwin.graph.color
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height
  local fontId     = omni.miniwin.font.table.graph.id

  local hpPercent = hp / hpMax
  local hpWidth = widthTrim * hpPercent
  local hpColorBase = color.gradientDark
  local hpColor = color.bgPlayer

  local curX, curY = startX + 1, startY + 1

  WindowRectOp(omni.miniwin.win, 2, startX, startY, startX + width, startY + height, color.bg, 0)

  WindowGradient(omni.miniwin.win, curX, curY, curX + hpWidth, curY + heightTrim,
                 hpColor, hpColorBase, 2)

  curX = curX + dims.pad.x

  local rowText = string.format("%3d %s", level, string.sub(name, 1, dims.len.nameNA))
  WindowText(omni.miniwin.win, fontId, rowText, curX, curY, curX + charWidth * string.len(rowText),
             curY + charHeight, nameColor, false)

  -- Border around entire entry
  WindowRectOp(omni.miniwin.win, 1, startX, startY, startX + width, startY + height, color.group, 0)

end -- omni.miniwin.graph.group.narea.draw


function omni.miniwin.graph.ngroup.draw(startX, startY, width)
  local dims        = omni.miniwin.graph.dims
  local color       = omni.miniwin.graph.color
  local currentX    = startX + dims.pad.x
  local currentY    = startY + dims.pad.yMed
  local numInRow    = 0

  -- Non-grouped players in room
  if omni.report.isEnabled("~grp") then
    numInRoom = 0
    numInRow = math.floor(width / (omni.miniwin.graph.ngroup.area.width + dims.pad.x))
    for i, entry in ipairs(omni.miniwin.graph.chars.ngroupRoomArray) do
      if (((i - 1) % numInRow) == 0) or (numInRow == 0) then
        -- Move to the beginning of a row
        currentX = startX + dims.pad.x
      else
        -- Move to the next spot in a row
        currentX = currentX + dims.pad.x + omni.miniwin.graph.ngroup.area.width     
      end -- if
      if (((i - 1) % numInRow) == 0) and (i ~= 1) then
        -- Move to the beginning of the next row
        currentY = currentY + dims.pad.y + omni.miniwin.graph.ngroup.area.height
      end -- if

      omni.miniwin.graph.ngroup.drawEntry(currentX, currentY, entry, true)
      numInRoom = numInRoom + 1
    end -- for
    if (numInRoom > 0) then
      currentY = currentY + omni.miniwin.graph.ngroup.area.height + dims.pad.yBig
    end -- if
  end -- if

  -- Non-grouped players in area
  if omni.report.isEnabled("~grp-area") then
    local numInArea = 0
    numInRow = math.floor(width / (omni.miniwin.graph.ngroup.area.width + dims.pad.x))
    for i, entry in ipairs(omni.miniwin.graph.chars.ngroupAreaArray) do
      if (((i - 1) % numInRow) == 0) or (numInRow == 0) then
        -- Move to the beginning of a row
        currentX = startX + dims.pad.x
      else
        -- Move to the next spot in a row
        currentX = currentX + dims.pad.x + omni.miniwin.graph.ngroup.area.width     
      end -- if
      if (((i - 1) % numInRow) == 0) and (i ~= 1) then
        -- Move to the beginning of the next row
        currentY = currentY + dims.pad.y + omni.miniwin.graph.ngroup.area.height
      end -- if

      omni.miniwin.graph.ngroup.drawEntry(currentX, currentY, entry, false)
      numInArea = numInArea + 1
    end -- for
    if (numInArea > 0) then
      currentY = currentY + omni.miniwin.graph.ngroup.area.height + dims.pad.yBig
    end -- if
  end -- if

  -- Mobs in room
  if omni.report.isEnabled("mob") then
    numInRow = math.floor(width / (omni.miniwin.graph.ngroup.mob.width + dims.pad.x))
    for i, entry in ipairs(omni.miniwin.graph.chars.mobRoomArray) do

      if (((i - 1) % numInRow) == 0) or (numInRow == 0) then
        -- Move to the beginning of a row
        currentX = startX + dims.pad.x
      else
        -- Move to the next spot in a row
        currentX = currentX + dims.pad.x + omni.miniwin.graph.ngroup.mob.width     
      end -- if
      if (((i - 1) % numInRow) == 0) and (i ~= 1) then
        -- Move to the beginning of the next row
        currentY = currentY + dims.pad.yMed + omni.miniwin.graph.ngroup.mob.height
      end -- if

      local charColor
      if (entry.isDivine == true) then
        charColor = color.divine
      elseif (entry.charType == "pet") then
        charColor = color.pet
      elseif (entry.good == true) then
        charColor = color.good
      elseif (entry.evil == true) then
        charColor = color.evil
      else
        charColor = color.neutral
      end -- if

      local nameSuffix = ""
      local suffixContents = ""
      if (entry.isQuest == true) then
        suffixContents = suffixContents .. "Q"
      end -- if
      if (entry.nameShort ~= nil) then

        local cpEntry = omni.hitlist.campaign.mobs[omni.capitalize(entry.nameShort)]
        if (cpEntry ~= nil) and (cpEntry.completed < cpEntry.total) and (not entry.isDivine) then
          suffixContents = suffixContents .. "C?"
        end -- if

        local gqEntry = omni.hitlist.gquest.mobs[omni.capitalize(entry.nameShort)]
        if (gqEntry ~= nil) and (gqEntry.completed < gqEntry.total) and (not entry.isDivine) then
          suffixContents = suffixContents .. "G?"
        end -- if

        if omni.hitlist.isBlocker(entry.nameShort) then
          suffixContents = suffixContents .. "B"
        end -- if
      end -- if

      if (suffixContents ~= "") then
        nameSuffix = " [" .. suffixContents .. "]"
      end -- if

      local targetColorStr, targetColorVal = omni.report.getColor(entry.target or "")
      omni.miniwin.graph.ngroup.mob.draw(currentX,
                                         currentY, 
                                         entry.target or "",
                                         targetColorVal,
                                         entry.dotName,
                                         charColor,
                                         nameSuffix,
                                         entry.hpPercent,
                                         entry.wounded,
                                         entry.sanc)
    end -- for
    currentY = currentY + omni.miniwin.graph.ngroup.mob.height + dims.pad.yMed
  end -- if

end -- omni.miniwin.graph.ngroup.draw


function omni.miniwin.graph.ngroup.drawEntry(x, y, entry, isRoom)
  local color = omni.miniwin.graph.color

  local stats = entry.stats or 0
  local flags = ""
  local clan  = ""

  local targetColorStr, targetColor = omni.report.getColor(entry.target or "")

  -- If the player is in the room then we can see the alignment and pick the appropriate color.  Otherwise,
  -- if the player is in the area but not in our room then we can't know alignment.  Pick a generic color
  -- that won't be confused with an alignment.
  local charColor = color.ngroup
  if (isRoom) then
    if (entry.good == true) then
      charColor = color.good
    elseif (entry.evil == true) then
      charColor = color.evil
    else
      charColor = color.neutral
    end -- if
  end -- if

  -- inRoom uses nameKey, inArea uses name
  local name = entry.nameKey or entry.name

  local level = 0
  local areaEntry = omni.scan.swho.area.table[name]
  if (areaEntry ~= nil) then
    flags = strip_colours(areaEntry.flags)
    clan  = string.sub(areaEntry.clanShort, 1, omni.miniwin.graph.dims.len.clan)
    level = areaEntry.level
  end -- if

  omni.miniwin.graph.ngroup.area.draw(x,
                                      y,
                                      level,
                                      name,
                                      stats,
                                      flags,
                                      clan,
                                      (entry.hpPercent or 100) / 100,
                                      99999, -- damOut,   --FIXME TODO: track actual damage dealt/received
                                      99, -- damOutNum,
                                      99999, -- damIn,
                                      entry.numAttackers or 0, -- damInNum
                                      entry.target or "",
                                      targetColor, 
                                      charColor,
                                      entry.sanc,
                                      isRoom)

end -- omni.miniwin.graph.ngroup.drawEntry


function omni.miniwin.graph.ngroup.area.calc()
  -- shortcuts to cut down on typing
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height

  local width, height = 0, 0

  -- Damage box (also includes current target)
  if omni.report.isEnabled("dmg") then
    width = width + (2 * dims.pad.x) -- target
    width = width + (charWidth * dims.len.target)
  end -- if

  -- Name box
  local rowMaxChars = dims.len.stats + 1 + dims.len.clan
  width = width + charWidth * rowMaxChars
  width = width + (2 * dims.pad.x) -- allow pads on left and right of the name box

  height = height + (3 * charHeight) -- 3 layers in the entry

  -- Add a 1-pixel border
  height = height + 2
  width  = width + 2

  omni.miniwin.graph.ngroup.area.height = height
  omni.miniwin.graph.ngroup.area.width  = width

  return height, width
end -- omni.miniwin.graph.ngroup.area.calc


function omni.miniwin.graph.ngroup.area.draw(startX, startY,
                                             lvl, name, stats, flags, clan, hpPercent,
                                             damOut, damOutNum, damIn, damInNum, target, targetColor,
                                             charColor, isSanc, isRoom)

  -- Get shortcuts to common values to save on typing
  local width      = omni.miniwin.graph.ngroup.area.width
  local widthTrim  = width - 2 -- We leave a 1-pixel border on each side
  local height     = omni.miniwin.graph.ngroup.area.height
  local heightTrim = height - 2 -- We leave a 1-pixel border on each side
  local color      = omni.miniwin.graph.color
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height
  local fontId     = omni.miniwin.font.table.graph.id

  -- If someone is wanted or hardcore, highlight it.  Otherwise, use the border to indicate whether or
  -- not the player is sanc'ed
  local borderColor = color.ngroup
  if (string.match((flags or "nil"), "H") or string.match((flags or "nil"), "W")) then
    borderColor = color.wantedOrHC
  elseif isSanc then
    borderColor = color.sanc
  end -- if

  local curX, curY = startX + 1, startY + 1

  -- Fill the background for the entire entry
  WindowRectOp(omni.miniwin.win, 2, startX, startY, startX + width, startY + height, color.bg, 0)

  -- Target, damage out, damage in
  if omni.report.isEnabled("dmg") then
    local tgtWidth = (2 * dims.pad.x) + (charWidth * dims.len.target)
    local tgtHeight = charHeight
    local tgtX = curX + dims.pad.x
    local tgtY = curY
    local targetStr = string.sub(target or "", 1, dims.len.target)
    WindowText(omni.miniwin.win, fontId, targetStr, tgtX, tgtY, curX + tgtWidth, curY + tgtHeight,
               targetColor, false)
    WindowRectOp(omni.miniwin.win, 1, curX - 1, startY, curX + tgtWidth + 2, curY + (2 * charHeight),
                 borderColor, 0)
    curX = tgtX
    curY = curY + charHeight

    local doX, doY = curX, curY
    local damOutStr = ""
    if (damOut == 0) then
      if (damOutNum > 0) then
        -- Center the # of targets in the output
        damOutStr = string.format("%s%-2d", string.rep(" ", (dims.len.target - dims.len.numAtk) / 2), damOutNum)
      end -- if
    else
      damOutStr = string.format("%-5d : %-2d", damOut, damOutNum)
    end -- if
    WindowText(omni.miniwin.win, fontId, damOutStr, doX, doY, doX + tgtWidth, curY + tgtHeight,
               color.damOut, false)
    curY = curY + tgtHeight

    local damInStr = ""
    if (damIn == 0) then
      if (damInNum > 0) then
        -- Center the # of attackers in the output
        damInStr = string.format("%s%-2d", string.rep(" ", (dims.len.target - dims.len.numAtk) / 2), damInNum)
      end -- if
    else
      damInStr = string.format("%-5d : %-2d", damIn, damInNum)
    end -- if
    WindowText(omni.miniwin.win, fontId, damInStr, curX, curY, curX + tgtWidth, curY + tgtHeight,
               color.damIn, false)
    curX = curX + tgtWidth - dims.pad.x
    curY = startY + 1
  end -- if

  -- Name box
  local rowMaxChars = dims.len.stats + 1 + dims.len.clan
  local nameBoxWidth = (2 * dims.pad.x) + (charWidth * rowMaxChars)
  local hpWidth = nameBoxWidth * hpPercent
  local hpColorBase = color.gradientDark
  local hpColor = color.bgDark
  if (isRoom) then
    hpColor = color.ngroupBg
  end -- if

  WindowGradient(omni.miniwin.win, curX, curY, curX + hpWidth, curY + (heightTrim / 2),
                 hpColor, hpColorBase, 2)
  WindowGradient(omni.miniwin.win, curX, curY + (heightTrim / 2), curX + hpWidth,
                 curY + heightTrim, hpColorBase, hpColor, 2)
  WindowRectOp(omni.miniwin.win, 1, curX, startY, curX + nameBoxWidth, startY + height, borderColor, 0)

  -- Name box contents
  --  3 chars: level(3) 
  -- 12 chars: who(3) name(5) numAtk(2)  -- name can expand if who and numAtk aren't full
  -- 12 chars: stats(4) clan(7)
  local rowWidth    = charWidth * rowMaxChars
  local rowHeight   = charHeight
  local rowX        = curX + dims.pad.x
  local row1Y       = curY

  local row1Text = ""
  if (lvl > 0) then
    row1Text = string.format("%-3d", lvl)
  end -- if
  WindowText(omni.miniwin.win, fontId, row1Text, rowX, row1Y, rowX + rowWidth, row1Y + rowHeight,
             color.level, false)

  local row2Y = row1Y + rowHeight
  local row2aText = strip_colours(flags)
  local row2cText = ""
  if (damInNum > 0) then
    row2cText = string.format("%d", damInNum)
  end -- if

  local row2aLen, row2cLen = string.len(row2aText), string.len(row2cText)
  local numBorderChars = row2aLen
  if (row2cLen > numBorderChars) then
    numBorderChars = row2cLen
  else
    row2cText = string.rep(" ", row2aLen - row2cLen) .. row2cText  -- pad the front with spaces if necessary
  end -- if

  local maxNameWidth = rowMaxChars - (2 * numBorderChars) - 2 -- subtract 2 for spaces on either side
  local nameTrunc = string.sub(name, 1, maxNameWidth) 

  -- Center the name
  local row2bText = " " .. string.rep(" ", (maxNameWidth - string.len(nameTrunc)) / 2) .. nameTrunc .. " "

  local row2aWidth = charWidth * numBorderChars
  local row2bWidth = charWidth * string.len(row2bText)
  local row2cWidth = charWidth * numBorderChars

  WindowText(omni.miniwin.win, fontId, row2aText, rowX, row2Y, rowX + row2aWidth,
             row2Y + rowHeight, color.flags, false)

  WindowText(omni.miniwin.win, fontId, row2bText, rowX + row2aWidth, row2Y, rowX + row2aWidth + row2bWidth,
             row2Y + rowHeight, charColor, false)

  WindowText(omni.miniwin.win, fontId, row2cText, rowX + rowWidth - row2cWidth, row2Y,
             rowX + rowWidth, row2Y + rowHeight, color.numAtk, false)

  local row3Y = row2Y + rowHeight
  local clanTrunc = omni.capitalize(string.sub(clan, 1, dims.len.clan))
  local statStr = "    "
  if (stats > 0) then
    statStr = string.format("%-4d", stats)
  end -- if
  local row3Text = string.format("%s%s%s",
                                 statStr,
                                 string.rep(" ", rowMaxChars - dims.len.stats - string.len(clanTrunc)),
                                 clanTrunc)
  WindowText(omni.miniwin.win, fontId, row3Text, rowX, row3Y,
             rowX + rowWidth, row3Y + rowHeight, color.stats, false)

  curX = curX + nameBoxWidth

  -- Border around entire entry
  if omni.report.isEnabled("dmg") then
    WindowRectOp(omni.miniwin.win, 1, startX, startY, startX + width - 1, startY + height, borderColor, 0)
  end -- if
end -- omni.miniwin.graph.ngroup.area.draw


function omni.miniwin.graph.ngroup.mob.calc()
  -- shortcuts to cut down on typing
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height

  local width, height = 0, 0

  if omni.report.isEnabled("tgt") then
    -- Target
    width = width + (2 * dims.pad.x)
    width = width + (charWidth * dims.len.target)

    -- Arrow
    width = width + (charWidth * dims.len.arrow)
  end -- if

  -- Mob name
  width = width + (2 * dims.pad.x)
  width = width + (charWidth * dims.len.nameMob)

  height = height + charHeight

  -- Add a 1-pixel border to the top, right, bottom (but not the left side)
  height = height + 2
  width  = width + 1

  omni.miniwin.graph.ngroup.mob.height = height
  omni.miniwin.graph.ngroup.mob.width  = width

  return height, width
end -- omni.miniwin.graph.ngroup.calc


function omni.miniwin.graph.ngroup.mob.draw(startX, startY, target, targetColor, name, nameColor, nameSuffix,
                                            hpPercent, isWounded, isSanc)
  local width      = omni.miniwin.graph.ngroup.mob.width
  local widthTrim  = width - 1 -- We leave a 1-pixel border on the right (but not the left)
  local height     = omni.miniwin.graph.ngroup.mob.height
  local heightTrim = height - 2 -- We leave a 1-pixel border on the top and bottom
  local color      = omni.miniwin.graph.color
  local dims       = omni.miniwin.graph.dims
  local charWidth  = omni.miniwin.font.table.graph.width
  local charHeight = omni.miniwin.font.table.graph.height
  local fontId     = omni.miniwin.font.table.graph.id

  local hpColorBase = color.gradientDark
  local hpColor = color.bgMob
  if (hpPercent == nil) and isWounded then
    hpColor = color.bgWounded
  end -- if

  local curX, curY = startX, startY + 1

  if omni.report.isEnabled("tgt") then
    -- Target
    local targetTrunc = string.sub(strip_colours(target), 1, dims.len.target)
    local targetText = string.rep(" ", dims.len.target - string.len(targetTrunc)) .. targetTrunc
    local targetWidth = charWidth * dims.len.target
    WindowText(omni.miniwin.win, fontId, targetText, curX, curY, curX + targetWidth,
               curY + charHeight, targetColor, false)
    curX = curX + targetWidth + dims.pad.x

    -- Arrow
    local arrowWidth = charWidth * dims.len.arrow
    if (targetTrunc ~= "") then
      local arrowText = string.rep("<", dims.len.arrow)
      WindowText(omni.miniwin.win, fontId, arrowText, curX, curY, curX + arrowWidth,
                 curY + charHeight, color.arrow, false)
    end -- if
    curX = curX + arrowWidth + dims.pad.x
  end -- if

  -- Border around the mob name box
  local borderColor  = color.mob
  local nameColorAdj = nameColor

  if (nameSuffix == " [Q]") or
     (nameSuffix == " [B]") or
     (nameSuffix == " [C?]") or
     (nameSuffix == " [G?]") or
     (nameSuffix == " [QC?]") or
     (nameSuffix == " [QG?]") or
     (nameSuffix == " [C?G?]") or
     (nameSuffix == " [QC?G?]") then

    nameColorAdj = color.target
    borderColor  = color.target
    -- override the border to highlight it if it is both a hitlist mob and our current selection
    if (name == omni.highlight) then
      borderColor = color.highlight
    end -- if
  elseif (name == omni.highlight) then
    borderColor  = color.highlight
    nameColorAdj = color.highlight
  elseif isSanc then
    borderColor = color.sanc
  end -- if
  local nameBoxWidth = (2 * dims.pad.x) + (charWidth * dims.len.nameMob)
  WindowRectOp(omni.miniwin.win, 1, curX, startY, curX + nameBoxWidth + 2, startY + height, borderColor, 0)
  curX = curX + 1

  -- Mob name box
  local hpWidth = nameBoxWidth
  if (hpPercent ~= nil) then
    hpWidth = nameBoxWidth * hpPercent / 100
  end -- if

  WindowGradient(omni.miniwin.win, curX, curY, curX + hpWidth, curY + heightTrim,
                 hpColor, hpColorBase, 2)

  -- Mob name
  curX = curX + dims.pad.x
  local nameText = string.sub(name, 1, (dims.len.nameMob - string.len(nameSuffix))) .. nameSuffix
  local nameWidth = charWidth * string.len(nameText)
  WindowText(omni.miniwin.win, fontId, nameText, curX, curY, curX + nameWidth,
             curY + charHeight, nameColorAdj, false)

end -- omni.miniwin.graph.ngroup.mob.draw


--]]

]]>

</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="omni:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
