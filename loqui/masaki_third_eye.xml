<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, September 20, 2015, 4:41 AM -->
<!-- MuClient version 4.93 -->

<!-- Plugin "Masaki_Third_Eye" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Masaki_Third_Eye"
   author="BluMalice"
   id="ea56ea6a618795027b343d12"
   language="Lua"
   purpose="A miniwin that keeps track of who is currently in the area."
   save_state="y"
   date_written="2015-09-20 04:40:27"
   requires="4.63"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
<trigger
	match="^[\s]+Who list sorted by .*|[\s]+Aardwolf Players Online[\s]+$"
	regexp="y"
	enabled="n"
	name="startcapture"
	omit_from_output="y"
	sequence="100"
	send_to="12">
	<send>
		EnableTrigger("startcapture", false)
		EnableTrigger("swhogag", true)
		EnableTrigger("endgag", true)
		EnableTrigger("capturenames", true)
		EnableTrigger("endcapture", true)
	</send>
</trigger>
<trigger
	match="^Use \'swho\' to see sorted lists of players online\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.$"
	regexp="y"
	enabled="n"
	name="swhogag"
	omit_from_output="y"
	sequence="100"
	send_to="12"
>
</trigger>
<trigger
	match="^Players found\: \[[\d]+\]\, Max this reboot\: \[[\d]+\]\, Connections this reboot\: \[[\d]+\]$"
	regexp="y"
	enabled="n"
	name="endcapture"
	omit_from_output="y"
	sequence="95"
	send_to="12">
	<send>
		EnableTrigger("capturenames", false)
		EnableTrigger("endcapture", false)
	</send>
</trigger>
<trigger
	match="^Players invis\: \[[\d]+\]\, Max on ever\: \[[\d]+\]$"
	regexp="y"
	enabled="n"
	name="endgag"
	omit_from_output="y"
	sequence="100"
	send_to="12">
	<send>
		EnableTrigger("swhogag", false)
		EnableTrigger("endgag", false)
		EnableTrigger("capturenames", false)
		EnableTrigger("endcapture", false)
		
		drawPlayers()
	</send>
</trigger>
<trigger
	match="^.*$"
	regexp="y"
	enabled="n"
	name="capturenames"
	omit_from_output="y"
	sequence="100"
	send_to="12"
	script="captureNames">
</trigger>
<trigger
	match="^There are too many doors and fences to see who is in this area\.$"
	regexp="y"
	enabled="y"
	sequence="100"
	send_to="12">
	<send>
		players = {}
		drawPlayers()
	</send>
</trigger>
</triggers>

<!--  Aliases  -->

<aliases>
<alias
	match="^meye min(?:i|im|imi|imiz|imize)$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		vars.minimize = not vars.minimize
		redraw()
	</send>
</alias>
<alias
	match="^meye setfont$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95"
	script="setFontSize">
</alias>
<alias
	match="^meye show$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		closeToggle()
	</send>
</alias>
<alias
	match="^meye help$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95"
	script="showHelp">
</alias>
<alias
	match="^meye blink$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		players = {}
		EnableTrigger("startcapture", true)
		SendNoEcho("swho 12 area")
	</send>
</alias>
<alias
	match="^meye level(?:s)?$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		vars.drawLevels = not vars.drawLevels
		players = {}
		EnableTrigger("startcapture", true)
		SendNoEcho("swho 12 area")
	</send>
</alias>
<alias
	match="^meye stat(?:s)?$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		vars.drawStats = not vars.drawStats
		players = {}
		EnableTrigger("startcapture", true)
		SendNoEcho("swho 12 area")
	</send>
</alias>
<alias
	match="^meye timer ([\d]+)$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		local newTime = tonumber("%1")
		newTime = newTime > 59 and 59 or (newTime == 0 and 1 or newTime)
		SetTimerOption("millionTimer", "minute", tostring(newTime))
		ColourNote("lime", "black", centerText(string.format("Third Eye will blink every%s minute%s.", newTime > 1 and " " .. tostring(newTime) or "", newTime > 1 and "s" or ""), 60))
	</send>
</alias>
</aliases>

<timers>
<timer
	name="whoTimer"
	minute="1"
	enabled="y"
	send_to="12">
	<send>
		players = {}
		EnableTrigger("startcapture", true)
		SendNoEcho("swho 12 area")
	</send>
</timer>
</timers>

<script>
<![CDATA[
--[[ ================================================================== 
     =                           INITIALIZE                           = 
     ================================================================== ]]

require "serialize"

-- Default variables
win = "Masaki_Third_Eye" .. GetPluginID()
icon = GetPluginInfo(GetPluginID(), 20) .. "Masaki2.png"
vars = {}

-- Saved variables
vars.defaultFont = "defaultFont"
vars.defaultFontFamily = "Consolas"
vars.header = {}
vars.fontSize = 12
vars.fontHeight = 8
vars.winLeft = 0
vars.winTop = 0
vars.winRight = 200
vars.winBottom = 200
vars.winHeight = 1
vars.pos_x = 495
vars.pos_y = 322
vars.show = true
vars.minimize = false
vars.snapSize = 10
vars.buttons = {}
vars.drawLevels = true
vars.drawStats = true

-- Activity variables
dragSpot = nil
players = {}

function OnPluginInstall()
	-- Restore saved states
	assert(loadstring(GetVariable("vars") or ""))()
	vars = vars or {}
	
	-- Refresh all states if changes or updates were added
	if vars.show == nil or vars.minimize == nil or vars.defaultFontFamily ~= "Consolas" or
	   vars.snapSize == nil or vars.drawLevels == nil then
	   
		vars.defaultFont = vars.defaultFont or "defaultFont"
		vars.defaultFontFamily = vars.defaultFontFamily or "Consolas"
		vars.header = {}
		vars.fontSize = vars.fontSize or 12
		vars.fontHeight = vars.fontHeight or 8
		vars.winLeft = vars.winLeft or 0
		vars.winTop = vars.winTop or 0
		vars.winRight = vars.winRight or 200
		vars.winBottom = vars.winBottom or 200
		vars.winHeight = 1
		vars.pos_x = vars.pos_x or 495
		vars.pos_y = vars.pos_y or 322
		vars.show = vars.show or true
		vars.minimize = vars.minimize or false
		vars.snapSize = vars.snapSize or 10
		vars.drawLevels = vars.drawLevels or true
		vars.drawStats = vars.drawStats or true
	end
	
	-- Prepare miniwin header
	if #vars.header == 0 then
		vars.header = {}
		table.insert(vars.header, {text = "{-=", textcolour = ColourNameToRGB("dimgray")})
		table.insert(vars.header, {text = "Masaki Third Eye", textcolour = ColourNameToRGB("darkred")})
		table.insert(vars.header, {text = "=-} ", textcolour = ColourNameToRGB("dimgray")})
	end
	
	-- Load miniwin and its properties
	WindowCreate(win, vars.winLeft, vars.winTop, vars.winRight, vars.winBottom, miniwin.pos_center_all, miniwin.create_keep_hotspots, ColourNameToRGB("black"))
	WindowFont(win, vars.defaultFont, vars.defaultFontFamily, vars.fontSize, false, false, false, false, 1, 0)
	WindowLoadImage(win, "icon", icon)
	
	-- Draw basic miniwin
	vars.winHeight = 1
	vars.fontHeight = WindowFontInfo(win, vars.defaultFont, 1)
	vars.winRight = textWidth(vars.header[1].text .. vars.header[2].text .. vars.header[3].text) + 25
	vars.winBottom = vars.winHeight * vars.fontHeight
	resize()
	WindowSetZOrder(win, 500)
	drawDefaults(true)
	WindowShow(win, vars.show)
	WindowPosition(win, vars.pos_x, vars.pos_y, 
                 miniwin.pos_stretch_to_view, 
                 miniwin.create_absolute_location)
		
	-- Final touches to the loading sequence
	loadButtons()
	showHelp()
end

function OnPluginSaveState()
	for i, v in pairs(vars.buttons) do
		v.mouseup = nil
		v.mousedown = nil
	end
	
	SetVariable("vars", serialize.save("vars"))
end

function loadButtons()
	-- Reload all buttons and their functions

	for i, v in pairs(vars.buttons) do
		local temp = v
	
		v = Button:new{x = temp.x, y = temp.y, width = temp.width, height = temp.height, text = temp.text, name = temp.name,
				   background = temp.background, textcolour = temp.textcolour, hint = temp.hint}

		v.mouseupDeclaration = temp.mouseupDeclaration
		v.mousedownDeclaration = temp.mousedownDeclaration
		
		v.mouseup = loadstring(v.mouseupDeclaration or "")
		v.mousedown = loadstring(v.mousedownDeclaration or "")
		
		_G[v.name] = v
	end
	
	drawDefaults(true)
end

function showHelp()
	ColourNote("lime", "black", "+-------------------{-=Masaki Third Eye=-}-------------------+")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourTell("lime", "black", "|")
	ColourTell("darkred", "black", " ".. centerText("\"None can hide from the Masaki Third Eye\"", 59))
	ColourNote("lime", "black", "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("This miniwin will capture all visible players", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("in your current area at set periods of time.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("The default period is each minute.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("{-=Commands=-}", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye blink   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Capture players in the area within miniwin.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye timer #   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Sets new blink timer in minutes.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye levels   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Toggles whether to show or hide player levels.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye stats   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Toggles whether to show or hide player stats.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye setfont   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Sets new font size for miniwin.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye minimize   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Minimizes or restores miniwin.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye show   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Shows or hides miniwin.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   meye help   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Displays this message.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "+-------------------{-=Masaki Third Eye=-}-------------------+")
end

--[[ ================================================================== 
     =                      MINIWIN UTILITIES                         = 
     ================================================================== ]]
	 
function dragmove(flags, hotspot_id)
	local previousX, previousY = vars.pos_x, vars.pos_y
	
	if not dragSpot then
		vars.pos_x, vars.pos_y = WindowInfo (win, 17) - WindowInfo(win, 14), WindowInfo (win, 18) - 5
		dragSpot = WindowInfo(win, 14)
	else
		vars.pos_x, vars.pos_y = WindowInfo (win, 17) - dragSpot, WindowInfo (win, 18) - 5
	end
	
	local changedX, changedY = vars.pos_x - previousX, vars.pos_y - previousY
	snap(win, changedX, changedY, vars)

	WindowPosition(win, vars.pos_x, vars.pos_y, 
				   miniwin.pos_stretch_to_view, 
                   miniwin.create_absolute_location)
end

function dragrelease(flags, hotspot_id)
	dragSpot = nil
end

function showWindow(show)
	-- Utility function, shows or hides the miniwin.
	
	WindowShow(win, show)
end

function redraw()
	-- Utility function, redraws the miniwin.
	
	resize()
	drawDefaults(true)
	showWindow(vars.show)
end

function resize()
	-- Utility function, resizes the miniwin.
	
	if not vars.minimize then
		WindowResize(win, vars.winRight, vars.winHeight * vars.fontHeight, ColourNameToRGB("black"))
	else
		WindowResize(win, vars.winRight, vars.fontHeight, ColourNameToRGB("black"))
	end
end

function textWidth(text)
	-- Utility function, returns the total width the given text requires within the miniwin.
	
	return WindowTextWidth(win, vars.defaultFont, text)
end

function drawDefaults(refreshHotspots)
	-- Utility function, draws the default layout of the miniwin.
	
	-- Clear miniwin
	WindowRectOp(win, miniwin.rect_fill, 0, 0, 0, 0, ColourNameToRGB("black"))

	-- Miniwin background and outline
	WindowRectOp(win, miniwin.rect_fill, 0, 0, vars.winRight, vars.fontHeight, ColourNameToRGB("black"))
	WindowRectOp(win, miniwin.rect_3d_rect, 0, 0, vars.winRight, 0, ColourNameToRGB("crimson"), ColourNameToRGB("red"))
	
	-- Seperator for header
	WindowRectOp(win, miniwin.rect_3d_rect, 0, 0, vars.winRight, vars.fontHeight, ColourNameToRGB("crimson"), ColourNameToRGB("red"))
	
	drawText("", 0, 25, vars.header)
	
	if refreshHotspots then
		WindowDeleteAllHotspots(win)
			
		-- Drag hotspot for header
		WindowAddHotspot(win, "DragArea", vars.fontHeight, 0, vars.winRight, vars.fontHeight, "", "", "", "", "", vars.headerhint, miniwin.cursor_both_arrow, 0)
		WindowDragHandler(win, "DragArea", "dragmove", "dragrelease", 0)
	end
	
	-- Minimize and close button
	WindowRectOp(win, miniwin.rect_fill, 5, 4, vars.fontSize * 1.42, vars.fontSize * 1.16, ColourNameToRGB("black"))
	WindowTransformImage(win, "icon", 5 + (vars.minimize and 2 + ((vars.fontSize - 6) * 1.5)  or 0), 4 + (vars.minimize and 2 + ((vars.fontSize - 6)) or 0), miniwin.image_copy, ((vars.fontSize * 1.42 - 5) / 50) * (vars.minimize and -1 or 1), 0, 0, ((vars.fontSize * 1.16 - 4) / 50) * (vars.minimize and -1 or 1))
	if refreshHotspots then
		WindowAddHotspot(win, "ToggleArea", 5, 4, vars.fontSize * 1.42, vars.fontSize * 1.16, "", "", "", "", "toggleMiniwin", "{-=Left click to minimize : Right click to close=-}", miniwin.cursor_hand, 0)
	end
end

function drawText(text, top, l, styles)
	-- Utility function, draws text into the miniwin.

	local left = l
	if styles ~= nil then
		for i, v in ipairs(styles) do
			left = left + WindowText(win, vars.defaultFont, v.text, left, top * vars.fontHeight - 1, 0, 0, v.textcolour, true)
		end
	else
		WindowText(win, vars.defaultFont, text, left, top * vars.fontHeight - 1, 0, 0, ColourNameToRGB("white"), true)
	end
end

function toggleMiniwin(flags, hotspot_id)
	-- Utility function, toggles miniwin sizes.
	
	if flags == miniwin.hotspot_got_rh_mouse then
		closeToggle()
	elseif flags == miniwin.hotspot_got_lh_mouse then
		vars.minimize = not vars.minimize
		redraw()
	end
end

function setFontSize()
	-- Sets new font size for miniwin.

	local size = utils.inputbox("Enter new font size : ", "{-=Masaki=-}", tostring(vars.fontSize), vars.defaultFontFamily, vars.fontSize)
	vars.fontSize = size or vars.fontSize
	WindowFont(win, vars.defaultFont, vars.defaultFontFamily, vars.fontSize, false, false, false, false, 1, 0)
	vars.fontHeight = WindowFontInfo(win, vars.defaultFont, 1)
	redraw()
end

function closeToggle()
	-- Utility function, displays or hides miniwin.
	
	vars.show = not vars.show
	showWindow(vars.show)
end

function OnPluginClose()
	WindowDelete(win)
end

function OnPluginDisable()
	showWindow(false)
end

function OnPluginEnable()
	showWindow(true)
end

--[[ +----------------------------------------------------------------+ 
     |                         MISC UTILITIES                         | 
     +----------------------------------------------------------------+ ]]

function split(s, del)
	-- Utility function, splits given string by given delimiter.
	
	if del == nil then
		del = "%s"
	end
	local t = {}
	local i = 1

	for str in string.gmatch(s, "([^" .. del .. "]+)") do
		t[i] = str
		i = i + 1
	end
	return t
end

function centerText(text, width)
	-- Wraps text into the center of the specified width.

	local length = width - #text
	if length > 0 then
		text = string.rep(" ", length / 2) .. text .. string.rep(" ", length / 2)
	end
	
	return #text == width and text or text .. " "
end

--[[ ================================================================== 
     =                           OPERATIONS                           = 
     ================================================================== ]]

function captureNames(name, line, wildcards, styles)
	-- Process captured names for insertion into miniwin
	
	if #(Trim(line)) ~= 0 then
		local parts = {}
		table.insert(parts, line:sub(1, 17))
		table.insert(parts, line:sub(19, 26))
		table.insert(parts, line:sub(28))
		parts.styles = styles
		table.insert(players, parts)
	end
end	 

function drawPlayers()
	-- Draw player list to miniwin
	
	vars.winHeight = #players + 1
	
	local max_width = 0
	for i, v in ipairs(players) do
		max_width = math.max(max_width, textWidth((vars.drawLevels and v[1] or "") .. (vars.drawStats and v[2] or "") .. v[3]) + 15 or 0)
	end
	
	vars.winRight = math.max(max_width, textWidth("        Masaki Third Eye ")) + 7
	redraw()
	
	for i, v in ipairs(players) do
		local newStyles = {}
		
		if not vars.drawLevels then
			local index = #(v.styles[1].text) == 1 and 4 or 2
			index = (#Trim(v.styles[2].text) == 0 or #Trim(v.styles[4].text) == 0) and index + 1 or index
			
			for j=index, #(v.styles) do
				table.insert(newStyles, v.styles[j])
			end
		end
		
		if not vars.drawStats then
			if not vars.drawLevels then
				local index = 4
				local tempNewStyles = {}
				
				for j=index, #(v.styles) do
					table.insert(tempNewStyles, newStyles[j])
				end
				
				newStyles = tempNewStyles
			else
				local index1 = #(v.styles[1].text) == 1 and 3 or 1
				local index2 = index1 == 3 and 8 or 6
				
				for j=1, index1 do
					table.insert(newStyles, v.styles[j])
				end
				
				for j=index2, #(v.styles) do
					table.insert(newStyles, v.styles[j])
				end
			end
		end
		
		if vars.drawLevels and vars.drawStats then
			newStyles = v.styles
		end
		
		drawText("", i, 5, newStyles)
	end
end

--[[ ================================================================== 
     =                      MINIWIN BUTTON CLASS                      = 
     ================================================================== ]]
	 
--[[ +----------------------------------------------------------------+ 
     |                            USAGE                               | 
     |                            ^^^^^                               | 
     |   Creating a new button   :   button = Button:new()            | 
     |   Create with defaults    :   button = Button:new{key = value} | 
     |   Redraw button           :   button:update(refreshHotspots)   | 
     |                               Pass true to refresh hotspots    | 
     |                               or false to only draw the button | 
     |                                                                | 
     |                  Default instance variables                    | 
     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^                    | 
     |            text           :   Text displayed within the button | 
     |            x              :   x-position of the button         | 
     |            y              :   y-position of the button         | 
     |            width          :   Width of the button              | 
     |            height         :   Height of the button             | 
     |                                                                | 
     |            textcolour     :   Text colour within button        | 
     |            background     :   Colour that fills the button     | 
     |            outline1       :   Colour on the top-left edges     | 
     |            outline2       :   Colour on the bottom-right edges | 
     |                                                                | 
     |            name           :   Must be the button name itself   | 
     |                               Needed for mouseup and mousedown | 
     |                               eg: button1 = Button:new()       | 
     |                                   button1.name = "button1"     | 
     |            mouseup()      :   Function called after click      | 
     |            mousedown()    :   Function called before click     | 
     |                                                                | 
     |            hint           :   Text displayed when hovered over | 
     |            cursor         :   Cursor type to use over button   | 
     |                                                                | 
     |                mouseup  |  mousedown example                   | 
     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                   | 
     |                button1 = Button:new()                          | 
     |                                                                | ]]
--   |                button1.mouseupDeclaration = [[                 | 
--[[ |                      -- This is the function that will execute | 
     |                      -- on mouseup                             | 
     |                      print("I got clicked!")                   | 
     |                      local num = 5                             | 
     |                      print(string.format("5 times 5 is %s!",   | 
     |                                          num * 5))             | ]] 
--   |                ]]                                              | 
--[[ |                                                                | 
     |                button1.mouseup = loadstring(                   |
	 |                                  button1.mouseupDeclaration)   | 
     |                                                                | 
     +----------------------------------------------------------------+ ]]

Button = {text = "B", isdown = false, textcolour = "black",
		  background = "white", outline1 = "silver", outline2 = "blue"}

function Button:new(o)
	-- Initialization

	o = o or {}
	setmetatable(o, self)
	self.__index = self   -- <--- This is where default values of Button are loaded
						  --	  New values are still retained
	
	return o
end

function Button:update(refreshHotspots)
	-- Redraw button and refresh its hotspots
	
	-- Clear anything behind button
	WindowRectOp(win, miniwin.rect_fill, 
				 self.x or 0, self.y or 0,
				 (self.x or 0) + (self.width or 100), (self.y or 0) + (self.height or 100),
				 ColourNameToRGB("black"))
	
	-- Draw Button
	WindowRectOp(win, miniwin.rect_fill, 
				 self.x or 0, self.y or 0,
				 (self.x or 0) + (self.width or 100), (self.y or 0) + (self.height or 100),
				 self.isdown and ColourNameToRGB(self.outline2) or ColourNameToRGB(self.background))
				 
	WindowRectOp(win, miniwin.rect_3d_rect, 
				 self.x or 0, self.y or 0,
				 (self.x or 0) + (self.width or 100), (self.y or 0) + (self.height or 100),
				 ColourNameToRGB(self.outline1), ColourNameToRGB(self.outline2))
				 
	WindowText(win, vars.defaultFont, self.text, 
			   (self.x and self.width) and self.x + (self.width / 2) - (textWidth(self.text) / 2) or (textWidth(self.text) / 2), 
			   (self.y and self.height) and self.y + (self.height / 2) - (vars.fontHeight / 2) or (vars.fontHeight / 2), 
			   0, 0, ColourNameToRGB(self.textcolour), true)
			   
	-- Add hotspots
	if refreshHotspots then
		WindowAddHotspot(win, self.name, 
						 self.x or 0, self.y or 0,
						 (self.x or 0) + (self.width or 100), (self.y or 0) + (self.height or 100),
						 "", "", "mousedown", "", "mouseup", 
						 self.hint or "{=-Button=-}", self.cursor or miniwin.cursor_hand, 0)
	end
end

function mouseup(flags, hotspot_id)
	-- Call button mouseup function
	
	if _G[hotspot_id].mouseup then
		_G[hotspot_id].mouseup()
	end
	
	_G[hotspot_id].isdown = false
	_G[hotspot_id]:update(true)
end

function mousedown(flags, hotspot_id)
	-- Call button mousedown function
	
	if _G[hotspot_id].mousedown then
		_G[hotspot_id].mousedown()
	end
	
	_G[hotspot_id].isdown = true
	_G[hotspot_id]:update(false)
end

--[[ ================================================================== 
     =                       MINIWIN SNAP CLASS                       = 
     ================================================================== ]]

rect = {}

rect.intersects = function(r1, r2)
	local rw, rh, tw, th = rect.width(r2) + r2.x1, rect.height(r2) + r2.y1, rect.width(r1) + r1.x1, rect.height(r1) + r1.y1
	return ((rw < r2.x1 or rw > r1.x1) and
            (rh < r2.y1 or rh > r1.y1) and
            (tw < r1.x1 or tw > r2.x1) and
            (th < r1.y1 or th > r2.y1))
end

rect.width = function(r1)
	return math.abs(r1.x2 - r1.x1)
end

rect.height = function(r1)
	return math.abs(r1.y2 - r1.y1)
end

rect.snappable = function(r1, r2, saveVar)
	-- The idea here is to create inner and outer shells of the second rect,
	-- then check if the first rect intersects with the outer shell but not
	-- with the inner shell. If this is true, then the first rect can snap
	-- to the second rect.
	
	local outerr2 = {x1 = r2.x1 - (saveVar.snapSize or 10), y1 = r2.y1 - (saveVar.snapSize or 10), x2 = r2.x2 + (saveVar.snapSize or 10), y2 = r2.y2 + (saveVar.snapSize or 10)}
	local innerr2 = {x1 = r2.x1 + (saveVar.snapSize or 10), y1 = r2.y1 + (saveVar.snapSize or 10), x2 = r2.x2 - (saveVar.snapSize or 10), y2 = r2.y2 - (saveVar.snapSize or 10)}
	return rect.intersects(r1, outerr2) and not rect.intersects(r1, innerr2)
end

rect.snapEdge = function(r1, r2, saveVar)
	-- What happens here is the second rect gets separated
	-- into four pieces, one for each side. We then check
	-- which piece intersects with the first rect, and
	-- the piece that intersects will then be the snap edge.
	local top = {x1 = r2.x1, y1 = r2.y1 - (saveVar.snapSize or 10), x2 = r2.x2, y2 = r2.y1 + (saveVar.snapSize or 10)}
	local bottom = {x1 = r2.x1, y1 = r2.y2 - (saveVar.snapSize or 10), x2 = r2.x2, y2 = r2.y2 + (saveVar.snapSize or 10)}
	local left = {x1 = r2.x1 - (saveVar.snapSize or 10), y1 = r2.y1, x2 = r2.x1 + (saveVar.snapSize or 10), y2 = r2.y2}
	local right = {x1 = r2.x2 - (saveVar.snapSize or 10), y1 = r2.y1, x2 = r2.x2 + (saveVar.snapSize or 10), y2 = r2.y2}
	return rect.intersects(r1, top) and r1.y2 <= r2.y1, rect.intersects(r1, bottom) and r1.y1 >= r2.y2, rect.intersects(r1, left) and r1.x2 <= r2.x1, rect.intersects(r1, right) and r1.x1 >= r2.x2
end

function snap(currentWindow, changedX, changedY, saveVar)
	-- Attempt to snap miniwin to other miniwins
	-- currentWindow is the dragged window ID
	-- changedX and changedY is the difference the previous window position and the current window position
	--    eg: local previousX, previousY = vars.pos_x, vars.pos_y
	--		  vars.pos_x, vars.pos_y = WindowInfo(win, 17) - dragSpotX, WindowInfo(win, 18) - dragSpotY
	--		  local changedX, changedY = vars.pos_x - previousX, vars.pos_y - previousY
	-- saveVar is where the new x and y positions are saved, usually vars, but can be elsewhere
	
	local currentRect = {x1 = WindowInfo(currentWindow, 10) + changedX, y1 = WindowInfo(currentWindow, 11) + changedY, x2 = WindowInfo(currentWindow, 12) + changedX, y2 = WindowInfo(currentWindow, 13) + changedY}
	local windows = WindowList()
	for i, v in ipairs(windows) do
		-- If miniwin is visible and we aren't checking the current miniwin
		if WindowInfo(v, 5) and v ~= currentWindow then
			local winRect = {x1 = WindowInfo(v, 10), y1 = WindowInfo(v, 11), x2 = WindowInfo(v, 12), y2 = WindowInfo(v, 13)}
			if rect.snappable(currentRect, winRect, saveVar) then
				local top, bottom, left, right = rect.snapEdge(currentRect, winRect, saveVar)
				
				if top then
					saveVar.pos_y = winRect.y1 - rect.height(currentRect)
				elseif bottom then
					saveVar.pos_y = winRect.y2
				elseif left then
					saveVar.pos_x = winRect.x1 - rect.width(currentRect)
				elseif right then
					saveVar.pos_x = winRect.x2
				end
			end
		end
	end
end
]]>
</script>
</muclient>
