<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Wednesday, September 09, 2015, 9:25 PM -->
<!-- MuClient version 4.93 -->

<!-- Plugin "Masaki_Million_Tracker" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Masaki_Million_Tracker"
   author="BluMalice"
   id="30c9b98364b6171349f04103"
   language="Lua"
   purpose="Displays count to million mobs killed over a period of time."
   save_state="y"
   date_written="2015-09-09 21:24:37"
   requires="4.63"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
<trigger
	name="millionCapture"
	match="^Mob Deaths       :.{16} (?<count>.+)$"
	regexp="y"
	omit_from_output="y"
	sequence="95"
	enabled="n"
	script="updateCount">
</trigger>
<trigger
	group="millionGag"
	match="^[\w\d\s:,]+$"
	regexp="y"
	omit_from_output="y"
	sequence="105"
	enabled="n">
</trigger>
<trigger
	group="millionGag"
	match="^\'Since added\' shows totals since 29th August 1997\.|                      \-\-\-\-\-\-\-\-\-\-\-\-       \-\-\-\-\-\-\-\-\-\-\-|                      \-\-\-\-\-\-\-\-\-\-\-\-       \-\-\-\-\-\-\-\-\-\-\-\-$"
	regexp="y"
	omit_from_output="y"
	sequence="105"
	enabled="n">
</trigger>
<trigger
	name="millionEnable"
	match="-------------- AARDWOLF MUD ACTIVITY MONITOR ----------"
	omit_from_output="y"
	sequence="100"
	enabled="n"
	send_to="12">
	<send>
		EnableTrigger("millionCapture", true)
		EnableTriggerGroup("millionGag", true)
		EnableTrigger("millionDisable", true)
		EnableTrigger("millionEnable", false)
	</send>
</trigger>
<trigger
	name="millionDisable"
	match="-------------------------------------------------------"
	omit_from_output="y"
	sequence="100"
	enabled="n"
	send_to="12">
	<send>
		disableCount = disableCount + 1
		if disableCount >= 2 then
			disableCount = 0
			EnableTriggerGroup("millionGag", false)
			EnableTrigger("millionDisable", false)
			EnableTrigger("millionCapture", false)
		end
	</send>
</trigger>
</triggers>

<!--  Aliases  -->

<aliases>
<alias
	match="^mmillion min(?:i|im|imi|imiz|imize)$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		vars.minimize = not vars.minimize
		redraw()
	</send>
</alias>
<alias
	match="^mmillion setfont$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95"
	script="setFontSize">
</alias>
<alias
	match="^mmillion show$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		closeToggle()
	</send>
</alias>
<alias
	match="^mmillion help$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95"
	script="showHelp">
</alias>
<alias
	match="^mmillion frequency (?<hours>[\d]+)$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		vars.millionTimer = tonumber("%1")
		SetTimerOption("millionTimer", "hour", "%1")
		ColourNote("lime", "black", "New million frequency : h" .. vars.millionTimer)
	</send>
</alias>
<alias
	match="^mmillion check$"
	regexp="y"
	enabled="y"
	echo_alias="n"
	send_to="12"
	sequence="95">
	<send>
		EnableTrigger("millionEnable", true)
		SendNoEcho("gamestat 5")
	</send>
</alias>
</aliases>

<timers>
<timer
	name="millionTimer"
	hour="1"
	enabled="y"
	send_to="12">
	<send>
		EnableTrigger("millionEnable", true)
		SendNoEcho("gamestat 5")
	</send>
</timer>
</timers>

<script>
<![CDATA[
--[[ ================================================================== 
     =                           INITIALIZE                           = 
     ================================================================== ]]

require "serialize"

-- Default variables
win = "Masaki_ Million_Tracker" .. GetPluginID()
icon = GetPluginInfo(GetPluginID(), 20) .. "Masaki2.png"
vars = {}

-- Saved variables
vars.defaultFont = "defaultFont"
vars.defaultFontFamily = "Consolas"
vars.header = {}
vars.fontSize = 12
vars.fontHeight = 8
vars.winLeft = 0
vars.winTop = 0
vars.winRight = 200
vars.winBottom = 200
vars.winHeight = 2
vars.pos_x = 495
vars.pos_y = 322
vars.show = true
vars.minimize = false
vars.snapSize = 10
vars.millionTimer = 1

-- Activity variables
dragSpot = nil
disableCount = 0
millionCount = 0

function OnPluginInstall()
	-- Restore saved states
	assert(loadstring(GetVariable("vars") or ""))()
	vars = vars or {}
	
	-- Refresh all states if changes or updates were added
	if vars.show == nil or vars.minimize == nil or vars.defaultFontFamily ~= "Consolas" or
	   vars.snapSize == nil or vars.millionTimer == nil then
	   
		vars.defaultFont = vars.defaultFont or "defaultFont"
		vars.defaultFontFamily = vars.defaultFontFamily or "Consolas"
		vars.header = {}
		vars.fontSize = vars.fontSize or 12
		vars.fontHeight = vars.fontHeight or 8
		vars.winLeft = vars.winLeft or 0
		vars.winTop = vars.winTop or 0
		vars.winRight = vars.winRight or 200
		vars.winBottom = vars.winBottom or 200
		vars.winHeight = vars.winHeight or 2
		vars.pos_x = vars.pos_x or 495
		vars.pos_y = vars.pos_y or 322
		vars.show = vars.show or true
		vars.minimize = vars.minimize or false
		vars.snapSize = vars.snapSize or 10
		vars.millionTimer = vars.millionTimer or 1
	end
	
	-- Set timer frequency
	SetTimerOption("millionTimer", "hour", tostring(vars.millionTimer))
	
	-- Prepare miniwin header
	if #vars.header == 0 then
		vars.header = {}
		table.insert(vars.header, {text = "{-=", textcolour = ColourNameToRGB("dimgray")})
		table.insert(vars.header, {text = "Million", textcolour = ColourNameToRGB("darkred")})
		table.insert(vars.header, {text = "=-} ", textcolour = ColourNameToRGB("dimgray")})
	end
	
	-- Load miniwin and its properties
	WindowCreate(win, vars.winLeft, vars.winTop, vars.winRight, vars.winBottom, miniwin.pos_center_all, miniwin.create_keep_hotspots, ColourNameToRGB("black"))
	WindowFont(win, vars.defaultFont, vars.defaultFontFamily, vars.fontSize, false, false, false, false, 1, 0)
	WindowLoadImage(win, "icon", icon)
	
	-- Draw basic miniwin
	vars.fontHeight = WindowFontInfo(win, vars.defaultFont, 1)
	vars.winRight = textWidth(vars.header[1].text .. vars.header[2].text .. vars.header[3].text) + 25
	vars.winBottom = vars.winHeight * vars.fontHeight
	resize()
	WindowSetZOrder(win, 500)
	drawDefaults(true)
	WindowShow(win, vars.show)
	WindowPosition(win, vars.pos_x, vars.pos_y, 
                 miniwin.pos_stretch_to_view, 
                 miniwin.create_absolute_location)
		
	-- Final touches to the loading sequence
	showHelp()
end

function OnPluginSaveState()
	SetVariable("vars", serialize.save("vars"))
end

function showHelp()
	ColourNote("lime", "black", "+----------------{-=Masaki Million Tracker=-}----------------+")
	ColourNote("lime", "black", "|".. centerText("This tracks the count till the next million", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("mobs have been killed over a specified hour", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("period.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("{-=Commands=-}", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   mmillion check   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Check the hour count now", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   mmillion frequency <hours   *>", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Sets how frequent the million count should", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("be checked in hours.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   mmillion setfont   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Sets new font size for miniwin.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   mmillion minimize   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Minimizes or restores miniwin.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   mmillion show   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Shows or hides miniwin.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("*   mmillion help   *", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("Displays this message.", 60) ..  "|")
	ColourNote("lime", "black", "|".. centerText("", 60) ..  "|")
	ColourNote("lime", "black", "+----------------{-=Masaki Million Tracker=-}----------------+")
end

--[[ ================================================================== 
     =                      MINIWIN UTILITIES                         = 
     ================================================================== ]]
	 
function dragmove(flags, hotspot_id)
	local previousX, previousY = vars.pos_x, vars.pos_y
	
	if not dragSpot then
		vars.pos_x, vars.pos_y = WindowInfo (win, 17) - WindowInfo(win, 14), WindowInfo (win, 18) - 5
		dragSpot = WindowInfo(win, 14)
	else
		vars.pos_x, vars.pos_y = WindowInfo (win, 17) - dragSpot, WindowInfo (win, 18) - 5
	end
	
	local changedX, changedY = vars.pos_x - previousX, vars.pos_y - previousY
	snap(win, changedX, changedY, vars)

	WindowPosition(win, vars.pos_x, vars.pos_y, 
				   miniwin.pos_stretch_to_view, 
                   miniwin.create_absolute_location)
end

function dragrelease(flags, hotspot_id)
	dragSpot = nil
end

function showWindow(show)
	-- Utility function, shows or hides the miniwin.
	
	WindowShow(win, show)
end

function redraw()
	-- Utility function, redraws the miniwin.
	
	resize()
	drawDefaults(true)
	showWindow(vars.show)
end

function resize()
	-- Utility function, resizes the miniwin.
	
	if not vars.minimize then
		WindowResize(win, vars.winRight, vars.winHeight * vars.fontHeight, ColourNameToRGB("black"))
	else
		WindowResize(win, vars.winRight, vars.fontHeight, ColourNameToRGB("black"))
	end
end

function textWidth(text)
	-- Utility function, returns the total width the given text requires within the miniwin.
	
	return WindowTextWidth(win, vars.defaultFont, text)
end

function drawDefaults(refreshHotspots)
	-- Utility function, draws the default layout of the miniwin.
	
	-- Clear miniwin
	WindowRectOp(win, miniwin.rect_fill, 0, 0, 0, 0, ColourNameToRGB("black"))

	-- Miniwin background and outline
	WindowRectOp(win, miniwin.rect_fill, 0, 0, vars.winRight, vars.fontHeight, ColourNameToRGB("black"))
	WindowRectOp(win, miniwin.rect_3d_rect, 0, 0, vars.winRight, 0, ColourNameToRGB("crimson"), ColourNameToRGB("red"))
	
	-- Seperator for header
	WindowRectOp(win, miniwin.rect_3d_rect, 0, 0, vars.winRight, vars.fontHeight, ColourNameToRGB("crimson"), ColourNameToRGB("red"))
	
	drawText("", 0, 25, vars.header)
	
	-- Draw million count
	WindowText(win, vars.defaultFont, millionCount, (vars.winRight / 2) - (textWidth(millionCount) / 2), vars.fontHeight - 1, 0, 0, ColourNameToRGB("white"), true)
	
	if refreshHotspots then
		WindowDeleteAllHotspots(win)
			
		-- Drag hotspot for header
		WindowAddHotspot(win, "DragArea", vars.fontHeight, 0, vars.winRight, vars.fontHeight, "", "", "", "", "", vars.headerhint, miniwin.cursor_both_arrow, 0)
		WindowDragHandler(win, "DragArea", "dragmove", "dragrelease", 0)
	end
	
	-- Minimize and close button
	WindowRectOp(win, miniwin.rect_fill, 5, 4, vars.fontSize * 1.42, vars.fontSize * 1.16, ColourNameToRGB("black"))
	WindowTransformImage(win, "icon", 5 + (vars.minimize and 2 + ((vars.fontSize - 6) * 1.5)  or 0), 4 + (vars.minimize and 2 + ((vars.fontSize - 6)) or 0), miniwin.image_copy, ((vars.fontSize * 1.42 - 5) / 50) * (vars.minimize and -1 or 1), 0, 0, ((vars.fontSize * 1.16 - 4) / 50) * (vars.minimize and -1 or 1))
	if refreshHotspots then
		WindowAddHotspot(win, "ToggleArea", 5, 4, vars.fontSize * 1.42, vars.fontSize * 1.16, "", "", "", "", "toggleMiniwin", "{-=Left click to minimize : Right click to close=-}", miniwin.cursor_hand, 0)
	end
end

function updateCount(name, line, wildcards, styles)
	-- Refreshes miniwin with new million count
	
	millionCount = Trim(wildcards.count)
	redraw()
end

function drawText(text, top, l, styles)
	-- Utility function, draws text into the miniwin.

	local left = l
	if styles ~= nil then
		for i, v in ipairs(styles) do
			left = left + WindowText(win, vars.defaultFont, v.text, left, top * vars.fontHeight - 1, 0, 0, v.textcolour, true)
		end
	end
end

function toggleMiniwin(flags, hotspot_id)
	-- Utility function, toggles miniwin sizes.
	
	if flags == miniwin.hotspot_got_rh_mouse then
		closeToggle()
	elseif flags == miniwin.hotspot_got_lh_mouse then
		vars.minimize = not vars.minimize
		redraw()
	end
end

function setFontSize()
	-- Sets new font size for miniwin.

	local size = utils.inputbox("Enter new font size : ", "{-=Masaki Million Tracker=-}", tostring(vars.fontSize), vars.defaultFontFamily, vars.fontSize)
	vars.fontSize = size or vars.fontSize
	WindowFont(win, vars.defaultFont, vars.defaultFontFamily, vars.fontSize, false, false, false, false, 1, 0)
	vars.fontHeight = WindowFontInfo(win, vars.defaultFont, 1)
	redraw()
end

function closeToggle()
	-- Utility function, displays or hides miniwin.
	
	vars.show = not vars.show
	showWindow(vars.show)
end

function OnPluginClose()
	WindowDelete(win)
end

function OnPluginDisable()
	showWindow(false)
end

function OnPluginEnable()
	showWindow(true)
end

--[[ +----------------------------------------------------------------+ 
     |                       MISC UTILITIES                           | 
     +----------------------------------------------------------------+ ]]

function centerText(text, width)
	-- Wraps text into the center of the specified width.

	local length = width - #text
	if length > 0 then
		text = string.rep(" ", math.floor(length / 2)) .. text .. string.rep(" ", math.floor(length / 2))
	end
	
	return #text == width and text or text .. " "
end

--[[ ================================================================== 
     =                       MINIWIN SNAP CLASS                       = 
     ================================================================== ]]

rect = {}

rect.intersects = function(r1, r2)
	local rw, rh, tw, th = rect.width(r2) + r2.x1, rect.height(r2) + r2.y1, rect.width(r1) + r1.x1, rect.height(r1) + r1.y1
	return ((rw < r2.x1 or rw > r1.x1) and
            (rh < r2.y1 or rh > r1.y1) and
            (tw < r1.x1 or tw > r2.x1) and
            (th < r1.y1 or th > r2.y1))
end

rect.width = function(r1)
	return math.abs(r1.x2 - r1.x1)
end

rect.height = function(r1)
	return math.abs(r1.y2 - r1.y1)
end

rect.snappable = function(r1, r2, saveVar)
	-- The idea here is to create inner and outer shells of the second rect,
	-- then check if the first rect intersects with the outer shell but not
	-- with the inner shell. If this is true, then the first rect can snap
	-- to the second rect.
	
	local outerr2 = {x1 = r2.x1 - (saveVar.snapSize or 10), y1 = r2.y1 - (saveVar.snapSize or 10), x2 = r2.x2 + (saveVar.snapSize or 10), y2 = r2.y2 + (saveVar.snapSize or 10)}
	local innerr2 = {x1 = r2.x1 + (saveVar.snapSize or 10), y1 = r2.y1 + (saveVar.snapSize or 10), x2 = r2.x2 - (saveVar.snapSize or 10), y2 = r2.y2 - (saveVar.snapSize or 10)}
	return rect.intersects(r1, outerr2) and not rect.intersects(r1, innerr2)
end

rect.snapEdge = function(r1, r2, saveVar)
	-- What happens here is the second rect gets separated
	-- into four pieces, one for each side. We then check
	-- which piece intersects with the first rect, and
	-- the piece that intersects will then be the snap edge.
	local top = {x1 = r2.x1, y1 = r2.y1 - (saveVar.snapSize or 10), x2 = r2.x2, y2 = r2.y1 + (saveVar.snapSize or 10)}
	local bottom = {x1 = r2.x1, y1 = r2.y2 - (saveVar.snapSize or 10), x2 = r2.x2, y2 = r2.y2 + (saveVar.snapSize or 10)}
	local left = {x1 = r2.x1 - (saveVar.snapSize or 10), y1 = r2.y1, x2 = r2.x1 + (saveVar.snapSize or 10), y2 = r2.y2}
	local right = {x1 = r2.x2 - (saveVar.snapSize or 10), y1 = r2.y1, x2 = r2.x2 + (saveVar.snapSize or 10), y2 = r2.y2}
	return rect.intersects(r1, top) and r1.y2 <= r2.y1, rect.intersects(r1, bottom) and r1.y1 >= r2.y2, rect.intersects(r1, left) and r1.x2 <= r2.x1, rect.intersects(r1, right) and r1.x1 >= r2.x2
end

function snap(currentWindow, changedX, changedY, saveVar)
	-- Attempt to snap miniwin to other miniwins
	-- currentWindow is the dragged window ID
	-- changedX and changedY is the difference the previous window position and the current window position
	--    eg: local previousX, previousY = vars.pos_x, vars.pos_y
	--		  vars.pos_x, vars.pos_y = WindowInfo(win, 17) - dragSpotX, WindowInfo(win, 18) - dragSpotY
	--		  local changedX, changedY = vars.pos_x - previousX, vars.pos_y - previousY
	-- saveVar is where the new x and y positions are saved, usually vars, but can be elsewhere
	
	local currentRect = {x1 = WindowInfo(currentWindow, 10) + changedX, y1 = WindowInfo(currentWindow, 11) + changedY, x2 = WindowInfo(currentWindow, 12) + changedX, y2 = WindowInfo(currentWindow, 13) + changedY}
	local windows = WindowList()
	for i, v in ipairs(windows) do
		-- If miniwin is visible and we aren't checking the current miniwin
		if WindowInfo(v, 5) and v ~= currentWindow then
			local winRect = {x1 = WindowInfo(v, 10), y1 = WindowInfo(v, 11), x2 = WindowInfo(v, 12), y2 = WindowInfo(v, 13)}
			if rect.snappable(currentRect, winRect, saveVar) then
				local top, bottom, left, right = rect.snapEdge(currentRect, winRect, saveVar)
				
				if top then
					saveVar.pos_y = winRect.y1 - rect.height(currentRect)
				elseif bottom then
					saveVar.pos_y = winRect.y2
				elseif left then
					saveVar.pos_x = winRect.x1 - rect.width(currentRect)
				elseif right then
					saveVar.pos_x = winRect.x2
				end
			end
		end
	end
end
]]>
</script>
</muclient>
