<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, July 14, 2018, 10:13 AM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "Bypass" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Bypass"
   author="Durel"
   id="a5801dd9fdc21eacba8efcb0"
   language="Lua"
   purpose="Bypass crappy areas because you are an awesome Navi"
   save_state="y"
   date_written="2018-07-14 10:10:01"
   requires="5.06"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<!--  Aliases  -->

<aliases>
  <alias
   match="^[ ]*bp[ ]+(on|off|reset|edit|display|version|help)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  local mode = Trim("%1") or "nil"

  if (mode == "on") then
    bp.on()
  elseif (mode == "off") then
    bp.off()
  elseif (mode == "reset") then
    bp.reset()
  elseif (mode == "edit") then
    bp.edit()
  elseif (mode == "display") then
    bp.display()
  elseif (mode == "version") then
    bp.version()
  elseif (mode == "help") then
    bp.help()
  else
    bp.print("Unknown mode " .. mode)
  end -- if</send>
  </alias>
  
  <alias
   match="^[ ]*bp[ ]+commlog[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>bp.commlogSet("%1")</send>
  </alias>
  
  <alias
   match="^[ ]*bp[ ]+update([ ]+[^ ]+)?[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>bp.update(Trim("%1"), true)</send>
  </alias>
  
  <alias
   match="^[ ]*bp(|[ ]+.*)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="1000"
  >
  <send>bp.help()</send>
  </alias>


</aliases>

<!--  Script  -->


<script>
<![CDATA[


----------------------------------------------------------------------------------------------------------
-- Dependencies
----------------------------------------------------------------------------------------------------------

require "gmcphelper"
require "serialize"
require "wait"
require "check"
require "tprint"

dofile(GetInfo(60) .. "aardwolf_colors.lua")


----------------------------------------------------------------------------------------------------------
-- Global vars and tables
----------------------------------------------------------------------------------------------------------

bp = {}

bp.name = "BP"
bp.ver  = "0.1.2"

bp.bypassTable = {}


----------------------------------------------------------------------------------------------------------
-- MUSH callbacks and hooks
----------------------------------------------------------------------------------------------------------

function OnPluginInstall()
  bp.init()
end -- OnPluginInstall


function OnPluginClose()
  bp.fini()
end -- OnPluginClose


function OnPluginConnect()
  --bp.print("OnPluginConnect!")
end -- OnPluginConnect


function OnPluginDisconnect()
  --bp.print("OnPluginDisconnect!")
end -- OnPluginDisconnect


function OnPluginEnable()
  --bp.print("OnPluginEnable!")
  bp.print("@GENABLED@W")
end -- OnPluginEnable


function OnPluginDisable()
  --bp.print("OnPluginDisable!")
  bp.print("@RENABLED@W")
end -- OnPluginDisable


----------------------------------------------------------------------------------------------------------
-- Plugin init/de-init
----------------------------------------------------------------------------------------------------------

bpTriggerOnLevelName     = "bpTriggerOnLevel"
bpTriggerOnSuperheroName = "bpTriggerOnSuperhero"
bpTriggerOnRemortName    = "bpTriggerOnRemort"

function bp.init()
  -- Add a trigger to detect when we level
  AddTriggerEx(bpTriggerOnLevelName,
               "^You raise a level! You are now level ([0-9]+).$",
               "bp.update(\"%1\", false)",
               trigger_flag.RegularExpression + trigger_flag.Replace,
	           custom_colour.Custom11, 0, "", "", sendto.script, 0)

  -- Add a trigger to detect when we hit 201 as a superhero
  AddTriggerEx(bpTriggerOnSuperheroName,
               "^Congratulations! You are now a superhero!$",
               "bp.update(\"201\", false)",
               trigger_flag.RegularExpression + trigger_flag.Replace,
	           custom_colour.Custom11, 0, "", "", sendto.script, 0)

  -- Add a trigger to detect when we remort back to level 1
  AddTriggerEx(bpTriggerOnRemortName,
               "^\\* Remort transformation complete!$",
               "bp.update(\"1\", false)",
               trigger_flag.RegularExpression + trigger_flag.Replace,
	           custom_colour.Custom11, 0, "", "", sendto.script, 0)


  -- If auto-bypass is enabled, enable the triggers
  bp.triggerEnable(bp.isEnabled())

  -- Load the areas we should bypass (or the defaults if this hasn't been set yet)
  bp.loadBypassTable()

  -- Display the helpfile when the plugin loads
  bp.help()

end -- bp.init


function bp.triggerEnable(value)
  EnableTrigger(bpTriggerOnLevelName,     value)
  EnableTrigger(bpTriggerOnSuperheroName, value)
  EnableTrigger(bpTriggerOnRemortName,    value)
end -- bp.triggerEnable


function bp.fini()
  -- placeholder for now...
end -- bp.fini


----------------------------------------------------------------------------------------------------------
-- Plugin modes
----------------------------------------------------------------------------------------------------------

function bp.on()
  SetVariable("bpEnabled", "on")
  bp.triggerEnable(true)
  bp.print("Area auto-bypass is @GENABLED@w")
end -- bp.on


function bp.off()
  SetVariable("bpEnabled", "off")
  bp.triggerEnable(false)
  bp.print("Area auto-bypass is @RDISABLED@w")
end -- bp.off


function bp.isEnabled()
  local enableVal = GetVariable("bpEnabled")
  if (enableVal == "on") then
    return true
  else
    return false
  end -- if
end -- bp.isEnabled


function bp.saveBypassTable()
  if (bp.bypassTable == nil) then
    bp.reset()
  end -- if

  SetVariable("bpBypassTable", serialize.save("bp.bypassTable", bp.bypassTable))
end -- bp.saveBypassTable


function bp.loadBypassTable()
  local serializedTable = GetVariable("bpBypassTable")

  if (serializedTable == nil) or (serializedTable == "") then
    bp.print("Bypass table not found: using default values")
    bp.reset()
    bp.saveBypassTable()
  else
    loadstring(serializedTable)()
  end -- if

end -- bp.loadBypassTable


function bp.reset()

  bp.bypassTable = {
    {   1, "gauntlet",         "chessboard",       "",                 "" },
    {  15, "gauntlet",         "kultiras",         "",                 "" },
    {  25, "gauntlet",         "maelstrom",        "",                 "" },
    {  30, "verume",           "maelstrom",        "",                 "" },
    {  40, "zangar",           "maelstrom",        "",                 "" },
    {  45, "zangar",           "goldrush",         "",                 "" },
    {  50, "zangar",           "citadel",          "",                 "" },
    {  60, "uplanes",          "citadel",          "",                 "" },
    {  70, "lplanes",          "uplanes",          "",                 "" },
    { 100, "xylmos",           "damned",           "",                 "" },
    { 115, "xylmos",           "deathtrap",        "",                 "" },
    { 120, "talsa",            "deathtrap",        "",                 "" },
    { 130, "ftii",             "horath",           "",                 "" },
    { 140, "ftii",             "cougarian",        "",                 "" },
    { 150, "cougarian",        "cataclysm",        "sahuagin",         "" },
    { 160, "helegear",         "cougarian",        "cataclysm",        "" },
    { 175, "deadlights",       "helegear",         "cataclysm",        "" },
    { 180, "partroxis",        "ninehells",        "deadlights",       "" },
    { 201, "partroxis",        "ninehells",        "deadlights",       "wyrm" }
  }

  bp.saveBypassTable()

  bp.print("Reset bypassed areas to default values")
end -- bp.reset


function bp.update(requestedLevel, doForce)

  local status = gmcp("char.status")
  local stats = gmcp("char.stats")
  local char = gmcp("char.base")
  if (status == nil) or (stats == nil) or (char == nil) or (char.subclass ~= "Navigator") then
    return
  end -- if

  if (bp.bypassTable == nil) then
    bp.error("bp.update: Bypass table is missing!")
    return
  end -- if

  -- If the caller supplied a level, use it.  Otherwise, use the char's current level.
  local charLevel = tonumber(requestedLevel or "") or tonumber(status.level or "") or 0

  local bestEntry = nil
  for i,entry in ipairs(bp.bypassTable) do
    local level = tonumber(entry[1] or "") or -1

    if (charLevel < level) then
      break
    else
      bestEntry = entry
    end -- if

  end -- for

  if (bestEntry == nil) then
    bp.error("Failed to update bypassed areas, no areas are defined for level " .. charLevel)
    return
  end -- if

  -- Skip the bypass if we aren't right on a bypass level threshold and the caller didn't not request one
  if (charLevel ~= tonumber(bestEntry[1] or "")) and (not doForce) then
    return
  end -- if

  local int = tonumber(stats.int or "") or 0
  local wis = tonumber(stats.wis or "") or 0

  local endMsg = "(@G" .. charLevel .. "@w) Bypassed"
  local colorToggle = " @c"

  Execute("bypass clear")
  for i,field in ipairs(bestEntry) do
    if (field == nil) then
      bp.error("bp.update: Missing field for entry " .. i)
    elseif (i == 1) or (field == "") then
      -- Nothing to do, this field isn't defined
    elseif (i == 4) and (int + wis < 600) then
      bp.print("@YSKIP@w: Skipping bypass for area \"@c" .. field .. "@w\" because int + wis < 600")
    elseif (i == 5) and (int + wis < 1200) then
      bp.print("@YSKIP@w: Skipping bypass for area \"@c" .. field .. "@w\" because int + wis < 1200")
    else
      Execute("bypass " .. field)
      endMsg = endMsg .. colorToggle .. field
      if (colorToggle == " @c") then
        colorToggle = " @C"
      else
        colorToggle = " @c"
      end -- if
    end -- if
  end -- for

  bp.print(endMsg)

end -- bp.update


function bp.tableToString()
  local str = ""

  if (bp.bypassTable == nil) then
    bp.error("bp.tableToString: Bypass table is missing!")

  else
    for i,entry in ipairs(bp.bypassTable) do
      if (entry ~= nil) then
        str = str .. string.format("%03d, %-15s, %-15s, %-15s, %-15s\n", entry[1], (entry[2] or ""),
                                   (entry[3] or ""), (entry[4] or ""), (entry[5] or ""))
      end -- if
    end -- for

  end -- if

  return str
end -- bp.tableToString


function bp.stringToTable(string)
  if (string == nil) or (string == "") then
    bp.error("bp.stringToTable: Missing string parameter!")
    return
  end -- if

  local newTab = nil

  local lines = utils.split(string, "\n")

  for i, line in ipairs(lines) do
    -- Remove any color codes and comments.  This makes parsing everything much simpler.
    lines[i] = string.gsub(strip_colours(line), ":.*$", "")

    local fields = utils.split(line, ",")

    if (#fields > 1) then
      local newEntry = {}
      for j,field in ipairs(fields) do
        newEntry[j] = Trim(field or "")
      end -- for

      if (newTab == nil) then
        newTab = {}
      end -- if

      table.insert(newTab, newEntry)
    end -- if
  end -- for

  if (newTab ~= nil) then
    bp.bypassTable = newTab
    return 0
  else
    return 1
  end -- if
  
end -- bp.stringToTable


function bp.edit()
  local bpString = bp.tableToString()

  local instructions =
[[Edit your preferred areas to bypass.  The first column is the level at which to start bypassing.  The subsequent columns are the keywords for areas you wish to bypass at the specified level range.
]]

  local fontSize = 10
  local fontName = GetAlphaOption("output_font_name")
  if (fontName == nil) then
    fontName = "Consolas"
  end -- if

  local retval = 0

  repeat
    bpString = utils.editbox(instructions,
                             "BP: Editing areas to bypass",
                             bpString,                  -- default text
                             fontName,                  -- font
                             fontSize,                  -- font size
                             { ok_button = "Done!" })   -- extras

    if (bpString == nil) then
      bp.print("Cancelled request to edit areas to bypass")
      retval = 0
      break   

    else
      retval = bp.stringToTable(bpString)
      if (retval == 0) then
        bp.saveBypassTable()        
        bp.display()
        bp.update(nil, true)
      end -- if

    end -- if

  until (retval == 0)

end -- bp.edit


function bp.display()
  if (bp.bypassTable == nil) then
    bp.error("bp.display: Area bypass table is missing!")
    return
  end -- if

  local line = "@WArea bypass table@w\n"
  line = line .. "@x39----------------------------------------------------------------------------\n"
  line = line .. "@WLvl @x39|@W Bypass 2 areas with any Int & Wis @x39|@W Int+Wis >= 600 @x39 |@W Int+Wis == 1200\n"
  line = line .. "@x39----------------------------------------------------------------------------\n"

  for i,entry in ipairs(bp.bypassTable) do
    local level = tonumber(entry[1] or "") or -1
    local area1 = entry[2] or ""
    local area2 = entry[3] or ""
    local area3 = entry[4] or ""
    local area4 = entry[5] or ""

    line = line .. string.format("@W%03d @x39|@c %-15s @x39|@C %-15s @x39|@c %-15s @x39|@C %-15s\n",
                                 level, area1, area2, area3, area4, area5)
  end -- for

  bp.print(line)

end -- bp.display


function bp.version()
  bp.print("Version " .. bp.ver)
end -- bp.version


function bp.help()

bp.printColors([[
@x039----------------------------------------------------------------------------@w
@x173BP: @x202Automatically bypass areas because you are an awesome navigator
@x039----------------------------------------------------------------------------@w

    @wbp@W [on|off]         @x173-- Enable or disable automatic bypass each level
    @wbp@W display          @x173-- Display the areas to be bypassed at each level
    @wbp@W edit             @x173-- Edit which areas to bypass for each level
    @wbp@W update           @x173-- Manually bypass areas for your current level

    @wbp@W reset            @x173-- Reset bypassed areas to the default settings
    @wbp@W commlog [on|off] @x173-- Mirror messages to the commlog@w
    @wbp@W version          @x173-- Report the current version of this plugin
    @wbp@W help             @x173-- Display the usage you're reading right now...

@x039----------------------------------------------------------------------------@w
]])

end -- bp.help


----------------------------------------------------------------------------------------------------------
-- Commlog access
----------------------------------------------------------------------------------------------------------

function bp.commlogSet(enable)
  if (enable ~= "on") and (enable ~= "off") then
    bp.error("bp.commlogSet: invalid commlog mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("commlogState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  bp.print("Mirroring to communication log is " .. msg)

end -- bp.commlog


function bp.commlogGet()
  return (GetVariable("commlogState") or "")
end -- bp.commlogGet


----------------------------------------------------------------------------------------------------------
-- Core helper functions
----------------------------------------------------------------------------------------------------------

function bp.printFormat(msg)
  local formattedMsg = ""

  if (msg ~= nil) and (msg ~= "") then

    local outerColor = "@x39"
    local innerColor = "@x173"

    formattedMsg = outerColor .. "[" .. innerColor .. bp.name .. outerColor .. "]@w " .. msg .. "@w"
  end -- if

  return formattedMsg
end -- bp.printFormat


function bp.printColors(msg)
  print(AnsiNote(stylesToANSI(ColoursToStyles(msg))))
end -- bp.printColors


function bp.print(msg)
  if (msg ~= nil) and (msg ~= "") then
    local formattedMsg = bp.printFormat(msg)
    bp.printColors(formattedMsg)

    -- If the user wants us to mirror messages to the commlog, do it :)
    local commlogState = bp.commlogGet()
    if (commlogState == "on") then
      bp.commLog(formattedMsg)
    end -- if
  end -- if

end -- bp.print()


function bp.error(msg)
  if (msg ~= nil) and (msg ~= "") then
    bp.print("@RERROR@w " .. msg)
  end -- if
end -- bp.error


function bp.commLog(msg)
  local clPlugin   = "b555825a4a5700c35fa80780"
  local clFunction = "storeFromOutside"

  if (msg == nil) or (msg == "") then
    print("bp.commLog: Missing message parameter")
    return error_code.eBadParameter
  end -- if

  local retval = CallPlugin(clPlugin, clFunction, msg)

  if (retval == error_code.eNoSuchPlugin) then
    print("bp.commLog: target plugin does not exist")

  elseif (retval == error_code.ePluginDisabled) then
    print("bp.commLog: target plugin is disabled")

  elseif (retval == error_code.eNoSuchRoutine) then
    print("bp.commLog: target routine does not exist")

  elseif (retval == error_code.eErrorCallingPluginRoutine) then
    print("bp.commLog: error calling plugin routine")

  elseif (retval ~= error_code.eOK) then
    print("bp.commLog: Unknown return value from CallPlugin: " .. (retval or "nil"))

  end -- if

  return retval
end -- bp.commLog


]]>
</script>


</muclient>
