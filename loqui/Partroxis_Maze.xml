<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, January 25, 2013, 5:28 PM -->
<!-- MuClient version 4.84 -->

<!-- Plugin "Partroxis_maze" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Partroxis_Maze"
   author="Littleman_n_Nok3"
   id="96ec6364cd4cc09df780773b"
   language="Lua"
   purpose="Script helps navigating the nasty partroxis maze"
   save_state="y"
   date_written="2013-01-25 17:24:31"
   requires="4.84"
   version="2.1"
   >
   <description trim="n">
		<![CDATA[
==================== Partroxis Maze Help ====================
pm <mob>(optional)       - Lists the rooms and mobs
                           Optional parameter for highlighting matching mobs

pm go <room>(optional)   - Runs to the last solved room ove the maze
                           Optional parameter to run to a specific room if it has been solved
						   
pm reset                 - Resets the solved path
	]]>
	</description>

</plugin>
<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->
<triggers>	
	<trigger name="exited_maze"
		match="^The Cheryb Sitter says 'Now, as I promised, I will lead you out of the Otherworld\.'$"
		enabled="y" regexp="y" send_to="12"		
		script="Reset"	
	>
	</trigger>
	
	<trigger name="repop"
		match="^The Partroxis has opened yet again\.$"
		enabled="y" regexp="y" send_to="12"		
		script="Reset"	
	>
	</trigger>
	
	<trigger name="tag_gags"
		match="^{/?scan}$"
		regexp="y" enabled="y"
		omit_from_output="y"
		sequence="200"
	>
	</trigger>

	<trigger name="scan_start"
		match="^{scan}$"
		enabled="n" regexp="y" send_to="12"
		omit_from_output="y"
		script="ScanStart"	sequence="100"	
	>
	</trigger>

	<trigger name="gag_scan_extra"
		match="^(2|3) (North|East|South|West|Up|Down) from here you see:$"
		enabled="n" regexp="y" send_to="12"
		omit_from_output="y"
		script="GagScanExtra"		
	>
	</trigger>
	
	<trigger name="gag_scan_mobs"
		match="^     - .*"		
		enabled="n" regexp="y"
		omit_from_output="y"			
	>
	</trigger>
	
	<trigger name="scan_stop"
		match="^{/scan}$"
		enabled="n" regexp="y" send_to="12"
		omit_from_output="y"
		script="ScanStop" sequence="100"	
	>
	</trigger>
	
	<trigger name="exits_start"
		match="^Obvious exits from \[ .* \]:$"
		enabled="n" regexp="y" send_to="12"
		omit_from_output="n"
		script="ExitsStart"	
	>
	</trigger>
</triggers>

<!--  Aliases  -->

<aliases>
	<alias name="help"
		regexp="y" match="^pm help$"
		send_to="12" script="Help"
		enabled="y"
		sequence="100"
	>
	</alias>

	<alias name="reset"
		regexp="y" match="^pm reset$"
		send_to="12" script="Reset"
		enabled="y"
		sequence="100"
	>
	</alias>

	<alias name="show_room"
		regexp="y" match="^pm room$"
		send_to="12" script="ShowRoom"
		enabled="y"
		sequence="100"
	>
	</alias>

	<alias name="show_path"
		regexp="y" match="^pm show$"
		send_to="12" script="ShowPath"
		enabled="y"
		sequence="100"
	>
	</alias>
	
	<alias name="track_movement"
		regexp="y" match="^(no?r?t?h?|ea?s?t?|so?u?t?h?|we?s?t?|up?|do?w?n?)$"
		send_to="12" script="TrackMovement"
		enabled="n" ignore_case="y"
	>
	</alias>
	
	<alias name="go"
		regexp="y" match="^pm go( [0-9]+)?$"
		send_to="12" script="Go"
		enabled="y"
		sequence="100"
	>
	</alias>	
	
	<alias name="mob_search"
		match="^pm( .*)?$"
		enabled="y" regexp="y"
		send_to="12" script="SearchMobs"   
		sequence="200"
	>  
	</alias>
</aliases>

<script>
<![CDATA[
	local rooms = {
		[1] = { name="In the Mountains", mob="Mountain of Rock" },
		[2] = { name="Through the Woods", mob="Rabid Tiger Men" },
		[3] = { name="The Forest", mob="The Man Eating Wolfen" },
		[4] = { name="Swampy Path", mob="Buck-Toothed Lizardman", scan="y" }, -- fake exit leads to 3
		[5] = { name="The Forest", mob="Living Tree" },
		[6] = { name="Along the River", mob="Flying Fish Men" },
		[7] = { name="The Desert", mob="Quicksand" },
		[8] = { name="The Desert", mob="The Flesh Eating Ants" },
		[9] = { name="The Wheat Fields", mob="Living Vines" },
		[10] = { name="In the Mountains", mob="Gigantic Bullette" },
		[11] = { name="In the Mountains", mob="Birds of Prey" },
		[12] = { name="A Cave", mob="The Otherworld Assassin", scan="y" }, -- fake exit leads to 9
		[13] = { name="The Wheat Fields", mob="Vision of the False Gate", scan="y" }, -- fake exit leads to 9
		[14] = { name="The Wheat Fields", mob="Hungry Dragon", custom="enter gate" }, -- enter gate
		[15] = { name="The Forest", mob="Blood Hungry Tigerman" },
		[16] = { name="The Swamp", mob="Cold-Hearted Lizardman" },
		[17] = { name="The Swamp", mob="Insany Patryn" },
		[18] = { name="River of Blood", mob="Flowing Blood" },
		[19] = { name="A small Cave", mob="Collapsing Cave" },
		[20] = { name="A small Cave", mob="Dream Eater" },
		[21] = { name="Through the Passage of Time", mob="Reality Check" },
		[22] = { name="The Swamp", mob="Bloodsucking Vines", scan="y" }, -- fake exit leads to 3
		[23] = { name="The Forest", mob="Golden Haired Assassin" },
		[24] = { name="The Wheat Fields", mob="Flying Body Parts", scan="y" }, -- fake exit leads to 9
		[25] = { name="The Wheat Fields", mob="Killer Gerbils" },
		[26] = { name="In the Mountains", mob="Monster Bullette", scan="y" }, -- Fake exit leads to 25
		[27] = { name="The Wheat Fields", mob="The Thing", scan="y" }, -- Fake exit leads to 6
		[28] = { name="Along the River", mob="Big and Deadly Dragon" }, -- fake exit leads to 27
		[29] = { name="The Wheat Field", mob="Soul of the Damned", custom="enter gate" }, -- enter gate
		[30] = { name="In the Mountains", mob="Lesser Chadryn", scan="y" }, -- fake exit leads to 11
		[31] = { name="In the Mountains", mob="Delusions of Hope" }, 
		[32] = { name="The Desert", mob="Blood Sucking Bio-Gnats", scan="y" }, -- fake exit leads to 16
		[33] = { name="The Swamp", mob="It", scan="y" }, -- fake exit leads to 32
		[34] = { name="The Desert", mob="Your Worst Nightmare" },
		[35] = { name="The Wheat Field", mob="Walking Suit of Armor", scan="y" }, -- fake exit leads to 12
		[36] = { name="A Cave", mob="Lesser Labryinth Dragon" },
		[37] = { name="A Cave", mob="Lesser Insane Patryn", scan="y" }, -- fake exit leads to 10
		[38] = { name="In the Mountains", mob="Labryinth Dragon" },
		[39] = { name="In the Mountains", mob="Hellhound Behemoths" },
		[40] = { name="A vast Expanse of Plains", mob="Chaodyn", custom="enter gate" }, -- Enter gate
	}
	
	local startId = 5764	
	
	local roomId = 0
	local lastRoom = 1
	local currentRoom = 1	
	local furthestRoom = 1
	local lastScanRoom = 0
	local lastScanRoomMove = ""
	local scanQueue = {}	
	local verifyMove = false
	local lastMove = ""
	local pathSoFar = {}
	local roomNotes = {}
	local delim = ";"
	local running = false
	local runningTo = 1
	
	function OnPluginInstall()
		Help()
	end
	
	function OnPluginBroadcast (msg, id, name, text)
		-- Look for GMCP handler.
		if (id == '3e7dedbe37e44942dd46d264') then
			if (text == "room.info") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info") --- We just want the gmcp.char section.
				luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.

				assert (loadstring (luastmt or "")) ()

				if (gmcpdata.zone == 'partroxis') then					
					roomId = tonumber(gmcpdata.num)

					if (roomId == 5763) then
						-- just before first room	
						SendNoEcho("open north")							
					elseif (roomId >= 5764 and roomId <= 5804) then
						lastRoom = currentRoom
						currentRoom = roomId - startId + 1
						
						if (not running) then
							-- solve the room
							if (verifyMove) then
								verifyMove = false
								if (currentRoom == lastRoom+1) then						
									pathSoFar[lastRoom] = lastMove
								else
									roomNotes[lastRoom] = "Not " .. string.upper(lastMove)
								end
							end
							
							if (currentRoom > furthestRoom) then furthestRoom = currentRoom end						
							
							SolveRoom()		
						else
							-- check to see if we are in the room we ran to
							if (currentRoom == runningTo) then
								running = false								
								SolveRoom()
							end
						end											
					end
				end
			elseif (text == "char.status") then
				if (running) then
					res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")				 
					luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.

					assert (loadstring (luastmt or "")) ()																						
										
					if (gmcpdata.state == "8") then
						running = false						
					end	
				end
			end
		end		   
	end -- onpluginbroadcast
	
	function Help()
		ColourNote("orange", "black", GetPluginInfo (GetPluginID (), 3))
	end
	
	function SearchMobs(name, line, wildcards)
		local search = ""
		if (wildcards[1] ~= nil and wildcards[1] ~= "") then search = string.lower(string.sub(wildcards[1], 2)) end				
			
		ColourNote("gray", "", "\n------------------------------------------------------------")
		ColourNote("gray", "", "| ", "cyan", "", "Partroxis Mobs" )
		ColourNote("gray", "", "------------------------------------------------------------")
						
		for i=1, 20 do		
			local color="lightgray"
			if (search ~= "" and string.find(string.lower(rooms[i].mob), search) ~= nil) then color = "yellow" end		
			ColourTell(color, "", string.sub("(".. i ..")  ", 1, 5)) 
			ColourTell(color, "", string.sub(rooms[i].mob .. "                         ", 1, 25) .. "  ")
			
			local color="lightgray"
			if (search ~= "" and string.find(string.lower(rooms[i+20].mob), search) ~= nil) then color = "yellow" end
			ColourTell(color, "", string.sub("(".. (i+20) ..") ", 1, 5))
			ColourNote(color, "", rooms[i+20].mob)
		end
		
		ColourNote("gray", "", "------------------------------------------------------------")
	end
	
	function Reset()
		pathSoFar = {}
		roomNotes = {}
		furthestRoom = 1
		currentRoom = 1
		lastRoom = 1
		
		ColourNote("orange", "", "Partroxis path and notes reset")
	end
	
	function SolveRoom()
		if (pathSoFar[currentRoom] ~= nil) then
			-- room is already solved			
			Execute("pm room")
			LoadCommand(pathSoFar[currentRoom])
			
		else			
			if (rooms[currentRoom].custom ~= nil) then
				-- ENTER GATE, easy peasy
				LoadCommand(rooms[currentRoom].custom)
				pathSoFar[currentRoom] = rooms[currentRoom].custom
				Execute("pm room")
			elseif (rooms[currentRoom].scan ~= nil) then
				-- MULTIPLE EXITS, scan for pet mobs on the possible exits
				local possibleExit = "^ (North|East|South|West|Up|Down)\\s+: " .. rooms[currentRoom+1].name .. " $"
				
				-- Create the triggers
				AddTriggerEx("possible_exit_1", possibleExit , "", 
					trigger_flag.Enabled + trigger_flag.KeepEvaluating + trigger_flag.RegularExpression + trigger_flag.OneShot,	
					14, 0, "", "PossibleExit", sendto.script, 100)						
					
				lastScanRoom = currentRoom
				scanQueue = {}
				EnableAlias("track_movement", true)
				
				EnableTrigger("exits_start", true)
				SendNoEcho("exits")
			else		
				-- REGULAR ROOM, set up trigger for exits			
				local nextExit = "^ (North|East|South|West|Up|Down)\\s+: " .. rooms[currentRoom+1].name .. " $"
				
				-- Create the trigger
				AddTriggerEx("next_exit", nextExit , "", 
					trigger_flag.Enabled + trigger_flag.KeepEvaluating + trigger_flag.RegularExpression + trigger_flag.OneShot,	
					14, 0, "", "NextExit", sendto.script, 100)
					
				EnableTrigger("exits_start", true)
				SendNoEcho("exits")
			end			
		end
	end
	
	function ExitsStart()
		Execute("pm room")
		EnableTrigger("exits_start", false)
	end
	
	function NextExit(name, line, wildcards)
		pathSoFar[currentRoom] = wildcards[1]
		LoadCommand(wildcards[1])
	end
	
	function PossibleExit(name, line, wildcards)		
		if (name == "possible_exit_1") then
			-- add the trigger for the second possible exit
			local possibleExit = "^ (North|East|South|West|Up|Down)\\s+: " .. rooms[currentRoom+1].name .. " $"
			AddTriggerEx("possible_exit_2", possibleExit , "", 
				trigger_flag.Enabled + trigger_flag.KeepEvaluating + trigger_flag.RegularExpression + trigger_flag.OneShot,	
				14, 0, "", "PossibleExit", sendto.script, 100)					
		end		
	
		-- Scan in the direction for pet mobs
		EnableTrigger("scan_start", true)				
		table.insert(scanQueue, string.upper(wildcards[1]))
		SendNoEcho("scan " .. wildcards[1])
	end
	
	function ScanStart()
		EnableTrigger("gag_scan_extra", true)
		EnableTrigger("scan_stop", true)		
			
		ColourNote("gray", "", "\n----------------------------------------")
		ColourNote("gray", "", "| Scanning for pets: ", "cyan", "", table.remove(scanQueue, 1))
		ColourNote("gray", "", "----------------------------------------")		
	end	
	
	function GagScanExtra()
		EnableTrigger("gag_scan_mobs", true)
	end
	
	function GagScanMobs()
		
	end
	
    function ScanStop()			
		EnableTrigger("scan_stop", false)	
		EnableTrigger("gag_scan_mobs", false)
		EnableTrigger("gag_scan_extra", false)					
		
		if (#scanQueue == 0) then
			EnableTrigger("scan_start", false)			
		end
		
		ColourNote("gray", "", "----------------------------------------\n")
	end
	
	function TrackMovement(name, line, wildcards)
		EnableAlias("track_movement", false)
		
		verifyMove = true		
		lastMove = wildcards[1]	
		
		SendNoEcho(wildcards[1])
	end
	
	function Go(name, line, wildcards)		
		local gotoRoom = furthestRoom
		if (wildcards[1] ~= nil and wildcards[1] ~= "") then 
			gotoRoom = tonumber(wildcards[1])			
		end
		
		if (gotoRoom <= furthestRoom) then
			ColourNote("gray", "", "----------------------------------------")
			ColourTell(
				"gray", "", "| Path from ", 
				"cyan", "", tostring(currentRoom),
				"gray", "", " to ", 
				"cyan", "", tostring(gotoRoom),
				"gray", "", ": ")				
		
			if (currentRoom  >= gotoRoom) then			
				ColourNote("cyan", "", "Already in furthest room")			
			else
				local path = "run "
				for i=currentRoom, gotoRoom-1 do
					if (pathSoFar[i] == "enter gate") then
						path = path .. delim .. pathSoFar[i] .. delim .. "run "
					else
						path = path .. string.lower(string.sub(pathSoFar[i], 1, 1))
					end				
				end							
				
				ColourNote("cyan", "", path)
				running = true
				runningTo = gotoRoom
				Execute(path)
			end			
			ColourNote("gray", "", "----------------------------------------")	
		else
			ColourNote("gray", "", "----------------------------------------")
			ColourNote(
				"gray", "", "| ",
				"red", "", "Path to room ", 
				"cyan", "", gotoRoom,				
				"red", "", " not solved")				
			ColourNote("gray", "", "----------------------------------------")
		end		
	end
	
	function ShowRoom()
		ColourNote("gray", "", "----------------------------------------")
		ColourTell("gray", "", "| Current Room: ", "cyan", "", tostring(currentRoom))
		
		local noteColor = ""
		local note = ""
		
		if (pathSoFar[currentRoom] ~= nil and currentRoom ~= furthestRoom) then
			noteColor = "green"
			note = "(SOLVED)"		
		elseif (roomNotes[currentRoom] ~= nil) then
			noteColor = "red"
			note = roomNotes[currentRoom]
		else
			noteColor = "yellow"
			note = "(UNSOLVED)"
		end
		ColourNote(noteColor, "", " - " .. note)
		
		ColourNote("gray", "", "----------------------------------------")		
	end
	
	function ShowPath()
		ColourNote("gray", "", "----------------------------------------")
			ColourTell(
				"gray", "", "| Path to ", 
				"cyan", "", tostring(furthestRoom),
				"gray", "", ": ")				
		
		ColourTell("cyan", "", "run ")
		for room, dir in pairs(pathSoFar) do
			if (dir == "enter gate") then
				ColourTell("cyan", "", delim .. dir .. delim .. "run ")
			else
				ColourTell("cyan", "", string.lower(string.sub(dir, 1, 1)))
			end
		end		
		
		ColourNote("gray", "", "\n----------------------------------------")		
	end
	
	function LoadCommand(cmd)		
		if (autofill == "true" or true) then
			SetCommandSelection(1,-1)
			local existing = PasteCommand(cmd)
			SetCommandSelection(1,-1)
			
			-- If something was already typed into the command bar, reload it
			if (existing ~= "") then							
				PasteCommand(existing)					
			end	
		end		
	end
]]>
</script>

</muclient>