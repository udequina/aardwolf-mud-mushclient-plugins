<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, May 28, 2019, 10:17 PM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "BlackClawHelper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="BlackClawHelper"
   author="Castiel"
   id="7a3526ff106dd8bcba196d78"
   language="Lua"
   purpose="Helps with BCC solo epic"
   save_state="y"
   date_written="2019-05-28 22:16:20"
   requires="5.06"
   version="1.0"
   >
   <description trim="n">
   		<![CDATA[
.----------------------------------------------------------------------------.
|                           Black Claw Crag Helper                           |
|----------------------------------------------------------------------------|
| bcc help -- Brings up the help section. (What you are reading now)         |
|                                                                            |
| bcc window       -- Toggles showing/hiding of mini window.                 |
| bcc announce     -- Toggles the announcements for breath.                  |
| bcc clear|reset  -- Clear any gathered data.                               |
| bcc window reset -- Reset window position/etc.                             |
| bcc find         -- Use once to "scan" all mist-viable rooms. Use again    |
|                     to run to and enter the last known mist location.      |
|                     Note: Requires mapper.                                 |
|                                                                            |
| bcc report <channel> -- Report statistics to channel supplied.             |
'----------------------------------------------------------------------------'
]]>
</description>
</plugin>

<aliases>
  <alias regexp="y" match="^bcc( help)?$" enabled="y" script="Help"></alias>
  <alias regexp="y" match="^bcc (clear|reset)$" enabled="y" script="manualReset"></alias>
  <alias regexp="y" match="^bcc rep(ort)? (?<channel>.*)$" enabled="y" script="reportData"></alias>
  <alias regexp="y" match="^bcc announce$" enabled="y" script="toggleAnnounce" ignore_case="y" sequence="100"></alias>
  <alias regexp="y" match="^bcc find$" enabled="y" script="findEntrance" ignore_case="y" sequence="100"></alias>

  <alias regexp="y" match="^bcc window$" enabled="y" script="toggleWindow" ignore_case="y" sequence="100"></alias>
  <alias regexp="y" match="^bcc window reset$" enabled="y" script="ResetWindow" ignore_case="y" sequence="100"></alias>
</aliases>

<triggers>
   <trigger group="bccEpic" regexp="y" match="^You get (\((?<enhanced>.*?)\) )?A jagged shard of obsidian from the (.*?)?corpse of A mortally wounded adventurer\.$" enabled="n" sequence="100" script="updateLoot"></trigger>
   <trigger group="bccEpic" regexp="y" match="^Axaldra, the Eternal One lifts off from her perch and flies (?<direction>south|north|east|west).$" enabled="n" sequence="100" script="breathAttack"></trigger>
   <trigger group="bccEpic" regexp="y" match="^You reach out and touch the crystal, which feels warm to the touch and is$" enabled="n" sequence="100" script="startTimer"></trigger>
   <trigger group="bccEpic" regexp="y" match="^Deciding you're not worth the trouble of feeding to her young, Axaldra, the$" enabled="n" sequence="100" script="endTimer"></trigger>
   <trigger name="bccFind" regexp="y" match="^     A thick layer of mist is obscuring your vision\.$" enabled="n" sequence="100" script="setEntranceRoom"></trigger>
   
</triggers>

<timers>
  <timer name="updateBreathTime" script="updateBreath" enabled="n" second="1.00" offset_second="0.00" send_to="12"></timer>
</timers>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Script  -->


<script>
<![CDATA[
   require "serialize"
   require "commas"
   require "gmcphelper"

   -- Window related variables
   local z_order_plugin = "462b665ecb569efbf261422f"
	local dragStart = nil	
	local window = {}	

   -- Variables
   local bccData = { }
   local startTime = 0
   local lastDir = "north"
   local entranceRoom = -1
   local curRoom = -1
   local announce = tonumber(GetVariable("announce")) or 1
   local tag = "@D[@YBlack Claw@D] :@w"
   local breath = {  ["north"] = "west",
                     ["east"]  = "north",
                     ["south"] = "east",
                     ["west"]  = "south" }

   local roomList = { ["nw"] = { timeLeft = 0, col = "silver" }, ["n"] = { timeLeft = 0, col = "silver" }, ["ne"] = { timeLeft = 0, col = "silver" },
                      ["w"]  = { timeLeft = 0, col = "silver" }, ["c"] = { timeLeft = 0, col = "silver" }, ["e"]  = { timeLeft = 0, col = "silver" },
                      ["sw"] = { timeLeft = 0, col = "silver" }, ["s"] = { timeLeft = 0, col = "silver" }, ["se"] = { timeLeft = 0, col = "silver" }
                     }

   function Help()
		ColourNote("orange", "black", GetPluginInfo (GetPluginID (), 3))
	end

   function toggleAnnounce()
      if announce == 1 then
         announce = 0
         ColourNote("silver", "", "Black Claw auto announce ", "red", "", "DISABLED")
      else
         announce = 1
         ColourNote("silver", "", "Black Claw auto announce ", "lime", "", "ENABLED")
      end
      SetVariable("announce", announce)
   end

   function OnPluginInstall()
      Send_GMCP_Packet("request room")

		if (GetVariable("window") ~= nil) then	
			-- load saved variables if they exist
			luastmt = "obj = " .. GetVariable("window")
			assert (loadstring (luastmt or "")) ()		
			window = obj
		else
			SetWindowDefaults() -- load window defaults
		end					
		
		if (GetVariable("bccData") ~= nil) then
			-- load saved variables if they exist
			luastmt = "obj = " .. GetVariable("bccData")
			assert (loadstring (luastmt or "")) ()
         bccData = obj
         if bccData.lastBonus == nil then --"Update" to fix a stat that didn't exist in a previous version
            if bccData.runs == nil then
               bccData.runs = 0
               bccData.lastBonus = 0
            else
               bccData.lastBonus = bccData.runs
            end
         end
      else
         resetData()
		end

		InitializeWindow()				
      Help()
   end

   function OnPluginClose()
		DeleteWindow()
   end
   
   function OnPluginBroadcast(msg, id, name, text)
      if (id == '3e7dedbe37e44942dd46d264') then
         if (text == "room.info") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info") --- We just want the room.info section.
            luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
            assert (loadstring (luastmt or "")) ()
            if (gmcpdata ~= nil) then
               currentArea = gmcpdata.zone
					curRoom = gmcpdata.num
               if gmcpdata.zone == "blackclaw" then --Enable triggers
                  EnableTriggerGroup("bccEpic", true)
               else
                  EnableTriggerGroup("bccEpic", false)
               end
            end
         end
      end
   end

   function findEntrance()
      if entranceRoom == -1 then
         EnableTrigger("bccFind", true)
         Execute("mapper goto 25035")
         Execute("s;e;e;e;n;e;s;s;s;w;n;w;w;w;s;s;s;s;w;s;e;e;e;e;s;e;s;e;w;s;w;w;n;e;n;w;w;w;w")
      else
         EnableTrigger("bccFind", false)
         Execute("mapper goto " .. entranceRoom)
         Execute("enter mist")
         entranceRoom = -1
      end
   end

   function setEntranceRoom()
      entranceRoom = curRoom
   end

   function reportData(name, line, wildcards)
      local tStr = wildcards.channel .. " " .. tag .. " "
      tStr = tStr .. "@cRuns: @w" .. bccData.runs .. "@c. "
      tStr = tStr .. "@cFastest: @w" .. GetTimeString(bccData.fastest) .. "@c. "
      tStr = tStr .. "@cTotal: @w" .. GetTimeString(bccData.totalTime) .. "@c. "
      tStr = tStr .. "@cAverage: @w" .. GetTimeString(bccData.avgTime) .. "@c. "
      if (bccData.runs - bccData.lastBonus) == 1 then
         tStr = tStr .. "@cLast bonus: @w" .. (bccData.runs - bccData.lastBonus) .. " run ago@c. "
      else
         tStr = tStr .. "@cLast bonus: @w" .. (bccData.runs - bccData.lastBonus) .. " runs ago@c. "
      end
      tStr = tStr .. "@cLoot: @D[@W"
      local tCount = 0
      for k, v in spairs(bccData.loot, function(t,a,b) return t[a] > t[b] end) do
         if tCount == 0 then
            tStr = tStr .. k .. "@c: @G" .. v .. "@c(@C" .. string.format("%.2f%%", (v/bccData.runs)*100) .. "@c)@W"
            tCount = tCount + 1
         else
            tStr = tStr .. " " .. k .. "@c: @G" .. v .. "@c(@C" .. string.format("%.2f%%", (v/bccData.runs)*100) .. "@c)@W"
         end
      end
      tStr = tStr .. "@D]@w"
      Send(tStr)
   end

   function resetData()
      bccData = { runs = 0, fastest = 0, totalTime = 0, avgTime = 0, loot = {} }
      SetVariable("bccData", serialize.save_simple(bccData))
   end

   function manualReset()
      resetData()
      ColourNote("orange", "", "Black Claw data reset!")
   end

   function updateLoot(name, line, wildcards)
      local iType = ""
      if wildcards.enhanced == nil or wildcards.enhanced == "" then
         iType = "Normal"
      else
         iType = wildcards.enhanced
      end
      iType = string.gsub(iType, "%(", "") --In case of Godly, it has 2 (
      iType = string.gsub(iType, "%)", "") --In case of Godly, it has 2 )

      if bccData.loot[iType] == nil then
         bccData.loot[iType] = 0
      end

      bccData.loot[iType] = tonumber(bccData.loot[iType]) + 1
      if iType ~= "Normal" then
         bccData.lastBonus = bccData.runs
      end
      SetVariable("bccData", serialize.save_simple(bccData)) --Save updated info
   end

   function breathAttack(name, line, wildcards)
      lastDir = wildcards.direction
      if announce == 1 then
         DoAfterSpecial (3, 'breathAnnounce()', sendto.script)
      end
      if wildcards.direction == "north" then
         roomList["nw"].timeLeft = 16
         roomList["nw"].col = "red"
         roomList["n"].timeLeft = 16
         roomList["n"].col = "red"
         roomList["ne"].timeLeft = 16
         roomList["ne"].col = "red"
      elseif wildcards.direction == "east" then
         roomList["ne"].timeLeft = 16
         roomList["ne"].col = "red"
         roomList["e"].timeLeft = 16
         roomList["e"].col = "red"
         roomList["se"].timeLeft = 16
         roomList["se"].col = "red"
      elseif wildcards.direction == "south" then
         roomList["se"].timeLeft = 16
         roomList["se"].col = "red"
         roomList["s"].timeLeft = 16
         roomList["s"].col = "red"
         roomList["sw"].timeLeft = 16
         roomList["sw"].col = "red"
      elseif wildcards.direction == "west" then
         roomList["sw"].timeLeft = 16
         roomList["sw"].col = "red"
         roomList["w"].timeLeft = 16
         roomList["w"].col = "red"
         roomList["nw"].timeLeft = 16
         roomList["nw"].col = "red"
      end
      EnableTimer("updateBreathTime", true)
      Draw(window)
   end
   
   function updateBreath()
      local tCount = 0
      for k, v in pairs(roomList) do
         if v.timeLeft > 0 then
            roomList[k].timeLeft = tonumber(roomList[k].timeLeft) - 1
            if roomList[k].timeLeft >= 3 then
               roomList[k].col = "red"
            elseif roomList[k].timeLeft == 2 then
               roomList[k].col = "orange"
            elseif roomList[k].timeLeft == 1 then
               roomList[k].col = "yellow"
            elseif roomList[k].timeLeft == 0 then
               roomList[k].col = "silver"
            end

            tCount = tCount + 1
         end
      end
      if tCount == 0 then --All timers are at 0, disable timer
         EnableTimer("updateBreathTime", false)
      end
      Draw(window)
   end

   function breathAnnounce()
      ColourNote("silver", "", "The direction ", "magenta", "", breath[lastDir], "silver", "", " is now safe!")
   end

   function startTimer()
      startTime = os.clock()
   end

   function endTimer()
      local endTime = (os.clock() - startTime)

      if endTime < bccData.fastest or bccData.fastest == 0 then --New fastest time!
         bccData.fastest = endTime
      end
      
      bccData.runs = tonumber(bccData.runs) + 1
      bccData.totalTime = tonumber(bccData.totalTime) + endTime
      bccData.avgTime = tonumber(bccData.totalTime) / tonumber(bccData.runs)
      SetVariable("bccData", serialize.save_simple(bccData)) --Save updated info
      ColourNote("silver", "", "Run completed in ", "cyan", "", GetTimeString(endTime))
   end

   function spairs(t, order)
      -- collect the keys
      local keys = {}
      for k in pairs(t) do keys[#keys+1] = k end

      -- if order function given, sort by it by passing the table and keys a, b,
      -- otherwise just sort the keys 
      if order then
         table.sort(keys, function(a,b) return order(t, a, b) end)
      else
         table.sort(keys)
      end

      -- return the iterator function
      local i = 0
      return function()
         i = i + 1
         if keys[i] then
            return keys[i], t[keys[i]]
         end
      end
   end

	function GetTimeString(curTimer)
		local min = 0
		local sec = 0
		local hrs = 0
		local days = 0
		local x = ""

		local amount = (curTimer/86400)
		if amount >= 1.0 then
			days = math.floor(amount)
			x = x .. days .. "d "
		end

		amount = (curTimer%86400)/3600
		if amount >= 1.0 then
			hrs = math.floor(amount)
			x = x .. hrs .. "h "
		end

		amount = ((curTimer%86400)%3600)/60;
			if amount >= 1.0 then
			min = math.floor(amount)
			x = x .. min .. "m "
		end

		amount = (((curTimer%86400)%3600)%60)%60
--		if amount >= 1.0 then
			sec = math.floor(amount)
			x = x .. sec .. "s"
--		end

		if x == "" then
			x = "N/A"
			Note("GetTimeString errored. Values:" .. curTimer)
		end

		return x
	end

   	-- window functions
	function Draw(win)
		-- miniwin background and outline
		WindowRectOp(win.id, miniwin.rect_fill , 0, 0, win.width, win.height, ColourNameToRGB(window.backgroundColor))	
		WindowRectOp(win.id, miniwin.rect_3d_rect , 0, 0, win.width, win.height, ColourNameToRGB(window.borderColor), ColourNameToRGB(window.borderColor))				
		
		-- resize bars
		WindowLine(win.id, win.width-3,  win.height-2, win.width-2, win.height-3, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-4,  win.height-2, win.width-2, win.height-4, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-6,  win.height-2, win.width-2, win.height-6, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-7,  win.height-2, win.width-2, win.height-7, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-9,  win.height-2, win.width-2, win.height-9, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-10, win.height-2, win.width-2, win.height-10, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-12, win.height-2, win.width-2, win.height-12, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-13, win.height-2, win.width-2, win.height-13, ColourNameToRGB(window.backgroundColor), 0, 1)
		
		-- Where the magic happens. Draw all the things!
      local offset = 3
      local boxSize = 10
      local tCol = "silver"
      --WindowText(win.id, win.font, "This is a test", 5, line * (win.fontSize+2), 0, 0, ColourNameToRGB(window.fontColor), true)
      drawSquare(win, offset, offset, boxSize, roomList["nw"].col)
      drawSquare(win, (offset*2)+boxSize, offset, boxSize, roomList["n"].col)
      drawSquare(win, (offset*3)+(boxSize*2), offset, boxSize, roomList["ne"].col)

      drawSquare(win, offset, (offset*2)+boxSize, boxSize, roomList["w"].col)
      drawSquare(win, (offset*2)+boxSize, (offset*2)+boxSize, boxSize, roomList["c"].col)
      drawSquare(win, (offset*3)+(boxSize*2), (offset*2)+boxSize, boxSize, roomList["e"].col)

      drawSquare(win, offset, (offset*3)+(boxSize*2), boxSize, roomList["sw"].col)
      drawSquare(win, (offset*2)+boxSize, (offset*3)+(boxSize*2), boxSize, roomList["s"].col)
      drawSquare(win, (offset*3)+(boxSize*2), (offset*3)+(boxSize*2), boxSize, roomList["se"].col)
	end	
   
   function drawSquare(win, x, y, boxSize, colour)
		WindowRectOp(win.id, miniwin.rect_fill , x, y, x+boxSize, y+boxSize, ColourNameToRGB(colour))	

      --WindowLine(win.id, x,  y, x+sSize, y, ColourNameToRGB(color), 0, 1) --Horizontal
      --WindowLine(win.id, x,  y+sSize, x+sSize, y+sSize, ColourNameToRGB(color), 0, 1)
      --WindowLine(win.id, x,  y, x, y+sSize, ColourNameToRGB(color), 0, 1) --Vertical
      --WindowLine(win.id, x+sSize,  y, x+sSize, y+sSize, ColourNameToRGB(color), 0, 1)
   end

	function InitializeWindow()
		WindowCreate(window.id, window.left, window.top, window.width, window.height, miniwin.pos_center_all, miniwin.create_keep_hotspots, ColourNameToRGB(window.backgroundColor))
		WindowFont(window.id, window.font, window.fontFamily, window.fontSize, false, false, false, false, 1, 0)
		WindowPosition(window.id, window.left, window.top, miniwin.pos_stretch_to_view, miniwin.create_absolute_location)	

		CreateHotSpots()
		
		if (window.show) then
			WindowShow(window.id, window.show)				
			if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
				CallPlugin(z_order_plugin, "boostMe", window.id)
			end
			Draw(window)
		end	
	end
	
	function DeleteWindow()
		WindowDelete(window.id)
   end

   function toggleWindow()
      if window.show == true then
         HideWindow()
         ColourNote("silver", "", "Black Claw mini window has been ", "red", "", "DISABLED")
      else
         ShowWindow()
         ColourNote("silver", "", "Black Claw mini window has been ", "lime", "", "ENABLED")
      end
   end
	
	function ShowWindow()
		window.show = true
		WindowShow(window.id, true)
		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "boostMe", window.id)
		end
		Draw(window)
		SaveWindow()	
	end
	
	function HideWindow()
		window.show = false
		WindowShow(window.id, false)
		Draw(window)
		SaveWindow()
	end	
	
	function SaveWindow()
		SetVariable("window", serialize.save_simple(window))
	end	
	
	function SetWindowDefaults()
		window = {
			id = "window_" .. GetPluginID(),
			top = 10,
			left = 10,
			width = 200,
			height = 50,
			show = true,
			font = "defaultFont",
			fontFamily = "Consolas",
			fontSize = 9,
			fontColor = "white",
			borderColor = "lightgray",
			backgroundColor = "black"
		}
	end
	
	function ResetWindow()
		SetWindowDefaults()		
		SaveWindow()	
		InitializeWindow()				
      Draw(window)
      ColourNote("silver", "", "Black Claw mini window position/etc has been reset.")
	end
	
	function CreateHotSpots()
		WindowDeleteAllHotspots(window.id)
	
		WindowAddHotspot(window.id, "DragArea", 0, 0, window.width-13, window.height-13, 
			"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
		WindowDragHandler(window.id, "DragArea", "dragmove", "dragrelease", 0)	

		WindowAddHotspot(window.id, "DragAreaBottom", 0, window.height-13, window.width-13, window.height, 
			"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
		WindowDragHandler(window.id, "DragAreaBottom", "dragmove", "dragrelease", 0)	

		WindowAddHotspot(window.id, "DragAreaRight", window.width-13, 0, window.width, window.height-13, 
			"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
		WindowDragHandler(window.id, "DragAreaRight", "dragmove", "dragrelease", 0)			
		
		WindowAddHotspot(window.id, "Resize", 
			window.width-13, window.height-13, window.width-2, window.height-2,
			"", "", "", "", "mouseup", "Drag to resize", miniwin.cursor_nw_se_arrow, 0)
		WindowDragHandler(window.id, "Resize", "resizemove", "resizerelease", 0) 
	end
	
	-- Handlers
	function dragmove(flags, hotspot_id)							
		if (not dragStart) then
			dragStart = {
				x = WindowInfo(window.id, 14),
				y = WindowInfo(window.id, 15),
			}
		end		
		
		WindowPosition(window.id, 
						WindowInfo (window.id, 17) - dragStart.x, 
						WindowInfo (window.id, 18) - dragStart.y, 
						miniwin.pos_stretch_to_view, 
						miniwin.create_absolute_location)
	end

	function dragrelease(flags, hotspot_id)		
		window.left = WindowInfo(window.id, 10)
		window.top = WindowInfo(window.id, 11)
		
		dragStart = nil
		
		SaveWindow()
	end
	
	function resizemove(flags, hotspot_id) 
		window.width = WindowInfo(window.id, 17) - WindowInfo(window.id, 10)
		window.height = WindowInfo(window.id, 18) - WindowInfo(window.id, 11)
		
		WindowResize(window.id, window.width, window.height, ColourNameToRGB("gray"))
		WindowShow(window.id, true)
	end -- dragmove

	function resizerelease(flags, hotspot_id)
		SaveWindow()
				
		CreateHotSpots()
		
		Draw(window)
	end -- dragrelease
	
	function mouseup(flags, hotspot_id)		
		if (bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0) then
			local result = WindowMenu(window.id, 
				WindowInfo(window.id, 14),
				WindowInfo(window.id, 15),
				"Bring to front|Send to back")		
			
			if (result ~= "" and IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
				if (result == "Send to back") then 
					CallPlugin(z_order_plugin, "dropMe", window.id)
				else
					CallPlugin(z_order_plugin, "boostMe", window.id)
				end
			end
		end
	end

]]>
</script>


</muclient>