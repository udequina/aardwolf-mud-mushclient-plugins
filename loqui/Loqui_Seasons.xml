<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, December 10, 2017, 7:26 PM -->
<!-- MuClient version 4.84 -->

<!-- Plugin "Loqui_Seasons" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Loqui_Seasons"
   author="Castiel"
   id="f8dc8e73ccaa06b7fd231396"
   language="Lua"
   purpose="Tracks seasons"
   save_state="y"
   date_written="2017-12-10 19:25:31"
   requires="4.84"
   version="1.0"
   >
   <description trim="n">
   		<![CDATA[
.----------------------------------------------------------------------------.
| Loqui Season Tracker Help                                                  |
|----------------------------------------------------------------------------|
|lst help -- Brings up the help section. (What you are reading now)          |
|lst search|find <damage> -- Search for damage type.                         |
|lst summary -- Display season info.                                         |
|lst report <channel> -- Report season data to a channel.                    |
|lst findrep <season> <channel> -- Report when a specific season will occur. |
'----------------------------------------------------------------------------'
]]>
</description>
</plugin>

<aliases>
	<alias script="Help" match="^lst help$" enabled="y" regexp="y" sequence="100" ignore_case="y"></alias>
	<alias script="Summary" match="^lst summary$" enabled="y" regexp="y" sequence="100" ignore_case="y"></alias>
	<alias script="FindSeason" match="^lst (search|find) (.*)$" enabled="y" regexp="y" sequence="100" ignore_case="y"></alias>
	<alias script="ReportSeasons" match="^lst report (.*)$" enabled="y" regexp="y" sequence="100" ignore_case="y"></alias>
	<alias script="ReportSpecificSeason" match="^lst findrep (\w+) (.*)$" enabled="y" regexp="y" sequence="100" ignore_case="y"></alias>
</aliases>

<triggers>
	<trigger name="seasonCapture" regexp="y" match="^  \*  It is (?<time>.*) on the (?<day>.*)(rd|th|st|nd) day of the Season of (?<season>.*)\, year (?<year>.*) AVT\.$" enabled="y" sequence="100" omit_from_output="n" script="CaptureTime"></trigger>
</triggers>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Script  -->


<script>
<![CDATA[
	local seasonTable = {
		 [0] = { name = "sun",       damage = "light",    days = 138 },
		 [1] = { name = "scourge",   damage = "disease",  days = 162 },
		 [2] = { name = "river",     damage = "water",    days = 138 },
		 [3] = { name = "song",      damage = "sonic",    days = 150 },
		 [4] = { name = "energy",    damage = "energy",   days = 148 },
		 [5] = { name = "nature",    damage = "earth",    days = 140 },
		 [6] = { name = "snake",     damage = "poison",   days = 142 },
		 [7] = { name = "sword",     damage = "slash",    days = 140 },
		 [8] = { name = "freeze",    damage = "cold",     days = 148 },
		 [9] = { name = "thought",   damage = "mental",   days = 148 },
		[10] = { name = "darkness",  damage = "shadow",   days = 134 },
		[11] = { name = "corrosion", damage = "acid",     days = 136 },
		[12] = { name = "dagger",    damage = "pierce",   days = 120 },
		[13] = { name = "storm",     damage = "electric", days = 131 },
		[14] = { name = "piety",     damage = "holy",     days = 143 },
		[15] = { name = "suffering", damage = "negative", days = 135 },
		[16] = { name = "burning",   damage = "fire",     days = 144 },
		[17] = { name = "tornado",   damage = "air",      days = 142 },
		[18] = { name = "stone",     damage = "bash",     days = 120 },
		[19] = { name = "magi",      damage = "magic",    days = 138 }
	}
	local seasonLookup = {
		["sun"] = 0,
		["scourge"] = 1,
		["river"] = 2,
		["song"] = 3,
		["energy"] = 4,
		["nature"] = 5,
		["snake"] = 6,
		["sword"] = 7,
		["freeze"] = 8,
		["thought"] = 9,
		["darkness"] = 10,
		["corrosion"] = 11,
		["dagger"] = 12,
		["storm"] = 13,
		["piety"] = 14,
		["suffering"] = 15,
		["burning"] = 16,
		["tornado"] = 17,
		["stone"] = 18,
		["magi"] = 19,
		["light"] = 0,
		["disease"] = 1,
		["water"] = 2,
		["sonic"] = 3,
--		["energy"] = 4, --Duplicate
		["earth"] = 5,
		["poison"] = 6,
		["slash"] = 7,
		["cold"] = 8,
		["mental"] = 9,
		["shadow"] = 10,
		["acid"] = 11,
		["pierce"] = 12,
		["electric"] = 13,
		["holy"] = 14,
		["negative"] = 15,
		["fire"] = 16,
		["air"] = 17,
		["bash"] = 18,
		["magic"] = 19
	}



	local curTime = { time = -1, day = -1, season = -1 }

	function Help()
		ColourNote("orange", "black", GetPluginInfo (GetPluginID (), 3))
	end

	function OnPluginBroadcast(msg, id, name, text)
		if (id == '3e7dedbe37e44942dd46d264') then
			if (text == 'comm.tick') then
				UpdateTime()
			end
		end
	end

	function UpdateTime()
		if tonumber(curTime.time) == -1 then --Haven't established current time, abort
			return --Time not set, don't do anything
		end
		if seasonTable[curTime.season].days == nil then
			ColourNote("orange", "", "Error 404: Season not found.")
			return
		end

		curTime.time = curTime.time + 1
		if curTime.time > 23 then
			curTime.time = 0
			curTime.day = curTime.day + 1
			if curTime.day > seasonTable[curTime.season].days then --Rollover season
				curTime.day = 1
				curTime.season = curTime.season + 1
				if curTime.season > 19 then
					curTime.season = 0
				end
			end
		end
	end

	function FindSeason(name, line, wildcards)
		if tonumber(curTime.time) == -1 then --Haven't established current time, abort
			ColourNote("orange", "", "You must first type 'time' to establish current time.")
			return
		end
		local sText = string.lower(wildcards[2])
		if seasonLookup[sText] == nil then
			ColourNote("orange", "", "Could not find the season/damage: " .. sText)
			return
		end
		local nSeason = seasonLookup[sText]
		if tonumber(nSeason) == tonumber(curTime.season) then
			ColourNote("orange", "", "That season is currently active!")
			return
		end
		local cSeason = curTime.season
		local ticks = ((tonumber(seasonTable[curTime.season].days)-tonumber(curTime.day)) * 24) + (24-curTime.time)
		cSeason = (cSeason + 1) % 20

		while tonumber(cSeason) ~= tonumber(nSeason) do
			ticks = ticks + (tonumber(seasonTable[cSeason].days)*24)
			cSeason = (cSeason + 1) % 20
		end
		ColourNote("orange", "", "Time until season ", "cyan", "", CapFirst(seasonTable[nSeason].name), "orange", "", " (", "cyan", "", CapFirst(seasonTable[nSeason].damage), "orange", "", "): ", "cyan", "", ticks, "orange", "", " ticks (", "cyan", "", GetTimeString(ticks*30), "orange", "", ")")		
	end

	function ReportSpecificSeason(name, line, wildcards)
		if tonumber(curTime.time) == -1 then --Haven't established current time, abort
			ColourNote("orange", "", "You must first type 'time' to establish current time.")
			return
		end
		local sText = string.lower(wildcards[1])
		if seasonLookup[sText] == nil then
			ColourNote("orange", "", "Could not find the season/damage: " .. sText)
			return
		end
		local nSeason = seasonLookup[sText]
		if tonumber(nSeason) == tonumber(curTime.season) then
			Send(wildcards[2] .. " @cThat season is already active!")
			return
		end
		local cSeason = curTime.season
		local ticks = ((tonumber(seasonTable[curTime.season].days)-tonumber(curTime.day)) * 24) + (24-curTime.time)
		cSeason = (cSeason + 1) % 20

		while tonumber(cSeason) ~= tonumber(nSeason) do
			ticks = ticks + (tonumber(seasonTable[cSeason].days)*24)
			cSeason = (cSeason + 1) % 20
		end
		local cText = wildcards[2] .. " @cTime until season @C" .. CapFirst(seasonTable[nSeason].name) .. "@c (@C" .. CapFirst(seasonTable[nSeason].damage) .. "@c): @C" .. ticks .. "@c ticks (@C" .. GetTimeString(ticks*30) .. "@c)"
		Send(cText)
	end

	function ReportSeasons(name, line, wildcards)
		if tonumber(curTime.time) == -1 then --Haven't established current time, abort
			ColourNote("orange", "", "You must first type 'time' to establish current time.")
			return --Time not set, don't do anything
		end
		if seasonTable[curTime.season].days == nil then
			ColourNote("orange", "", "Error 404: Season not found.")
			return
		end

		local sText = wildcards[1] .. " @cSeason: @C" .. CapFirst(seasonTable[curTime.season].name) .. " @c(@C" .. CapFirst(seasonTable[curTime.season].damage)
			.. "@c). Next season: @C"
		local ticks = ((tonumber(seasonTable[curTime.season].days)-tonumber(curTime.day)) * 24) + (24-curTime.time)
		local nSeason = (curTime.season + 1) % 20
		sText = sText .. CapFirst(seasonTable[nSeason].name) .. " @c(@C" .. CapFirst(seasonTable[nSeason].damage) .. "@c) in @C" .. ticks .. " @cticks (@C" .. GetTimeString(ticks*30) .. "@c)@w"
		Send(sText)
	end

	function Summary(name, line, wildcards)
		if tonumber(curTime.time) == -1 then --Haven't established current time, abort
			ColourNote("orange", "", "You must first type 'time' to establish current time.")
			return --Time not set, don't do anything
		end
		if seasonTable[curTime.season].days == nil then
			ColourNote("orange", "", "Error 404: Season not found.")
			return
		end
		ColourNote("orange", "", "The current season is: ", "cyan", "", CapFirst(seasonTable[curTime.season].name), "orange", "", " (", "cyan", "", CapFirst(seasonTable[curTime.season].damage), "orange", "", ")")
		ColourNote("orange", "", "It is day ", "cyan", "", curTime.day, "orange", "", " of ", "cyan", "", seasonTable[curTime.season].days, "orange", "", ".")
		local ticks = ((tonumber(seasonTable[curTime.season].days)-tonumber(curTime.day)) * 24) + (24-curTime.time)
		ColourNote("orange", "", "Time left in this season: ", "cyan", "", ticks, "orange", "", " ticks, which is in roughly ", "cyan", "", GetTimeString(ticks*30), "orange", "", ".")
		local nSeason = (curTime.season + 1) % 20
		ColourNote("orange", "", "The next season is: ", "cyan", "", CapFirst(seasonTable[nSeason].name), "orange", "", " (", "cyan", "", CapFirst(seasonTable[nSeason].damage), "orange", "", ")")
		
	end

	function CaptureTime(name, line, wildcards)
		local tTime = wildcards.time
		curTime.day = wildcards.day
		curTime.season = seasonLookup[string.lower(string.gsub(wildcards.season, "the ", ""))]

		if tTime == "Noon" then
			curTime.time = 12
		elseif tTime == "Midnight" then
			curTime.time = 0
		else
			if string.find(tTime, "am") ~= nil then --Morning
				tTime = string.gsub(tTime, "am", "")
				curTime.time = tonumber(tTime)
			elseif string.find(tTime, "pm") ~= nil then --Afternoon
				tTime = string.gsub(tTime, "pm", "")
				curTime.time = tonumber(tTime+12)
			else --Error
				ColourNote("orange", "", "Error 404: Time not found! You shouldn't see this, so if you do report it to Castiel!")
			end
		end
	end

	function CapFirst(str)
		return (str:gsub("^%l", string.upper))
	end

	function GetTimeString(curTimer)
		local min = 0
		local sec = 0
		local hrs = 0
		local days = 0
		local x = ""

		local amount = (curTimer/86400)
		if amount >= 1.0 then
			days = math.floor(amount)
			x = x .. days .. "d "
		end

		amount = (curTimer%86400)/3600
		if amount >= 1.0 then
			hrs = math.floor(amount)
			x = x .. hrs .. "h "
		end

		amount = ((curTimer%86400)%3600)/60;
			if amount >= 1.0 then
			min = math.floor(amount)
			x = x .. min .. "m "
		end

		amount = (((curTimer%86400)%3600)%60)%60
--		if amount >= 1.0 then
			sec = math.floor(amount)
			x = x .. sec .. "s"
--		end

		if x == "" then
			x = "N/A"
			Note("GetTimeString errored. Values:" .. curTimer)
		end

		return x
	end
]]>
</script>


</muclient>
