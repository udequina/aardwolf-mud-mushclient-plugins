<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Wednesday, February 20, 2019, 11:14 AM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "ooc" generated by Plugin Wizard -->

<muclient>
<plugin
   name="ooc"
   author="Durel"
   id="b16d151337abc0f42a42a37c"
   language="Lua"
   purpose="Out-of-combat manager"
   save_state="y"
   date_written="2019-02-20 11:15:14"
   requires="5.06"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Queues command(s) to execute once the player is no longer in combat.  This could be helpful
to run "spellup" while in a fast group that doesn't give much time between rooms.
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>


<!--  Triggers  -->

<!--  Aliases  -->

<aliases>

  <alias
   match="^[ ]*ooc[ ]+(~)?(?:command|cmd)([ ]+.*)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>ooc.command(Trim("%2"), "%1")</send>
  </alias>

  <alias
   match="^[ ]*ooc[ ]+timeout([ ]+[0-9]+)?[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>ooc.timeout(Trim("%1"))</send>
  </alias>
  
 <alias
   match="^[ ]*ooc[ ]+cancel[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>ooc.cancel()</send>
  </alias>

  <alias
   match="^[ ]*ooc[ ]+commlog[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>ooc.commlogSet("%1")</send>
  </alias>
  
  <alias
   match="^[ ]*ooc[ ]+verbose[ ]+(on|off)[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>ooc.verboseSet("%1")</send>
  </alias>
  
  <alias
   match="^[ ]*ooc[ ]+display[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>ooc.display()</send>
  </alias>

  <alias
   match="^[ ]*ooc[ ]+version[ ]*$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>ooc.version()</send>
  </alias>

  <alias
   match="^[ ]*ooc(|[ ]+.*)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="1000"
  >
  <send>ooc.help()</send>
  </alias>


</aliases>

<!--  Variables  -->


<!--  Script  -->


<script>
<![CDATA[


--[[
----------------------------------------------------------------------------------------------------------
Table of Contents
----------------------------------------------------------------------------------------------------------

Dependencies and Globals
------------------------

MUSH callbacks
--------------
function OnPluginInstall()
function OnPluginClose()
function OnPluginConnect()
function OnPluginDisconnect()
function OnPluginEnable()
function OnPluginDisable()
function OnPluginBroadcast(msg, id, name, text)

Plugin init/de-init
-------------------
function ooc.init()
function ooc.fini()

Command options
---------------
function ooc.command(command, invert)
function ooc.commandCR()
function ooc.cancel()
function ooc.timeout()
function ooc.timeoutSet()
function ooc.timeoutGet()

Commlog options
---------------
function ooc.commlogSet(enable)
function ooc.commlogGet()
function ooc.commLog(msg)

Plugin info
-----------
function ooc.version()
function ooc.help()

Core helper functions
---------------------
function ooc.printFormat(msg)
function ooc.printColors(msg)
function ooc.print(msg)
function ooc.error(msg)

function ooc.getRoom()
function ooc.getRoomId()
function ooc.roomIdToRoom(roomId)

function ooc.getName()

function ooc.inCombat()
function ooc.isWordInString(word, field)
--]]


----------------------------------------------------------------------------------------------------------
-- Dependencies
----------------------------------------------------------------------------------------------------------

require "gmcphelper"
require "wait"
require "check"
require "tprint"

dofile(GetInfo(60) .. "aardwolf_colors.lua")


----------------------------------------------------------------------------------------------------------
-- Global vars and tables
----------------------------------------------------------------------------------------------------------

ooc = {}

ooc.name = "OOC"
ooc.ver = "1.0.1"


----------------------------------------------------------------------------------------------------------
-- MUSH callbacks and hooks
----------------------------------------------------------------------------------------------------------

function OnPluginInstall()
  ooc.init()
end -- OnPluginInstall


function OnPluginClose()
  ooc.fini()
end -- OnPluginClose


function OnPluginConnect()
  --ooc.print("OnPluginConnect!")
end -- OnPluginConnect


function OnPluginDisconnect()
  --ooc.print("OnPluginDisconnect!")
end -- OnPluginDisconnect


function OnPluginEnable()
  --ooc.print("OnPluginEnable!")
  ooc.print("@GENABLED@W")
end -- OnPluginEnable


function OnPluginDisable()
  --ooc.print("OnPluginDisable!")
  ooc.print("@RENABLED@W")
end -- OnPluginDisable


function OnPluginBroadcast(msg, id, name, text)
  if id == "3e7dedbe37e44942dd46d264" then -- message from the GMCP Handler
    if (text == "room.info") then
      --placeholder
    end
  end
end


----------------------------------------------------------------------------------------------------------
-- Plugin init/de-init
----------------------------------------------------------------------------------------------------------

function ooc.init()

  -- Display the helpfile when the plugin loads
  ooc.help()

end -- ooc.init


function ooc.fini()
  -- placeholder for now...
end -- ooc.fini


----------------------------------------------------------------------------------------------------------
-- Command options
----------------------------------------------------------------------------------------------------------

ooc.commandPkg    = nil
ooc.commandInvPkg = nil

function ooc.command(commands, invert)
  local isInverted = false
  if (invert == "~") then
    isInverted = true
  end -- if

  if (not isInverted) and (ooc.commandPkg ~= nil) then
    ooc.print("@YSKIP@w \"@C" .. (commands or "nil") .. "@w\": another request is in progress")
    return
  elseif (isInverted) and (ooc.commandInvPkg ~= nil) then
    --ooc.print("@YSKIP@w @M~@w\"@C" .. (commands or "nil") .. "@w\": another request is in progress")
    return
  end -- if

  if isInverted then
    ooc.commandInvPkg = { cmds = commands, qSec = ooc.timeoutGet(), halt = false }
    wait.make(ooc.commandInvCR)
  else
    ooc.commandPkg = { cmds = commands, qSec = ooc.timeoutGet(), halt = false }
    wait.make(ooc.commandCR)
  end -- if

end -- ooc.command


function ooc.commandCR()
  if (ooc.commandPkg == nil) then
    ooc.error("Command co-routine package is nil!?!")
    return
  end -- if

  local cmds  = ooc.commandPkg.cmds or "nil"
  local qSec  = tonumber(ooc.commandPkg.qSec or "") or 0

  local didTimeout = false

  if (qSec > ooc.timeoutMax) then
    qSec = ooc.timeoutMax
  end -- if

  -- Wait for up to qSec seconds to get to desired combat state before proceeding
  local totTime = 0
  if (qSec > 0) then
    local spinPeriod = 0.1

    while (totTime <= qSec) do
      -- break out of the spin once we hit the desired combat state
      if (not ooc.inCombat()) then
        break
      end -- if

      -- break out of the spin if the user cancels the request
      if (ooc.commandPkg.halt == true) then
        break
      end -- if

      if (totTime == 0) and ooc.isVerbose() then
        ooc.print("Queuing   \"@g" .. cmds .. "@w\"")
      end -- if

      wait.time(spinPeriod)
      totTime = totTime + spinPeriod
    end -- if

    if (totTime >= qSec) then
      ooc.print("@YTIMEOUT@w \"@C" .. cmds .. "@w\" timed out (" .. qSec .. " s)")
      didTimeout = true
    end -- if
  end -- if

  local isHalting = ooc.commandPkg.halt

  -- Clear things here so that we can start another ooc command in the Execute line below
  ooc.commandPkg = nil

  -- If we didn't timeout or see a cancellation request, send the command(s)
  if (not didTimeout) and (not isHalting) and (cmds ~= nil) and (cmds ~= "") then
    if ooc.isVerbose() then
      local suffix = ""
      if (totTime > 0) then
        suffix = " (delayed " .. totTime .. " seconds)"
      end -- if

      ooc.print("Executing \"@x083" .. cmds .. "@w\"" .. suffix)
    end -- if

    Execute(cmds)
  end -- if

end -- ooc.commandCR


function ooc.commandInvCR()
  if (ooc.commandInvPkg == nil) then
    ooc.error("Inverted command co-routine package is nil!?!")
    return
  end -- if

  local cmds  = ooc.commandInvPkg.cmds or "nil"
  local qSec  = tonumber(ooc.commandInvPkg.qSec or "") or 0

  local didTimeout = false

  if (qSec > ooc.timeoutMax) then
    qSec = ooc.timeoutMax
  end -- if

  -- Wait for up to qSec seconds to get to desired combat state before proceeding
  local totTime = 0
  if (qSec > 0) then
    local spinPeriod = 0.1

    while (totTime <= qSec) do
      -- break out of the spin once we hit the desired combat state
      if ooc.inCombat() then
        break
      end -- if

      -- break out of the spin if the user cancels the request
      if (ooc.commandInvPkg.halt == true) then
        break
      end -- if

      if (totTime == 0) and ooc.isVerbose() then
        --ooc.print("Queuing   @M~@w\"@g" .. cmds .. "@w\"")
      end -- if

      wait.time(spinPeriod)
      totTime = totTime + spinPeriod
    end -- if

    if (totTime >= qSec) then
      ooc.print("@YTIMEOUT@w @M~@w\"@C" .. cmds .. "@w\" timed out (" .. qSec .. " s)")
      didTimeout = true
    end -- if
  end -- if

  local isHalting = ooc.commandInvPkg.halt

  -- Clear things here so that we can start another ooc command in the Execute line below
  ooc.commandInvPkg = nil

  -- If we didn't timeout or see a cancellation request, send the command(s)
  if (not didTimeout) and (not isHalting) and (cmds ~= nil) and (cmds ~= "") then
    if ooc.isVerbose() then
      local suffix = ""
      if (totTime > 0) then
        suffix = " (delayed " .. totTime .. " seconds)"
      end -- if

      --ooc.print("Executing @M~@w\"@x083" .. cmds .. "@w\"" .. suffix)
    end -- if

    Execute(cmds)
  end -- if

end -- ooc.commandInvCR


-- Halt any pending request
function ooc.cancel()
  if (ooc.commandPkg ~= nil) then
    ooc.print("Cancelled request")
    ooc.commandPkg.halt = true
  end -- if

  if (ooc.commandInvPkg ~= nil) then
    ooc.print("Cancelled @M~@wrequest")
    ooc.commandInvPkg.halt = true
  end -- if
end -- ooc.cancel


-- Specify how many seconds to try a movement before giving up (if you are in combat)
ooc.timeoutDefault = 60 -- Default # of seconds before giving up on a delayed command
ooc.timeoutMax = 60 -- set a limit on how long to retry
function ooc.timeout(timeSec)

  -- If no timeout value is given, report the current timeout instead
  if (timeSec == nil) or (timeSec == "") then
    ooc.print("Current timeout is " .. (ooc.timeoutGet() or 0) .. " seconds")
  else
    ooc.timeoutSet(tonumber(timeSec or "") or 0)
  end -- if

end -- ooc.timeout


function ooc.timeoutSet(seconds)
  local timeoutSec = tonumber(seconds or "") or 0

  if (timeoutSec > ooc.timeoutMax) then
    timeoutSec = ooc.timeoutMax
    ooc.print("Capping timeout at maximum value of " .. ooc.timeoutMax .. " seconds")
  else
    ooc.print("Setting timeout to " .. timeoutSec .. " seconds")
  end -- if

  SetVariable("timeoutSeconds", timeoutSec)
end -- ooc.timeoutSet


function ooc.timeoutGet()
  local timeSec = tonumber(GetVariable("timeoutSeconds") or "")

  if (timeSec == nil) then
    timeSec = ooc.timeoutDefault
    ooc.timeoutSet(timeSec)
  end -- if

  return timeSec or 0
end -- ooc.timeoutGet


----------------------------------------------------------------------------------------------------------
-- Verbose access
----------------------------------------------------------------------------------------------------------

function ooc.verboseSet(enable)
  if (enable ~= "on") and (enable ~= "off") then
    ooc.error("ooc.verboseSet: invalid verbose mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("verboseState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  ooc.print("Verbose logging is " .. msg)

end -- ooc.verboseSet


function ooc.verboseGet()
  return (GetVariable("verboseState") or "")
end -- ooc.verboseGet


function ooc.isVerbose()
  if (ooc.verboseGet() == "on") then
    return true
  else
    return false
  end -- if
end -- ooc.isVerbose


----------------------------------------------------------------------------------------------------------
-- Commlog options
----------------------------------------------------------------------------------------------------------

function ooc.commlogSet(enable)
  if (enable ~= "on") and (enable ~= "off") then
    ooc.error("ooc.commlogSet: invalid commlog mode \"" .. (enable or "nil") .. "\"")
    return
  end -- if

  SetVariable("commlogState", enable)

  local msg
  if (enable == "on") then
    msg = "@GENABLED@w"
  else
    msg = "@RDISABLED@w"
  end -- if

  ooc.print("Mirroring to communication log is " .. msg)

end -- ooc.commlog


function ooc.commlogGet()
  return (GetVariable("commlogState") or "")
end -- ooc.commlogGet


----------------------------------------------------------------------------------------------------------
-- Plugin information
----------------------------------------------------------------------------------------------------------

function ooc.version()
  ooc.print("Version: " .. ooc.ver)
end -- ooc.version


function ooc.help()

ooc.printColors([[
@x039------------------------------------------------------------------------------------------@w
@x039OOC: Out-of-combat manager@w
@x039------------------------------------------------------------------------------------------@w

  @cCommand options@w
    @wooc @Wcommand [commands] @x173-- Specify command (or commands) to run when out of combat@w
    @wooc @Wtimeout <seconds>  @x173-- Specify how many seconds to attempt command if in combat@w
    @wooc @Wcancel             @x173-- Cancel any pending commands@w

    @wooc @Wcommlog [on|off]   @x173-- Mirror ooc messages to the commlog (handy with L3 spam!)@w
    @wooc @Wverbose [on|off]   @x173-- Report commands@w

  @cPlugin info@w
    @wooc @Wversion            @x173-- Report the current version of this plugin@w
    @wooc @Whelp               @x173-- Display the usage you're reading right now...@w

  @RFor the love of Ayla, please do NOT use this for botting.  This is intended to let
  you spellup, sense life, scan, etc., not auto-run and attack another room.

@x039------------------------------------------------------------------------------------------@w
]])
end -- ooc.help


----------------------------------------------------------------------------------------------------------
-- Core helper functions
----------------------------------------------------------------------------------------------------------

function ooc.printFormat(msg)
  local formattedMsg = ""

  if (msg ~= nil) and (msg ~= "") then

    local outerColor = "@x105"
    local innerColor = "@x39"

    formattedMsg = outerColor .. "[" .. innerColor .. ooc.name .. outerColor .. "]@w " .. msg .. "@w"
  end -- if

  return formattedMsg
end -- ooc.printFormat


function ooc.printColors(msg)
  print(AnsiNote(stylesToANSI(ColoursToStyles(msg))))
end -- ooc.printColors


function ooc.print(msg)
  if (msg ~= nil) and (msg ~= "") then
    local formattedMsg = ooc.printFormat(msg)
    ooc.printColors(formattedMsg)

    -- If the user wants us to mirror messages to the commlog, do it :)
    local commlogState = ooc.commlogGet()
    if (commlogState == "on") then
      ooc.commLog(formattedMsg)
    end -- if
  end -- if

end -- ooc.print()


function ooc.error(msg)
  if (msg ~= nil) and (msg ~= "") then
    ooc.print("@RERROR@w " .. msg)
  end -- if
end -- ooc.error


function ooc.getRoom()
  local roomId = tonumber(ooc.getRoomId() or "") or -1
  local room = ooc.roomIdToRoom(roomId) or -1

  return room, roomId
end -- ooc.getRoom()


function ooc.getRoomId()
  return gmcp("room.info.num")
end -- ooc.getRoomId()


function ooc.roomIdToRoom(roomId)
  local roomIdNum = tonumber(roomId or "") or -1
  local room = -1

  for r, entry in pairs(ooc.rooms) do
    if (entry.r == roomIdNum) then
      room = r
      break
    end -- if
  end -- for

  return room
end -- ooc.roomIdToRoom


function ooc.getName()
  local name = ""
  local pretitle = ""
  local char = gmcp("char.base")

  if (char ~= nil) then
    name = (char.name or "nil")
    pretitle = (char.pretitle or "nil")
  end -- if

  return name, pretitle
end -- ooc.getName


function ooc.inCombat()
  local inCombat = false
  local charStatus = gmcp("char.status")

  if (charStatus ~= nil) and (charStatus.state == "8") then
    inCombat = true
  end -- if

  return inCombat
end -- ooc.inCombat


function ooc.commLog(msg)
  local clPlugin   = "b555825a4a5700c35fa80780"
  local clFunction = "storeFromOutside"

  if (msg == nil) or (msg == "") then
    print("ooc.commLog: Missing message parameter")
    return error_code.eBadParameter
  end -- if

  local retval = CallPlugin(clPlugin, clFunction, msg)

  if (retval == error_code.eNoSuchPlugin) then
    print("ooc.commLog: target plugin does not exist")

  elseif (retval == error_code.ePluginDisabled) then
    print("ooc.commLog: target plugin is disabled")

  elseif (retval == error_code.eNoSuchRoutine) then
    print("ooc.commLog: target routine does not exist")

  elseif (retval == error_code.eErrorCallingPluginRoutine) then
    print("ooc.commLog: error calling plugin routine")

  elseif (retval ~= error_code.eOK) then
    print("ooc.commLog: Unknown return value from CallPlugin: " .. (retval or "nil"))

  end -- if

  return retval
end -- ooc.commLog


function ooc.isWordInString(word, field)
  if (word == nil) or (word == "") or (field == nil) or (field == "") then
    return false
  end -- if

  for element in field:gmatch("%S+") do
    if (string.lower(word) == string.lower(element)) then
      return true
    end -- if
  end -- for

  return false
end -- ooc.isWordInString


]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="ooc:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
