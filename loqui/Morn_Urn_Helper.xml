<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, March 26, 2017, 12:51 PM -->
<!-- MuClient version 4.98 -->

<!-- Plugin "Morn_Urn_Helper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Morn_Urn_Helper"
   author="Morn"
   id="57d5014f9fcbb8e2d4a7829b"
   language="Lua"
   purpose="Utilities for placing items in and retrieving nosave items from a floor container"
   save_state="y"
   date_written="2017-03-26 12:49:12"
   requires="4.98"
   version="0.1"
   >

<description trim="y">
<![CDATA[
===============================================================================
                     Urn Helper v0.1
                        By Morn

Purpose:
   
   Automate the process of dumping all your nosave items into the Urn (or
   whatever you have) before quitting as well as retrieving them when you log
   back in. This plugin sends and parses the output of "quit check" to see what
   items need to be dumped in the urn.

Setup:

   Run "urn set <your urn's keyword>" to set the urn

Usage:
    
   urn put:
     Put all of your nosave items in the urn and safely quit. If you need to
     close MUSHclient, make sure the world is saved (Ctrl+S) so the plugin
     knows what items to retrieve later.
    
   urn get:
     Get everything back from the urn and put them where they were (inv,
     keyring or containers)

   urn help:
     Show this message

Note: This plugin handles items in your INVENTORY, KEYRING and CONTAINERS only.
      Your nosave items in your vault are not touched by this plugin.

That is all.

===============================================================================
]]>
</description>

</plugin>


<aliases>
  <alias
   name="urn_help"
   match="urn help"
   enabled="y"
   script="urn_print_help"
   sequence="100"
  >
  </alias>

  <alias
   name="urn_put"
   match="urn put"
   enabled="y"
   script="urn_put"
   sequence="100"
  >
  </alias>

  <alias
   name="urn_get"
   match="urn get"
   enabled="y"
   script="urn_get"
   sequence="100"
  >
  </alias>

  <alias
   name="urn_set"
   match="urn set *"
   enabled="y"
   script="urn_set"
   sequence="100"
  >
  </alias>

  <alias
   name="urn_reload"
   match="urn reload"
   enabled="y"
   script="urn_reload"
   sequence="100"
  >
  </alias>
</aliases>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<script>
<![CDATA[

require("wait")

function OnPluginInstall()
  urn_print_help();
end

function urn_print_help()
  urn_note(GetPluginInfo(GetPluginID(), 3))
end

urn_note_fg = "magenta"
urn_note_bg = "black"
function urn_note(msg)
  ColourNote(urn_note_fg, urn_note_bg, tostring(msg))
end

-- WARNING: Does not work
function urn_reload()
  local id = GetPluginID()
  Note(ReloadPlugin(id))
  urn_note("Reloaded " .. GetPluginInfo(id, 1))
end

function urn_set(name, line, wildcards)
  local urn_item = wildcards[1]
  SetVariable("UrnItem", urn_item)
  urn_note("Set urn item to " .. urn_item)
end

function urn_put(name, line, wildcards)
  local urn = GetVariable("UrnItem")
  if urn == nil then
    urn_note("There is no urn! Set it with 'urn set <item>'.")
    return
  end

  wait.make(function()
    -- First check if the urn is even there
    SendNoEcho("rlook " .. urn)
    local res = wait.regexp("^(You don't see that here.|.*?)$")

    if res == "You don't see that here." then
      urn_note("Your urn is not there!")
      return
    end


    local store_cmds, retr_cmds = get_store_retr_cmds()


    local full_store_cmd, full_retr_cmd
    full_store_cmd = table.concat(store_cmds, ";")
    full_retr_cmd = table.concat(retr_cmds, ";")

    SetVariable("UrnRetrieveCommand", full_retr_cmd)
    Execute(full_store_cmd)

  end)
end

function get_store_retr_cmds()
  local result = ""
  local close_tag = "{/quitcheck}"
  local close_tag_regex = "^\\{\\/quitcheck\\}$"
  local qcheck_line_regex = "^\\[\\s*\\d+\\]\\s\\(\\w+\\)\\s*\\-\\s(?<item_id>\\d+)(?:.*\\((?:(?<keyring>[^\\s]*?)|inside .+?\\/(?<container>\\d+))\\)|.*)$"
  local qcheck_line_regex_full = "(?:" .. qcheck_line_regex .. "|" .. close_tag_regex .. ")"

  local line, wildcards

  local count = 0
  local safe_max_count = 5000

  SendNoEcho("quit check")
  SendNoEcho("echo {/quitcheck}")

  local store_cmds, store_cmd, retr_cmds, retr_cmd
  store_cmds = {}
  retr_cmds = {}

  require("tprint")
  while true do
    line, wildcards = wait.regexp(qcheck_line_regex_full)
    if line == close_tag then
      break
    end

    store_cmd, retr_cmd = qcline_to_cmds(wildcards)
    table.insert(store_cmds, store_cmd)
    table.insert(retr_cmds, retr_cmd)

    count = count + 1
    if count > safe_max_count then
      urn_note("Too many items in 'quit check'! Stopping.")
      break
    end

  end

  return store_cmds, retr_cmds

end

function qcline_to_cmds(wildcards)
  local id = wildcards.item_id
  local keyring = wildcards.keyring
  local container = wildcards.container
  local urn_item = GetVariable("UrnItem")

  local store_cmd, retr_cmd
  retr_cmd = ""
  store_cmd = ""
  if #keyring > 0 then
    store_cmd = string.format("keyring get %s;", id)
    retr_cmd = string.format(";keyring put %s", id)
  elseif #container > 0 then
    store_cmd = string.format("get %s %s;", id, container)
    retr_cmd = string.format(";put %s %s", id, container)
  end

  store_cmd = store_cmd .. "put " .. id .. " ".. urn_item
  retr_cmd = "get " .. id .. " " .. urn_item .. retr_cmd

  return store_cmd, retr_cmd
end

function urn_get(name, line, wildcards)
  local retr_cmd = GetVariable("UrnRetrieveCommand") 
  if retr_cmd == nil then
    urn_note("You don't have a retrieve command stored.")
  else
    Execute(retr_cmd)
  end
end
]]>
</script>

</muclient>
