<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, January 21, 2019, 9:10 AM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "Trainer" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Trainer"
   author="Castiel"
   id="89c5f5d45d0fe1d827b53a39"
   language="Lua"
   purpose="Makes training easier"
   save_state="y"
   date_written="2019-01-21 09:09:33"
   requires="4.84"
   version="1.0"
   >
   <description trim="n">
   		<![CDATA[
.----------------------------------------------------------------------------.
| Trainer Help                                                               |
|----------------------------------------------------------------------------|
|train help -- Brings up the help section. (What you are reading now)        |
|                                                                            |
|train stats -- Attempts to train based on your train order.                 |
|                                                                            |
|train order                - Shows your current training priorities.        |
|train reset                - Resets any training priorities.                |
|train add <stat> <amount>  - Set up a new stat order with amount supplied.  |
|train rem <ind>            - Remove a stat order based on its index seen in |
|                             Train Order.                                   |
|train move <ind> <up|down> - Move a stat priority up or down based on index |
|train adjust <ind> <amount>- Changes the stat at index to the new amount.   |
'----------------------------------------------------------------------------'
]]>
</description>
</plugin>

<aliases>
	<alias script="doTrain" match="^train stats$" enabled="y" regexp="y"></alias>
	<alias script="showTrainHelp" match="^train help$" enabled="y" regexp="y"></alias>
	<alias script="showTrainOrder" match="^train order$" enabled="y" regexp="y"></alias>
	<alias script="resetTrainOrder" match="^train reset$" enabled="y" regexp="y"></alias>
	<alias script="addTrainStat" match="^train add (?<stat>.*) (?<amount>[0-9]+)$" enabled="y" regexp="y"></alias>
	<alias script="remTrainStat" match="^train rem(ove)? (?<ind>.*)$" enabled="y" regexp="y"></alias>
	<alias script="moveTrainStat" match="^train move (?<ind>.*) (?<dir>up|down|u|d)$" enabled="y" regexp="y"></alias>
	<alias script="adjustTrainStat" match="^train adjust (?<ind>.*) (?<amount>[0-9]+)$" enabled="y" regexp="y"></alias>
</aliases>

<triggers>
<trigger group="trainerStat" regexp="y" match="^(?<stat>Strength|Intelligence|Wisdom|Dexterity|Constitution|Luck)\s+:\s+(?<base>[0-9]+)\s+(?<race>\-?[0-9]+)\s+(?<tier>\-?[0-9]+)\s+(?<wish>\-?[0-9]+)\s+(?<cost>[0-9]+)\s+(?<cur>[0-9]+)\s+(?<max>[0-9]+)(\*)?$" enabled="n" sequence="100" script="updateStat"></trigger>
<trigger group="trainerStat" regexp="y" match="^You have (?<trains>[0-9]+) training sessions? available\.$" enabled="n" sequence="100" script="updateTrains"></trigger>

</triggers>

<include name="constants.lua"/>

<script>
<![CDATA[
   require "serialize"
	
local curStats = {}
local trainOrder = {}
if GetVariable("trainOrder") ~= nil then
   luastmt = "obj = " .. GetVariable("trainOrder")
   assert (loadstring (luastmt or "")) ()		
   trainOrder = obj
end

local trainOrderSize = tonumber(GetVariable("trainOrderSize") or 0)
local curTrains = 0
local statLookup = {
   ["str"] = "Strength",
   ["strength"] = "Strength",
   ["int"] = "Intelligence",
   ["intelligence"] = "Intelligence",
   ["wis"] = "Wisdom",
   ["wisdom"] = "Wisdom",
   ["dex"] = "Dexterity",
   ["dexterity"] = "Dexterity",
   ["con"] = "Constitution",
   ["constitution"] = "Constitution",
   ["lck"] = "Luck",
   ["luck"] = "Luck"
}

function showTrainHelp()
   ColourNote("orange", "black", GetPluginInfo (GetPluginID (), 3))
end

function showTrainOrder(name, line, wildcards)
   ColourNote("green", "", "Ind     Stat     Amount")
   ColourNote("cyan", "", "--- ------------ ------")
   for i, v in spairs(trainOrder, function(t,a,b) return a < b end) do
      ColourNote("silver", "", string.format("%3i %-12s %6i", i, v.stat, v.amount))
   end
end

function resetTrainOrder(name, line, wildcards)
   trainOrder = {}
   trainOrderSize = 0
   SetVariable("trainOrder", serialize.save_simple(trainOrder))
   SetVariable("trainOrderSize", trainOrderSize)
   ColourNote("orange", "", "Training order has been reset.")
end

function addTrainStat(name, line, wildcards) --stat/amount
   
   if statLookup[string.lower(wildcards.stat)] == nil then --Stat could not be found
      ColourNote("orange", "", "The stat " .. wildcards.stat .. " could not be found.")
      return
   end

   if tonumber(wildcards.amount) < 20 or tonumber(wildcards.amount) > 400 then
      ColourNote("orange", "", "The stat amount was out of range. Must be between 20 and 400.")
      return
   end
   
   local tStat = statLookup[string.lower(wildcards.stat)]
   trainOrder[trainOrderSize] = { stat = tStat, amount = tonumber(wildcards.amount) }
   trainOrderSize = trainOrderSize + 1
   ColourNote("orange", "", "A new stat order for " .. tStat .. " has been set for " .. wildcards.amount .. ".")
   SetVariable("trainOrder", serialize.save_simple(trainOrder))
   SetVariable("trainOrderSize", trainOrderSize)
   showTrainOrder()
end

function remTrainStat(name, line, wildcards) --ind
   local tNum = tonumber(wildcards.ind)
   if trainOrder[tNum] == nil then
      ColourNote("orange", "", "There is no index at " .. tNum)
      return
   end

   if tNum < trainOrderSize then
      repeat
         trainOrder[tNum] = trainOrder[tNum+1]
         tNum = tNum + 1
      until tNum == trainOrderSize
   end

   trainOrder[tNum] = nil
   trainOrderSize = trainOrderSize - 1
   ColourNote("orange", "", "You have successfully removed a stat priority.\n\r")
   SetVariable("trainOrder", serialize.save_simple(trainOrder))
   SetVariable("trainOrderSize", trainOrderSize)
   showTrainOrder()
end

function moveTrainStat(name, line, wildcards) --ind/dir(u/d/up/down)
   local tNum = tonumber(wildcards.ind)
   local dir = string.lower(wildcards.dir)
   local dest = tNum
   if trainOrder[tNum] == nil then
      ColourNote("orange", "", "There is no index at " .. tNum)
      return
   end
   if dir == "d" or dir == "down" then
      if trainOrder[tNum+1] == nil then --Already at the end, do nothing.
         ColourNote("orange", "", "Index " .. tNum .. " is already at the bottom!")
         return
      end
      dest = tNum+1
   elseif dir == "u" or dir == "up" then
      if trainOrder[tNum-1] == nil then --Already at the top, do nothing.
         ColourNote("orange", "", "Index " .. tNum .. " is already at the top!")
         return
      end
      dest = tNum-1
   end
   local tStat = trainOrder[dest]
   trainOrder[dest] = trainOrder[tNum]
   trainOrder[tNum] = tStat
   ColourNote("orange", "", "You have successfully adjusted the training order.\n\r")
   SetVariable("trainOrder", serialize.save_simple(trainOrder))
   SetVariable("trainOrderSize", trainOrderSize)
   showTrainOrder()
end

function adjustTrainStat(name, line, wildcards)
   local tNum = tonumber(wildcards.ind)
   local tAmt = tonumber(wildcards.amount)
   if trainOrder[tNum] == nil then
      ColourNote("orange", "", "There is no index at " .. tNum)
      return
   end
   if tAmt < 20 or tAmt > 400 then --Out of bounds
      ColourNote("orange", "", "The stat amount was out of range. Must be between 20 and 400.")
      return
   end

   trainOrder[tNum].amount = tAmt
   ColourNote("orange", "", "Index " .. tNum .. " has been set to " .. tAmt .. ".")
   SetVariable("trainOrder", serialize.save_simple(trainOrder))
   showTrainOrder()
end

function updateTrains(name, line, wildcards)
   curTrains = tonumber(wildcards.trains)
   EnableTriggerGroup("trainerStat", false)
   finishTraining()
end

function updateStat(name, line, wildcards)

   if curStats[wildcards.stat] == nil then
      curStats[wildcards.stat] = { base = 0, race = 0, tier = 0, wish = 0, cost = 0, cur = 0, max = 0 }
   end

   curStats[wildcards.stat].base = tonumber(wildcards.base)
   curStats[wildcards.stat].race = tonumber(wildcards.race)
   curStats[wildcards.stat].tier = tonumber(wildcards.tier)
   curStats[wildcards.stat].wish = tonumber(wildcards.wish)
   curStats[wildcards.stat].cost = tonumber(wildcards.cost)
   curStats[wildcards.stat].cur = tonumber(wildcards.cur)
   curStats[wildcards.stat].max = tonumber(wildcards.max)
end

function doTrain(name, line, wildcards)
   Send("gain convertall")
   Send("train")
   EnableTriggerGroup("trainerStat", true)
end

function finishTraining() --Here's where we ACTUALLY train!
   if curTrains == 0 then
      return --No trains to do anything with.
   end

   for i, v in spairs(trainOrder, function(t,a,b) return a < b end) do
      if curStats[v.stat].cur < curStats[v.stat].max then --Not at max stat, so can be trained!
         if v.amount > curStats[v.stat].cur then --The current training order needs to be fulfilled.
            if v.amount > curStats[v.stat].max then --The current training order exceeds our max, so just fill to max.
               local tAmt = curStats[v.stat].max - curStats[v.stat].cur --The # of stats to train
               if (tAmt*curStats[v.stat].cost) > curTrains then --Requires more than we can give! (In trains)
                  tAmt = math.floor(curTrains/curStats[v.stat].cost)
               end
               if tAmt > 0 then
                  Send("train " .. tAmt .. " " .. v.stat) --Actual training message
                  curTrains = curTrains - math.floor(tAmt*curStats[v.stat].cost)
               end
            else --Train to fill the order
               local tAmt = v.amount - curStats[v.stat].cur
               if (tAmt*curStats[v.stat].cost) > curTrains then --Requires more than we can give! (In trains)
                  tAmt = math.floor(curTrains/curStats[v.stat].cost)
               end
               if tAmt > 0 then
                  Send("train " .. tAmt .. " " .. v.stat)
                  curTrains = curTrains - math.floor(tAmt*curStats[v.stat].cost)
               end
            end
         end
      end

      if curTrains == 0 then
         return --Ran out of trains to do anything with.
      end
   end
end

function spairs(t, order)
   -- collect the keys
   local keys = {}
   for k in pairs(t) do keys[#keys+1] = k end

   -- if order function given, sort by it by passing the table and keys a, b,
   -- otherwise just sort the keys 
   if order then
      table.sort(keys, function(a,b) return order(t, a, b) end)
   else
      table.sort(keys)
   end

   -- return the iterator function
   local i = 0
   return function()
      i = i + 1
      if keys[i] then
         return keys[i], t[keys[i]]
      end
   end
end

]]>
</script>


</muclient>