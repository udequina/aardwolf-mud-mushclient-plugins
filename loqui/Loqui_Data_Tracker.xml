<muclient>
<plugin
   name="Damage_Tracker"
   author="Nokfah and Castiel"
   id="3b37d0d96e58f12563a70452"
   language="Lua"
   purpose="Tracks damage of players in group"   
   save_state="y"
   version="1.0"
   >
   <description trim="n">
   		<![CDATA[
.----------------------------------------------------------------------------|
| Loqui Data Tracker Help
|----------------------------------------------------------------------------|
|ldt help -- Brings up the help section. (What you are reading now)          |
|ldt uptime -- Shows how long you've been tracking data.                     |
|                                                                            |
|ldt show <player>(optional)  -- output all damage info to the main window   |
|                                optionally filter on a single player        |
|                                                                            |
|ldt clear/reset <option> -- clear tracking data. Available options: dodges, |
|                            damage/dmg, exp, gold, pups, lvls, deaths and   |
|                            all.                                            |
|                                                                            |
|ldt gag <option>  -- toggles gagging of specific data. Options are: me/self,|
|                     others, dodges, pups, lvls, deaths and all.            |
|ldt sort <type>(optional) -- Toggles the sorting method.                    |
|ldt filter <amount> -- Filters detailed window attacks by this %. Must be   |
|                       between 0-100.                                       |
|ldt pupfilter <amount> -- Filters detailed window pups that fall below      |
|                       this value. Must be between 0 and 100.               |
|ldt pupthreshold <amount> -- Filters pups that take longer than this value. |
|                             Must be between 0 and 10000.                   |
|ldt dodges  -- report dodges to your screen.                                |
|ldt rounds|rooms <y|n> -- toggles round/room display.                       |
|                                                                            |
|ldt throttle <y|n>  -- limit the redraws of minwins to 10/second            |
|                                                                            |
|ldt details <text>(optional) -- Manually show the details window, targeting |
|                                <text> if supplied.                         |
|                                                                            |
|ldt total <channel>  -- report overall damage to a channel                  |
|ldt types <channel>  -- report damage by type to a channel                  |
|ldt deaths <clan> <player> -- Displays detailed death info of player.       |
|                                                                            |
|ldt goal <type> <amount> -- Types: exp, gold, lvl, pup. Ex: ldt goal lvl 10 |
|ldt goal reset <type/all> -- Resets the individual goal or all goals.       |
|ldt goal report <type> <channel>                                            |
|                                                                            |
|ldt showcolour         -- list all colours                                  |
|ldt addcolour <colour> -- add a colour to the list                          |
|ldt remcolour <#>      -- remove a colour from the list                     |
|                                                                            |
|ldt win reset     -- reset the window                                       |
|ldt win show/hide -- show or hide the window                                |
|                                                                            |
|ldt playerwin <show|hide>           -- show or hide the player window       |
|ldt playerwin <vertical|horizontal> -- change the orientation of the window |
|ldt playerwin <num>                 -- The number of seconds to collect data|
'----------------------------------------------------------------------------'
]]>
</description>
</plugin>




<!-- ************************CHANGELOG*************************
-Added min/max to dmg/dmg received.
-Added mouse over for min/max dmg(hover over the rank #'s)
*************************************************************** -->





<aliases>
  <alias regexp="y" match="^ldt help$" enabled="y" script="Help"></alias>
  <alias regexp="y" match="^ldt show$" enabled="y" script="Show"></alias>
  <alias regexp="y" match="^ldt show (.*)$" enabled="y" script="ShowPlayer"></alias>
  <alias regexp="y" match="^ldt (clear|reset) (.*)$" enabled="y" script="Clear"></alias>
  <alias regexp="y" match="^ldt goal (exp|gold|lvl|pup) ([0-9]+)$" enabled="y" script="SetGoal"></alias>
  <alias regexp="y" match="^ldt goal reset (exp|gold|lvl|pup|all)$" enabled="y" script="ResetGoal"></alias>
  <alias regexp="y" match="^ldt goal report (exp|gold|lvl|pup) (.*)$" enabled="y" script="ReportGoal"></alias>
  <alias regexp="y" match="^ldt gag (.*)$" enabled="y" script="GagType"></alias>
  <alias regexp="y" match="^ldt sort( (?<type>\w+))?$" enabled="y" script="Sort"></alias>
  <alias regexp="y" match="^ldt filter (.*)$" enabled="y" script="Filter"></alias>  
  <alias regexp="y" match="^ldt pupfilter (.*)$" enabled="y" script="PupFilter"></alias>  
  <alias regexp="y" match="^ldt pupthreshold (.*)$" enabled="y" script="PupThreshold"></alias>  
  <alias regexp="y" match="^ldt throttle (y|n)$" enabled="y" script="Throttle"></alias>  
  <alias regexp="y" match="^ldt total (.*)$" enabled="y" script="ReportTotal"></alias>
  <alias regexp="y" match="^ldt types (.*)$" enabled="y" script="ReportTypes"></alias>
  <alias regexp="y" match="^ldt dodges$" enabled="y" script="ReportDodges"></alias>
  <alias regexp="y" match="^ldt details(.*)$" enabled="y" script="TypeToOpenDetailWindow"></alias>
  <alias regexp="y" match="^ldt deaths (.*) (.*)$" enabled="y" script="DisplayDeaths"></alias>
  <alias regexp="y" match="^ldt uptimes?$" enabled="y" script="DisplayUptime"></alias>

  <alias regexp="y" match="^ldt round (.*)$" enabled="y" script="SetRoundDelimiter"></alias>
  <alias regexp="y" match="^ldt rounds (y|n)$" enabled="y" script="ReportRoundsToggle"></alias>
  <alias regexp="y" match="^ldt rooms$" enabled="y" script="ReportRooms"></alias>
  <alias regexp="y" match="^ldt rooms (y|n)$" enabled="y" script="ReportRoomsToggle"></alias>    
  <alias regexp="y" match="^ldt rooms clear$" enabled="y" script="ClearRooms"></alias>    

  <alias regexp="y" match="^ldt win show$" script="ShowWindow" enabled="y" sequence="100" ignore_case="y"></alias>
  <alias regexp="y" match="^ldt win hide$" script="HideWindow" enabled="y" sequence="100" ignore_case="y"></alias>
  <alias regexp="y" match="^ldt win reset$" script="userReset" enabled="y" sequence="100" ignore_case="y"></alias>

  <alias regexp="y" match="^ldt playerwin show$" script="ShowPlayerWindow" enabled="y" sequence="100" ignore_case="y"></alias>
  <alias regexp="y" match="^ldt playerwin hide$" script="HidePlayerWindow" enabled="y" sequence="100" ignore_case="y"></alias>
  <alias regexp="y" match="^ldt playerwin (horizontal|vertical)$" script="SetPlayerWinOrientation" enabled="y" sequence="100" ignore_case="y"></alias>
  <alias regexp="y" match="^ldt playerwin ([0-9]+)" script="SetRollingWindowDuration" enabled="y" sequence="100" ignore_case="y"></alias>

  <alias regexp="y" match="^ldt showcolour$" enabled="y" script="ShowColour"></alias>
  <alias regexp="y" match="^ldt addcolour (\w+)$" enabled="y" script="AddColour"></alias>
  <alias regexp="y" match="^ldt remcolour ([0-9]+)$" enabled="y" script="RemoveColour"></alias>

  <alias regexp="y" match="^ldt watchlvl (.*)$" enabled="y" script="WatchLevel"></alias>

  <alias regexp="y" match="^ldt manual (.*)$" enabled="y" script="ToggleManual"></alias>
  <alias regexp="y" match="^ldt remove (.*)$" enabled="y" script="RemFromGroup"></alias>
</aliases>

<triggers>

	<!-- damage triggers -->
	<trigger name="mydamage_dealt"	
		regexp="y" match="^(?<crit>\*)?(?:\[(?<hits>\d+)\] )?(?<player>You)r (?<attack>.*) (?:decimates|devastates|rends|incinerates|lacerates|obliterates|massacres|disembowels|extirpates|eradicates|dismembers|mutilates|tickles|bruises|scratches|grazes|nicks|scars|hits|injures|wounds|mauls|maims|mangles|mars|LACERATES|DECIMATES|DEVASTATES|ERADICATES|OBLITERATES|EXTIRPATES|INCINERATES|MUTILATES|DISEMBOWELS|MASSACRES|DISMEMBERS|RENDS|blasts|demolishes|shreds|destroys|pulverizes|vaporizes|atomizes|asphyxiates|ravages|fissures|liquidates|evaporates|sunders|tears into|wastes|cremates|annihilates|implodes|exterminates|shatters|slaughters|ruptures|nukes|glaciates|meteorites|supernovas|damages|- BLASTS -|-= DEMOLISHES =-|\*\* SHREDS \*\*|\*\*\*\* DESTROYS \*\*\*\*|\*\*\*\*\* PULVERIZES \*\*\*\*\*|-=- VAPORIZES -=-|\<-==-\> ATOMIZES \<-==-\>|\<-:-\> ASPHYXIATES \<-:-\>|\<-\*-\> RAVAGES \<-\*-\>|\<\>\*\<\> FISSURES \<\>\*\<\>|\<\*\>\<\*\> LIQUIDATES \<\*\>\<\*\>|\<\*\>\<\*\>\<\*\> EVAPORATES \<\*\>\<\*\>\<\*\>|\<-=-\> SUNDERS \<-=-\>|\<=-=\>\<=-=\> TEARS INTO \<=-=\>\<=-=\>|\<-\>\*\<=\> WASTES \<=\>\*\<-\>|\<-\+-\>\<-\*-\> CREMATES \<-\*-\>\<-\+-\>|\<\*\>\<\*\>\<\*\>\<\*\> ANNIHILATES \<\*\>\<\*\>\<\*\>\<\*\>|\<--\*--\>\<--\*--\> IMPLODES \<--\*--\>\<--\*--\>|\<-\>\<-=-\>\<-\> EXTERMINATES \<-\>\<-=-\>\<-\>|\<-==-\>\<-==-\> SHATTERS \<-==-\>\<-==-\>|\<\*\>\<-:-\>\<\*\> SLAUGHTERS \<\*\>\<-:-\>\<\*\>|\<-\*-\>\<-\>\<-\*-\> RUPTURES \<-\*-\>\<-\>\<-\*-\>|\<-\*-\>\<\*\>\<-\*-\> NUKES \<-\*-\>\<\*\>\<-\*-\>|-\<\[=-\+-=\]\<:::\<\>:::\> GLACIATES \<:::\<\>:::\>\[=-\+-=\]\>-|\<-=-\>\<-:-\*-:-\>\<\*--\*\> METEORITES \<\*--\*\>\<-:-\*-:-\>\<-=-\>|\<-:-\>\<-:-\*-:-\>\<-\*-\> SUPERNOVAS \<-\*-\>\<-:-\*-:-\>\<-:-\>|does UNSPEAKABLE things to|does UNTHINKABLE things to|does UNIMAGINABLE things to|does UNBELIEVABLE things to) (?:.*). \[(?<damage>\d+)\]\*?$"
		enabled="y" sequence="200" script="DamageDealt"		
	></trigger>

	<trigger name="mydamage_received"
		regexp="y" match="^(?<crit>\*)?(?:\[(?<hits>\d+)\] )?(?<enemy>.*)'s? (?<attack>.*) (?:decimates|devastates|rends|incinerates|lacerates|obliterates|massacres|disembowels|extirpates|eradicates|dismembers|mutilates|tickles|bruises|scratches|grazes|nicks|scars|hits|injures|wounds|mauls|maims|mangles|mars|LACERATES|DECIMATES|DEVASTATES|ERADICATES|OBLITERATES|EXTIRPATES|INCINERATES|MUTILATES|DISEMBOWELS|MASSACRES|DISMEMBERS|RENDS|blasts|demolishes|shreds|destroys|pulverizes|vaporizes|atomizes|asphyxiates|ravages|fissures|liquidates|evaporates|sunders|tears into|wastes|cremates|annihilates|implodes|exterminates|shatters|slaughters|ruptures|nukes|glaciates|meteorites|supernovas|damages|- BLASTS -|-= DEMOLISHES =-|\*\* SHREDS \*\*|\*\*\*\* DESTROYS \*\*\*\*|\*\*\*\*\* PULVERIZES \*\*\*\*\*|-=- VAPORIZES -=-|\<-==-\> ATOMIZES \<-==-\>|\<-:-\> ASPHYXIATES \<-:-\>|\<-\*-\> RAVAGES \<-\*-\>|\<\>\*\<\> FISSURES \<\>\*\<\>|\<\*\>\<\*\> LIQUIDATES \<\*\>\<\*\>|\<\*\>\<\*\>\<\*\> EVAPORATES \<\*\>\<\*\>\<\*\>|\<-=-\> SUNDERS \<-=-\>|\<=-=\>\<=-=\> TEARS INTO \<=-=\>\<=-=\>|\<-\>\*\<=\> WASTES \<=\>\*\<-\>|\<-\+-\>\<-\*-\> CREMATES \<-\*-\>\<-\+-\>|\<\*\>\<\*\>\<\*\>\<\*\> ANNIHILATES \<\*\>\<\*\>\<\*\>\<\*\>|\<--\*--\>\<--\*--\> IMPLODES \<--\*--\>\<--\*--\>|\<-\>\<-=-\>\<-\> EXTERMINATES \<-\>\<-=-\>\<-\>|\<-==-\>\<-==-\> SHATTERS \<-==-\>\<-==-\>|\<\*\>\<-:-\>\<\*\> SLAUGHTERS \<\*\>\<-:-\>\<\*\>|\<-\*-\>\<-\>\<-\*-\> RUPTURES \<-\*-\>\<-\>\<-\*-\>|\<-\*-\>\<\*\>\<-\*-\> NUKES \<-\*-\>\<\*\>\<-\*-\>|-\<\[=-\+-=\]\<:::\<\>:::\> GLACIATES \<:::\<\>:::\>\[=-\+-=\]\>-|\<-=-\>\<-:-\*-:-\>\<\*--\*\> METEORITES \<\*--\*\>\<-:-\*-:-\>\<-=-\>|\<-:-\>\<-:-\*-:-\>\<-\*-\> SUPERNOVAS \<-\*-\>\<-:-\*-:-\>\<-:-\>|does UNSPEAKABLE things to|does UNTHINKABLE things to|does UNIMAGINABLE things to|does UNBELIEVABLE things to) (?<player>you). \[(?<damage>\d+)\]$"
		enabled="y" sequence="200" script="DamageReceived"		
	></trigger>

	<trigger name="my_miss"	
		regexp="y" match="^(?:\[(?<hits>\d+)\] )?(?<player>You)r (?<attack>.*) (?:misses) (?:.*). \[(?<damage>\d+)\]$"
		enabled="y" sequence="200" script="DamageDealt"		
	></trigger>

	<trigger name="enemy_miss"
		regexp="y" match="^(?:\[(?<hits>\d+)\] )?(?<enemy>.*)'s? (?<attack>.*) (?:misses) (?<player>you). \[(?<damage>\d+)\]$"
		enabled="y" sequence="200" script="DamageReceived"		
	></trigger>


	<!-- heal triggers -->
	<trigger regexp="y" match="^(?:\[\d\] )?A warm feeling fills your body\. \[([0-9]+)\]$" enabled="y" sequence="100" script="Healed"></trigger>
	<trigger regexp="y" match="^You feel your life restored\. \[([0-9]+)\]$" enabled="y" sequence="100" script="Healed"></trigger>
	<trigger regexp="y" match="^You feel your life renewed\. \[([0-9]+)\]$" enabled="y" sequence="100" script="Healed"></trigger>
	<trigger regexp="y" match="^You are greatly healed by .* magic touch\. \[([0-9]+)\]$" enabled="y" sequence="100" script="Healed"></trigger>		

	<!-- dodge triggers -->
	<trigger name="dodgesParry" regexp="y" match="^You parry (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Parry")</send></trigger>
	<trigger name="dodgesDodge" regexp="y" match="^You dodge (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Dodge")</send></trigger>
	<trigger name="dodgesShieldBlock" regexp="y" match="^You block (?<enemy>.*)'s? attack with your shield.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Shield Block")</send></trigger>
	<trigger name="dodgesTimeShift" regexp="y" match="^You create a time shift and calmly step away from (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Time Shift")</send></trigger>
	<trigger name="dodgesHolyIntervention" regexp="y" match="^You sense divine intervention as (?<enemy>.*)'s? attack narrowly misses you.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Holy Intervention")</send></trigger>
	<trigger name="dodgesCamouflage" regexp="y" match="^You blend perfectly with your surroundings and avoid (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Camouflage")</send></trigger>
	<trigger name="dodgesMisdirect" regexp="y" match="^You misdirect (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Misdirection")</send></trigger>
	<trigger name="dodgesHolyRift" regexp="y" match="^(?<deity>.*)'s? holy rift protects you from (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Holy Rift")</send></trigger>
	<trigger name="dodgesBlink" regexp="y" match="^You blink out of existence and avoid (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Blink")</send></trigger>
	<trigger name="dodgesInstinct" regexp="y" match="^You instinctively dodge (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Instinct")</send></trigger>
	<trigger name="dodgesLucky" regexp="y" match="^You get lucky and manage to escape (?<enemy>.*)'s? attack.$" enabled="y" sequence="100" send_to="12"><send>Dodged("Lucky")</send></trigger>
	<trigger name="enemyDodge" regexp="y" match="^(?<enemy>.*) dodges your attack.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Dodge")</send></trigger>
	<trigger name="enemyBlink" regexp="y" match="^(?<enemy>.*) blinks out of existence avoiding your attack.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Blink")</send></trigger>
	<trigger name="enemyParry" regexp="y" match="^(?<enemy>.*) parries your attack.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Parry")</send></trigger>
	<trigger name="enemyCamouflage" regexp="y" match="^(?<enemy>.*) blends in perfectly causing you to hit nothing but air.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Camouflage")</send></trigger>
	<trigger name="enemyMisdirection" regexp="y" match="^(?<enemy>.*) misdirects your attack.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Misdirection")</send></trigger>
	<trigger name="enemyTimeShift" regexp="y" match="^(?<enemy>.*) fiddles with time and your attack is just a few seconds slow.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Time Shift")</send></trigger>
	<trigger name="enemyLucky" regexp="y" match="^(?<enemy>.*) gets lucky and avoids your hit.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Lucky")</send></trigger>
	<trigger name="enemyHolyRift" regexp="y" match="^.* holy rift protects (?<enemy>.*) from your attack.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Holy Rift")</send></trigger>
	<trigger name="enemyShieldBlock" regexp="y" match="^(?<enemy>.*) blocks your attack with (?:his|her|its) shield\.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Shield Block")</send></trigger>
	<trigger name="enemyHolyIntervention" regexp="y" match="^(?<enemy>.*) avoids your attack, almost too easily\.$" enabled="y" sequence="100" send_to="12"><send>EnemyDodged("Holy Intervention")</send></trigger>
	

	<!-- exp triggers -->
	<trigger name="expNormal" regexp="y" match="^You receive (?<amount>.*) experience points?\.$" enabled="y" sequence="100" script="AddExp"></trigger>
	<trigger name="expDouble" regexp="y" match="^You receive (?<amount>[0-9]+) bonus experience points? (in honor of|courtesy of|to rejoice)" enabled="y" sequence="100" script="AddExp"></trigger>
	<trigger name="expRare" regexp="y" match="^You receive (?<amount>[0-9]+) 'rare kill' experience bonus\.$" enabled="y" sequence="100" script="AddExp"></trigger>
	<trigger name="expDaily" regexp="y" match="^You receive (?<amount>[0-9]+) bonus experience points? from your daily blessing\.$" enabled="y" sequence="100" script="AddExp"></trigger>

	<!-- gold triggers -->
	<trigger name="goldMob" regexp="y" match="^You get (?<amount>[0-9,]+) gold coins? from .* of .*\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldCrumble" regexp="y" match="^.* crumbles into (?<amount>[0-9,]+) gold pieces\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldShared" regexp="y" match="^.* shares [0-9,]+ gold( coins?)? with .*\. Your share is (?<amount>[0-9,]+) gold( coins?)?\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldSharing" regexp="y" match="^You share (?<total>[0-9,]+) gold( coins?)? with .*\. Your share is (?<amount>[0-9,]+) gold( coins?)?\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldSac" regexp="y" match="^.* gives you (?<amount>[0-9,]+) gold coins? for .*\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldSell" regexp="y" match="^You sell .* for (?<amount>[0-9,]+) gold\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldFence" regexp="y" match="^You fenced .* items? for (?<amount>[0-9,]+)\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldHaggle" regexp="y" match="^You haggle with .* for an extra (?<amount>[0-9,]+) gold\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldCP" regexp="y" match="^\s*Reward of (?<amount>[0-9,]+) gold coins? added\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldGQ" regexp="y" match="^Reward of (?<amount>[0-9,]+) gold coins? added\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldDB" regexp="y" match="^.* blesses you with (?<amount>[0-9,]+) additional gold\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldDailyKill" regexp="y" match="^Your daily blessing added (?<amount>[0-9,]+) gold to the corpse\.$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldQuest" regexp="y" match="^.*tells you \'As a reward, I am giving you [0-9]+ quest points? and (?<amount>[0-9]+) gold\.\'$" enabled="y" sequence="100" script="AddGold"></trigger>
	<trigger name="goldTax" regexp="y" match="^You are taxed (?<amount>[0-9,]+) gold( coins?)? by your clan\.$" enabled="y" sequence="100" script="AddGold"></trigger>

	<!-- PUP Tracker via Info Messages -->
	<trigger group="ldtPups" name="pupInfoBlankLine" regexp = "y" match="^$" omit_from_output="y" sequence="100" enabled="n" send_to="12"><send>SetTriggerOption("pupInfoBlankLine", "enabled", "n")</send>	</trigger>
	<trigger group="ldtPups" name="pupInfoUnclanned" regexp="y" match="^INFO: The mighty hero (?<name>.*) has increased in power\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoTwinlobe" regexp="y" match="^INFO: Energy flows through (?<name>.*) as (s?he|it) gains understanding\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoWatchmen" regexp="y" match="^INFO: Stendarr smiles as his holy champion\, (?<name>.*)\, triumphs over evil\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoChaos" regexp="y" match="^INFO: The very Fabric of Magic shudders as (?<name>.*)\'s power increases\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoSeekers" regexp="y" match="^INFO: The genius (?<name>.*) has found another way to avoid remorting\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoShadokil" regexp="y" match="^INFO: (?<name>.*) is at work close by, better watch your back\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoEmerald" regexp="y" match="^INFO: (?<name>.*) kneels in worship to Athena in celebration of another glorious victory\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoLight" regexp="y" match="^INFO: A magnificent light shines before (?<name>.*) leading them toward the virtue of Radience\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoDragon" regexp="y" match="^INFO: A sword is drawn as Draconian fury pulses through (?<name>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoBaal" regexp="y" match="^INFO: The True Source floods (?<name>.*) with Power\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoHook" regexp="y" match="^INFO: People burn and villages flee in terror as (?<name>.*) conquers more of the world\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoBard" regexp="y" match="^INFO: Orchestral music swells as (?<name>.*) completes another rousing verse in the epic Song of Aardwolf\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoCrusader" regexp="y" match="^INFO: There is rejoicing in the Temple as Crusader Hero (?<name>.*) increases in power\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoXunti" regexp="y" match="^INFO: Blood gushes from the latest sacrifice as (?<name>.*) gains the approval of Xiuhtecuhtli\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoImperium" regexp="y" match="^INFO: Bloodied but victorious\, (?<name>.*) rises and screams &quot;Veni Vidi Vici\!&quot;$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoCrimson" regexp="y" match="^INFO: (?<name>.*)\'s hammer shatters the earth, sending lightning across the land\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoRetribution" regexp="y" match="^INFO: Blood drips from (?<name>.*)\'s weapon as they turn their gaze towards you\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoDruid" regexp="y" match="^INFO: Another tale about (?<name>.*) is written in the Book of Mabinogian\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoAmazon" regexp="y" match="^INFO: Reflecting from constant battle\, (?<name>.*)\'s strength radiates within\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoPyre" regexp="y" match="^INFO: (?<name>.*) culls more souls and watches them ignite as Sorrow stokes the inferno\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoTanelorn" regexp="y" match="^INFO: (?<name>.*) has achieved fuller understanding of the three pillars\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoDominion" regexp="y" match="^INFO: Rasputin inscribes (?<name>.*)\'s name in the Word\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoMasaki" regexp="y" match="^INFO: Not a sound is heard as (?<name>.*) crosses the nightingale floor and steals your last breath\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoRhabdo" regexp="y" match="^INFO: (?<name>.*) amasses new power and leads the Dark Templars in new rituals to Dak\'kon\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoPerdition" regexp="y" match="^INFO: (?<name>.*) just beat Aardwolf\.\.\.again\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoCabal" regexp="y" match="^INFO: The planes quake as (?<name>.*) increases in power\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoLoqui" regexp="y" match="^INFO: You hear slight whispers as (?<name>.*) helps The Revolution grow\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoGaardian" regexp="y" match="^INFO: Mild mannered reporter (?<name>.*) leaps into a nearby phone booth\, mistaking it for a dressing room\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoTao" regexp="y" match="^INFO: (?<name>.*) takes a step closer to Nirvana as (his|her|its) power increases\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoTouchstone" regexp="y" match="^INFO: Stones fall from the high mountains as (?<name>.*) increases in strength\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>
	<trigger group="ldtPups" name="pupInfoBoot" regexp="y" match="^INFO: (?<name>.*) becomes stronger as s?he practices (his|her|its) skills for battle\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoPup"></trigger>

	<!-- Level Tracker via Info Messages -->
	<!-- OLD BAAL LVL: <trigger group="ldtLevels" name="lvlInfoBaal" regexp="y" match="^INFO: (?<name>.*) has gained favor in the eyes of the Dark One\, and gains level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger> -->
	<trigger group="ldtLevels" name="lvlInfoUnclanned" regexp="y" match="^INFO: (?<name>.*) raises a level. Now up to level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoTwinlobe" regexp="y" match="^INFO: (?<name>.*) adds another (?<lvl>.*) pages to (his|her|its) research\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoWatchmen" regexp="y" match="^INFO: Stendarr\'s angel sings praises to (?<name>.*) for attaining level (?<lvl>.*)\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoXunti" regexp="y" match="^INFO: Screams echo through the mist as (?<name>.*) sacrifices (?<lvl>.*) captives to Xiuhtecuhtli\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoLight" regexp="y" match="^INFO: The minions of darkness squeal in terror as (?<name>.*) reaches level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoDragon" regexp="y" match="^INFO: Dragons belch fire and Vorel exults as (?<name>.*) slays (?<lvl>.*) villains\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoBaal" regexp="y" match="^INFO: (?<name>.*) spirals towards insanity as (she|he|it) draws (?<lvl>.*) percent more from the True Power\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoBard" regexp="y" match="^INFO: (?<name>.*) frantically fumbles for a pen to write down a new haiku for gaining level (?<lvl>.*)\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoSeekers" regexp="y" match="^INFO: (?<name>.*) has gained both knowledge and understanding\, advancing in power to level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoShadokil" regexp="y" match="^INFO: Check your PK ranges\, (?<name>.*)\'s body count just hit (?<lvl>.*)\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoChaos" regexp="y" match="^INFO: The Three Moons blaze in glory as (?<name>.*) reaches level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoCrusader" regexp="y" match="^INFO: Weapons gleam and trumpets sound from the Crusader\'s grand temple as (?<name>.*) leads (?<lvl>.*) Holy Knights on a quest for another holy artifact\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoEmerald" regexp="y" match="^INFO: Raising their sword in honor to Athena\, (?<name>.*) attains level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoHook" regexp="y" match="^INFO: The pirates plunder nearby villages to celebrate (?<name>.*) reaching level (?<lvl>.*)\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoImperium" regexp="y" match="^INFO: (?<name>.*) has achieved level (?<lvl>.*) of military training\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoCrimson" regexp="y" match="^INFO: Thor\'s hammer shatters the earth\, sending lightning across the land as (?<name>.*) gains level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoRetribution" regexp="y" match="^INFO: Clans start to panic as raider (?<name>.*) obtains level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoDruid" regexp="y" match="^INFO: A sip of Kyrridwen\'s brew imparts guarded knowledge as (?<name>.*) gains level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoAmazon" regexp="y" match="^INFO: Battle may have taken its toll but through constant training (?<name>.*) has obtained level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoPyre" regexp="y" match="^INFO: A bell tolls in the darkness as (?<name>.*) leads (?<lvl>.*) souls to eternal misery\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoMasaki" regexp="y" match="^INFO: (?<name>.*) is surrounded by the souls of (?<lvl>.*) legendary samurai and ninjas who bestow their approval\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoRhabdo" regexp="y" match="^INFO: The voice of Dak\'kon leads (?<name>.*) to level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoTanelorn" regexp="y" match="^INFO: (?<name>.*) has attained a deeper understanding of the three pillars\, ascending to level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoDominion" regexp="y" match="^INFO: Constant conditioning has prepared (?<name>.*) for level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoPerdition" regexp="y" match="^INFO: (?<name>.*) scours the land in search of enlightenment\, purging another (?<lvl>.*) souls by the cold steel of Apollyon's blade\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoCabal" regexp="y" match="^INFO: Xarmaroch is pleased as (?<name>.*) prepares (?<lvl>.*) more followers for the Rebirth\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoLoqui" regexp="y" match="^INFO: Working in the shadows\, (?<name>.*) gathers (?<lvl>.*) followers of The Revolution\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoGaardian" regexp="y" match="^INFO: (?<name>.*) successfully fends off another libel lawsuit\! \(Full story on page (?<lvl>.*)\!\)$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoTouchstone" regexp="y" match="^INFO: The black stone guides (?<name>.*) into gaining level (?<lvl>.*)\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoTao" regexp="y" match="^INFO: The wind of duality strengthens\, as (?<name>.*) aligns (him|her|it)self (?<lvl>.*) steps closer with Tao\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoBoot" regexp="y" match="^INFO: Another battalion falls before (?<name>.*) as (he|she|it) raises to level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>
	<trigger group="ldtLevels" name="lvlInfoOutcast" regexp="y" match="^INFO: Nobody cares as the outcast (?<name>.*) reaches level (?<lvl>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoLevel"></trigger>

	<!-- Death Tracker via Info Messages -->
	<trigger group="ldtDeaths" name="deathInfoUnclanned" regexp="y" match="^INFO: (The valkyries come for |You hear a loud scream as )?(?<name>.*) (has been (removed from this realm|killed) by|who was slain by( a direct hit from)?|is brutally killed by) (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoBoot" regexp="y" match="^INFO: The last post plays mournfully as (?<name>.*) falls in battle to (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoTanelorn" regexp="y" match="^INFO: Bowed heads mark the passing of (?<name>.*)\, murdered by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoCrimson" regexp="y" match="^INFO: (?<name>.*)\'s blood is spilled by (?<enemy>.*) and the earth runs crimson\. $" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoLoqui" regexp="y" match="^INFO: Silence falls as (?<name>.*) is slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoEmerald" regexp="y" match="^INFO: Knights race from the stronghold to avenge the death of (?<name>.*) to (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoMasaki" regexp="y" match="^INFO: Without a glimpse of hesitation\, (?<name>.*) performs the seppuku\, assisted by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoLight" regexp="y" match="^INFO: Radience embraces (?<name>.*) who died valiantly in combat against (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoCrusader" regexp="y" match="^INFO: The heavens part as (?<name>.*) is sent by (?<enemy>.*) to the Nameless One\'s embrace\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoPyre" regexp="y" match="^INFO: Tormented spirits wail in requiem as dark flames ravage the soul of (?<name>.*)\, slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoTouchstone" regexp="y" match="^INFO: A mountain fades as (?<name>.*) dies to (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoHook" regexp="y" match="^INFO: The pirates prepare a burial at sea for (?<name>.*)\, slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoAmazon" regexp="y" match="^INFO: The Tribes prepare a ritual for (?<name>.*)\. Hunters are sent after (?<enemy>.*) for revenge\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoSeekers" regexp="y" match="^INFO: (?<name>.*)\'s knowledge couldn\'t save them from (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoRetribution" regexp="y" match="^INFO: (?<name>.*) is sent with a blood curdling scream by (?<enemy>.*) to meet Taboo\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoBard" regexp="y" match="^INFO: (?<name>.*) and (?<enemy>.*) have an Oscar\-winning final scene\!$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoBaal" regexp="y" match="^INFO: (?<name>.*)\, cursing (?<enemy>.*)\, embraces death and returns to the Dark One\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoShadokil" regexp="y" match="^INFO: The day brightens as darkness recalls (?<name>.*) from (?<enemy>.*)\'s wrath\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoCabal" regexp="y" match="^INFO: The fragile order of the multiverse is torn asunder as (?<name>.*) is slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoRhabdo" regexp="y" match="^INFO: A scream of vengeance is heard as Dak\'kon revives (?<name>.*) to claim their revenge on (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoChaos" regexp="y" match="^INFO: The Three Moons mourn the passing of (?<name>.*) at the hands of (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoDominion" regexp="y" match="^INFO: (?<name>.*) has been defeated in mortal combat by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoDruid" regexp="y" match="^INFO: The Cwn Annwn emerge in a frenzy with (?<name>.*) in their midst\, savagely hunting down (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoGaardian" regexp="y" match="^INFO: (?<name>.*)\'s journalistic integrity crumbles in the affair known as (?<enemy>.*)gate\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoXunti" regexp="y" match="^INFO: (?<name>.*) is cut down in the midst of bloody warfare by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoImperium" regexp="y" match="^INFO: You hear a faint rendition of &quot;Taps&quot; as (?<name>.*) is slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoTao" regexp="y" match="^INFO: (?<name>.*)\'s Chi has been unbalanced by (?<enemy>.*)\, and (he|she|it) begins (his|her|their|its) journey anew\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoDragon" regexp="y" match="^INFO: (?<name>.*) is slain by (?<enemy>.*) and is borne on swift wings to seek Vorel\'s embrace\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoWatchmen" regexp="y" match="^INFO: Stendarr cries tears of Anguish as (?<name>.*) is slain by (?<enemy>.*)\!$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoTwinlobe" regexp="y" match="^INFO: (?<name>.*) has attained a better understanding of death\, thanks to (?<enemy>.*)\!$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoPerdition" regexp="y" match="^INFO: Valiant to the end\, (?<name>.*) has fallen to (?<enemy>.*) in battle\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="deathInfoOutcast" regexp="y" match="^INFO: Nobody mourns the death of outcast (?<name>.*)\, slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>

	<!-- Death Tracker [Suicides] via Info Messages -->
	<trigger group="ldtDeaths" name="suicideInfoBoot" regexp="y" match="^INFO: (?<name>.*) yells \'Death before Dishonor\' and then chooses death\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoDragon" regexp="y" match="^INFO: (?<name>.*) sneaks a peek at Vorel\'s cleavage and pays the ultimate price\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoTwinlobe" regexp="y" match="^INFO: (?<name>.*) attempts to divide by zero\, with catastrophic results\!$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoEmerald" regexp="y" match="^INFO: A tear falls from Athena\'s eye as (?<name>.*) throws (him|her|it)self from the parapets\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoWatchmen" regexp="y" match="^INFO: Without a moments hesitation\, (?<name>.*) makes the ultimate sacrifice in the name of Stendarr\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoLoqui" regexp="y" match="^INFO: Though (?<name>.*) falls in battle\, The Revolution carries on\.$" enabled="y" sequence="100" omit_from_output="n" script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoHook" regexp="y" match="^INFO: You did not know it was possible to keelhaul yourself.  (?<name>.*) demonstrates\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoRhabdo" regexp="y" match="^INFO: (?<name>.*) has fallen to the dire\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoXunti" regexp="y" match="^INFO: With no virgins left\, Xiuhtecuhtli accepts the ultimate sacrifice of (?<name>.*)\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoDominion" regexp="y" match="^INFO: Contemplating the meaning of the universe too deeply\, (?<name>.*) ceases to exist\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoDruid" regexp="y" match="^INFO: A raven\'s caw echoes in the grove as (?<name>.*) walks into the veil to the Otherworld\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoBaal" regexp="y" match="^INFO: (?<name>.*) bursts into flames as (he|she|it) draws too deeply on the True Source\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoCrimson" regexp="y" match="^INFO: (?<name>.*) slips while dancing on the oars and plummets to (his|her|its) death\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoAmazon" regexp="y" match="^INFO: (?<name>.*) slits their throat to escape only to be reborn a little stronger\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoPyre" regexp="y" match="^INFO: The everlasting flames burn brighter as (?<name>.*)\'s soul fades into eternal darkness\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>
	<trigger group="ldtDeaths" name="suicideInfoPerdition" regexp="y" match="^INFO: Apollyon's intervention saves (?<name>.*) from unending death\.$" enabled="y" sequence="100" omit_from_output="n"  script="AddInfoDeath"></trigger>

<!-- Move them above this line once found/added.
Suicides:
Some clans have duplicate suicide/death messages, these clans are:
	<trigger name="suicideInfoRetribution" regexp="y" match="^INFO: (?<name>.*) is sent with a blood curdling scream by (?<enemy>.*) to meet Taboo\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoCabal" regexp="y" match="^INFO: The fragile order of the multiverse is torn asunder as (?<name>.*) is slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoLight" regexp="y" match="^INFO: Radience embraces (?<name>.*) who died valiantly in combat against (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoChaos" regexp="y" match="^INFO: The Three Moons mourn the passing of (?<name>.*) at the hands of (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoMasaki" regexp="y" match="^INFO: Without a glimpse of hesitation\, (?<name>.*) performs the seppuku\, assisted by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoImperium" regexp="y" match="^INFO: You hear a faint rendition of &quot;Taps&quot; as (?<name>.*) is slain by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>

Unclanned/NoPK cannot suicide, but leaving NoPK here just in case they go PK
	<trigger name="suicideInfoTanelorn" regexp="y" match="^INFO: Bowed heads mark the passing of (?<name>.*)\, murdered by (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoCrusader" regexp="y" match="^INFO: The heavens part as (?<name>.*) is sent by (?<enemy>.*) to the Nameless One\'s embrace\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoTouchstone" regexp="y" match="^INFO: A mountain fades as (?<name>.*) dies to (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoSeekers" regexp="y" match="^INFO: (?<name>.*)\'s knowledge couldn\'t save them from (?<enemy>.*)\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoBard" regexp="y" match="^INFO: (?<name>.*) and (?<enemy>.*) have an Oscar\-winning final scene\!$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoShadokil" regexp="y" match="^INFO: The day brightens as darkness recalls (?<name>.*) from (?<enemy>.*)\'s wrath\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoGaardian" regexp="y" match="^INFO: (?<name>.*)\'s journalistic integrity crumbles in the affair known as (?<enemy>.*)gate\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
	<trigger name="suicideInfoTao" regexp="y" match="^INFO: (?<name>.*)\'s Chi has been unbalanced by (?<enemy>.*)\, and (he|she|it) begins (his|her|their|its) journey anew\.$" enabled="y" sequence="100" omit_from_output="y"  script="AddInfoDeath"></trigger>
-->
	<!-- Simple gag trigger -->
	<trigger regexp="y" match="^INFO: Congratulations to (?<name>.*) on becoming a noble of Aardwolf\.$" enabled="y" sequence="100" omit_from_output="y"></trigger>

   <trigger group="icefall" script="DamageReceived" sequence="200" enabled="y" regexp="y" match="^.* bites (?<player>you) one last time! \[(?<damage>[0-9]+)\]$"></trigger> 
   <trigger group="icefall" script="DamageReceived" sequence="200" enabled="y" regexp="y" match="^Dry Ice burns (?<player>you) after a hug! \[(?<damage>[0-9]+)\]$"></trigger> 
   <trigger group="icefall" script="DamageReceived" sequence="200" enabled="y" regexp="y" match="^Sergeant Stealth kicks (?<player>you) with his boot! \[(?<damage>[0-9]+)\]$"></trigger> 
   <trigger group="icefall" script="DamageReceived" sequence="200" enabled="y" regexp="y" match="^Hazy Reflections reflects her damage, injuring (?<player>you)! \[(?<damage>[0-9]+)\]$"></trigger> 
   <trigger group="icefall" script="DamageReceived" sequence="200" enabled="y" regexp="y" match="^A minion of Shade pops a balloon, injuring (?<player>you)! \[(?<damage>[0-9]+)\]$"></trigger> 
   <trigger group="icefall" script="DamageReceived" sequence="200" enabled="y" regexp="y" match="^Doctor Dusk smacks (?<player>you) before dying! \[(?<damage>[0-9]+)\]$"></trigger>        
</triggers>

<script>
<![CDATA[
	require "serialize"
	require "commas"
	require "gmcphelper"

	-- Damage Class
	local Attack = {}
	Attack.__index = Attack

	Attack.meleeDamageMap = {
		["acidic bite"] = "acid",
		["digestion"] = "acid",
		["slime"] = "acid",

		["air"] = "air",

		["beating"] = "bash",
		["blast"] = "bash",
		["charge"] = "bash",
		["crush"] = "bash",
		["hit"] = "bash",
		["pound"] = "bash",
		["punch"] = "bash",
		["slap"] = "bash",
		["smash"] = "bash",
		["suction"] = "bash",
		["thwack"] = "bash",

		["chill"] = "cold",
		["freezing bite"] = "cold",

		["earth"] = "earth",

		["shock"] = "electric",
		["shocking bite"] = "electric",

		["friction"] = "energy",
		["wrath"] = "energy",
		["Wrath"] = "energy",

		["flame"] = "fire",
		["flaming bite"] = "fire",

		["divine power"] = "holy",

		["light"] = "light",

		["magic"] = "magic",

		["mental energy"] = "mental",
		["mind force"] = "mental",

		["decaying touch"] = "negative",
		["life drain"] = "negative",

		["bite"] = "pierce",
		["chomp"] = "pierce",
		["peck"] = "pierce",
		["pierce"] = "pierce",
		["scratch"] = "pierce",
		["stab"] = "pierce",
		["sting"] = "pierce",
		["thrust"] = "pierce",

		["chop"] = "slash",
		["claw"] = "slash",		
		["cleave"] = "slash",
		["grep"] = "slash",
		["slash"] = "slash",
		["slice"] = "slash",
		["whip"] = "slash",

		["shadow"] = "shadow",

		["wail"] = "sonic",

		["water blast"] = "water",
	}

	Attack.spellDamageMap = {
		["stream of acid"] = "acid",
		["wave of acid"] = "acid",
		["searing blast of acid"] = "acid",		
		["nerve shock"] = "acid",
		["hand of acid"] = "acid",
		["miasma of pain"] = "acid",		

		["deadly wind"] = "air",
		["cyclone"] = "air",
		["blast of air"] = "air",
		["air dart"] = "air",
		["whirlwind"] = "air",
		["tornado"] = "air",
		["scouring air"] = "air",
		["tempest"] = "air",

		["bash"] = "bash",
		["bodycheck"] = "bash",
		["uppercut"] = "bash",
		["kicked dirt"] = "bash",
		["hammering blow"] = "bash",
		["sap"] = "bash",
		["kick"] = "bash",
		["stunning blow"] = "bash",
		["spasm"] = "bash",
		["ballistic attack"] = "bash",
		["bone-crunching force"] = "bash",
		["stomp"] = "bash",

		["freezing sleet"] = "cold",
		["cloud of ice"] = "cold",
		["shard of ice"] = "cold",
		["bolt of ice"] = "cold",
		["freezing air"] = "cold",
		["chilling touch"] = "cold",
		["purgatory"] = "cold",
		["mind numbing chill"] = "cold",

		["stench"] = "disease",
		["spray"] = "disease",
		["green death"] = "disease",
		["blight"] = "disease",
		["decaying touch"] = "disease",
		["insect swarm"] = "disease",
		["scourge"] = "disease",

		["ground strike"] = "earth",
		["earthen spike"] = "earth",
		["earth shroud"] = "earth",
		["eruption"] = "earth",
		["crushing earth"] = "earth",
		["earthquake"] = "earth",

		["spear of odin"] = "electric",
		["lightning strike"] = "electric",
		["shock aura"] = "electric",
		["arc lightning"] = "electric",
		["shocking grasp"] = "electric",
		["lightning bolt"] = "electric",
		["God\'s Wrath"] = "electric",

		["detonation"] = "energy",
		["psionic blast"] = "energy",
		["blast of energy"] = "energy",
		["wave of energy"] = "energy",		
		["spirit strike"] = "energy",
		["spiritual force"] = "energy",
		["explosive energy"] = "energy",
		["rune"] = "energy",

		["forestfire"] = "fire",
		["flaming arrow"] = "fire",
		["flamestrike"] = "fire",
		["Fire Blast"] = "fire",
		["fire storm"] = "fire",
		["searing ball of flame"] = "fire",
		["shroud of flame"] = "fire",
		["sphere of flame"] = "fire",
		["tongue of flame"] = "fire",
		["blazing fire"] = "fire",
		["pillar of fire"] = "fire",
		["burning hands"] = "fire",
		["scorching heat"] = "fire",
		["soulburn"] = "fire",
		["white flame"] = "fire",
		["aura of flame"] = "fire",
		["fiery rain"] = "fire",
		["scorching heat"] = "fire",
		["fire breath"] = "fire",

		["exorcism"] = "holy",
		["shimmering arrow"] = "holy",
		["blast of holy fury"] = "holy",
		["holy strike"] = "holy",
		["purging"] = "holy",
		["flaming bolts of godly might"] = "holy",		

		["colour spray"] = "light",
		["Colourful Spray"] = "light",
		["beam of colorful light"] = "light",
		["blast of light"] = "light",
		["pulse of light"] = "light",
		["ray of moonlight"] = "light",
		["brilliant arrow of light"] = "light",
		["vengeance"] = "light",
		["blazing fury"] = "light",
		["starburst"] = "light",
		["heavenly balance"] = "light",

		["magical backstab"] = "magic",
		["magic"] = "magic",
		["harm spell"] = "magic",
		["magic missile"] = "magic",
		["crushing force bolt"] = "magic",
		["misty breath"] = "magic",
		["cleansing"] = "magic",

		["anguish"] = "mental",
		["neural overload"] = "mental",		
		["finger of death"] = "mental",
		["mind thrust"] = "mental",
		["ego whip"] = "mental",
		["mindpower"] = "mental",
		["neural burn"] = "mental",
		["projected force"] = "mental",
		["psychic drain"] = "mental",
		["soul-tearing energy"] = "mental",
		["blast of fury"] = "mental",
		["traumatic sending"] = "mental",
		["abomination"] = "mental",
		["ultrablast"] = "mental",

		["flesh rip"] = "negative",
		["tormenting"] = "negative",
		["torment"] = "negative",
		["agitation"] = "negative",
		["psychic crush"] = "negative",
		["soften"] = "negative",
		["life-draining touch"] = "negative",
		["strength-draining touch"] = "negative",
		["field of death"] = "negative",
		["nightmare touch"] = "negative",
		["damning force"] = "negative",

		["gouge"] = "pierce",
		["razor-sharp talon"] = "pierce",

		["marbu poison"] = "poison",
		["cobra bane"] = "poison",
		["burnt marbu"] = "poison",
		["poison"] = "poison",
		["Poison"] = "poison",
		["venom"] = "poison",
		["toxic cloud"] = "poison",

		["apocalyptic force"] = "shadow",
		["condemning force"] = "shadow",

		["mighty assault"] = "slash",
		["scalp"] = "slash",
		["spinning blade"] = "slash",

		["piercing sound"] = "sonic",
		["unholy scream"] = "sonic",
		["sonic blast"] = "sonic",

		["hydroblast"] = "water",
		["rain of justice"] = "water",
		["caustic rain"] = "water",
		["stream"] = "water"
	}

	Attack.damageTypeMap = {
		bash = "physical",
		pierce = "physical",
		slash = "physical",
		air = "magic",
		acid = "magic",
		cold = "magic",
		disease = "magic",
		earth = "magic",
		electric = "magic",
		energy = "magic",
		fire = "magic",
		holy = "magic",
		light = "magic",
		magic = "magic",
		mental = "magic",
		negative = "magic",
		poison = "magic",
		shadow = "magic",
		sonic = "magic",
		water = "magic",
		mprog = "mprog"
	}

	function Attack:New(name, colour)
		local atk = {}
		setmetatable(atk, Attack)
		
		atk.name = name
		atk.colour = colour
		atk.damage = 0
		atk.min = 0
		atk.max = 0
		atk.hits = 0
		atk.crits = 0		

		return atk
	end

	-- Player class
	local Player = {}
	Player.__index = Player
	function Player:New(name, colour)
		local player = {}
		setmetatable(player, Player)
		
		player.name = name		
		player.colour = colour	
		player.last = os.clock()			
		player.time = 0

		player.damageDealt = 0
		player.damageDealtPerSecond = 0
		player.damageDealtHits = 0 --Total # of hits dealt
		player.meleeHitsDealt = 0
		player.spellHitsDealt = 0
		player.critHitsDealt = 0
		player.physicalHitsReceived = 0
		player.magicHitsReceived = 0
		player.mprogHitsReceived = 0
		player.unknownHitsDealt = 0
		player.attacksDealt = {}		

		player.damageReceived = 0
		player.damageReceivedPerSecond = 0
		player.damageReceivedHits = 0 --Total # of hits received
		player.meleeHitsReceived = 0
		player.dodgeableHitsReceived = 0
		player.spellHitsReceived = 0
		player.critHitsReceived = 0
		player.unknownHitsReceived = 0
		player.mprogHitsReceived = 0
		player.attacksReceived = {}
		player.dodges = {
			Total = {
				count = 0,
				colour = colour
			}
		}

		player.enemydodges = {
			Total = {
				count = 0,
				colour = colour
			}
		}	

		player.damageAggregates = {
			melee = 0,
			spell = 0,

			physical = 0,
			magic = 0,

			mprog = 0,

			damtypes = {
				bash = 0,
				pierce = 0,
				slash = 0,
				acid = 0,
				air = 0,
				cold = 0,
				disease = 0,
				earth = 0,
				electric = 0,
				energy = 0,
				fire = 0,
				holy = 0,
				light = 0,
				magic = 0,
				mental = 0,
				negative = 0,
				poison = 0,
				shadow = 0,
				sonic = 0,
				water = 0,
				mprog = 0
			},

			unknown = 0
		}

		return player
	end

	function Player:AttackDealt(attack, damage, hits, crit)
		if self.attacksDealt[attack] == nil then self.attacksDealt[attack] = Attack:New(attack, randomColour()) end

		local now = os.clock()
		local timeSinceLast = now - self.last
		self.last = now

		if timeSinceLast < 10 then
			self.time = self.time + timeSinceLast
			
			self.damageDealt = self.damageDealt + damage
			self.damageDealtPerSecond = self.damageDealt / self.time
			self.damageDealtHits = self.damageDealtHits + hits
			self.critHitsDealt = self.critHitsDealt + crit
	
			self.attacksDealt[attack].damage = self.attacksDealt[attack].damage + damage
			self.attacksDealt[attack].hits = self.attacksDealt[attack].hits + hits
			self.attacksDealt[attack].crits = self.attacksDealt[attack].crits + crit

			if self.attacksDealt[attack].min > damage or self.attacksDealt[attack].min == 0 then
				self.attacksDealt[attack].min = damage
			end

			if self.attacksDealt[attack].max < damage then
				self.attacksDealt[attack].max = damage
			end


			local damageType = Attack.meleeDamageMap[attack]
			if damageType ~= nil then
				-- melee				
				self.meleeHitsDealt = self.meleeHitsDealt + hits		
			else			
				-- spell
				damageType = Attack.spellDamageMap[attack]
				if damageType ~= nil then					
					self.spellHitsDealt = self.spellHitsDealt + hits
				else
					self.unknownHitsDealt = self.unknownHitsDealt + hits
				end
			end
		end
	end

	function Player:AttackReceived(attack, damage, hits, crit)			
		if self.attacksReceived[attack] == nil then self.attacksReceived[attack] = Attack:New(attack, randomColour()) end		

		self.damageReceived = self.damageReceived + damage
		self.damageReceivedPerSecond = self.damageReceived / self.time
		self.damageReceivedHits = self.damageReceivedHits + hits
		self.critHitsReceived = self.critHitsReceived + crit

		self.attacksReceived[attack].damage = self.attacksReceived[attack].damage + damage
		self.attacksReceived[attack].hits = self.attacksReceived[attack].hits + hits	
		self.attacksReceived[attack].crits = self.attacksReceived[attack].crits + crit	
		if self.attacksReceived[attack].min > damage or self.attacksReceived[attack].min == 0 then
			self.attacksReceived[attack].min = damage
		end
		if self.attacksReceived[attack].max < damage then
			self.attacksReceived[attack].max = damage
		end

		-- spell vs melee
		local damageType = Attack.meleeDamageMap[attack]
		if damageType ~= nil then
			-- melee
			self.damageAggregates.melee = self.damageAggregates.melee + damage	
			self.meleeHitsReceived = self.meleeHitsReceived + hits		
			self.dodgeableHitsReceived = self.dodgeableHitsReceived + hits
		else			
			-- spell
			damageType = Attack.spellDamageMap[attack]
			if damageType ~= nil then
				self.damageAggregates.spell = self.damageAggregates.spell + damage
				self.spellHitsReceived = self.spellHitsReceived + hits			
			end
		end

		-- magic vs physical and damtype
		if damageType ~= nil then
			-- damtype
			self.damageAggregates.damtypes[damageType] = self.damageAggregates.damtypes[damageType] + damage

			-- magic vs physical
			self.damageAggregates[Attack.damageTypeMap[damageType]] = self.damageAggregates[Attack.damageTypeMap[damageType]] + damage
			if Attack.damageTypeMap[damageType] == "physical" then
				self.physicalHitsReceived = self.physicalHitsReceived + 1
			elseif Attack.damageTypeMap[damageType] == "magic" then
				self.magicHitsReceived = self.magicHitsReceived + 1
			end
		elseif attack == "mprog" then
			self.mprogHitsReceived = self.mprogHitsReceived + hits
			self.damageAggregates.mprog = self.damageAggregates.mprog + damage
			self.damageAggregates.damtypes.mprog = self.damageAggregates.damtypes.mprog + damage
			self.mprogHitsReceived = self.mprogHitsReceived + hits
		else			
			-- unknown
			self.unknownHitsReceived = self.unknownHitsReceived + hits
			self.damageAggregates.unknown = self.damageAggregates.unknown + damage
		end		
	end

	function Player:Dodge(dodgeType)
		if self.dodges[dodgeType] == nil then
			self.dodges[dodgeType] = {}
			self.dodges[dodgeType].count = 1
			self.dodges[dodgeType].colour = randomColour()						
		else
			self.dodges[dodgeType].count = self.dodges[dodgeType].count + 1			
		end

		self.dodges.Total.count = self.dodges.Total.count + 1
		self.damageReceivedHits = self.damageReceivedHits + 1
		self.meleeHitsReceived = self.meleeHitsReceived + 1
		self.dodgeableHitsReceived = self.dodgeableHitsReceived + 1
	end

	function Player:EnemyDodge(dodgeType)
		if self.enemydodges[dodgeType] == nil then
			self.enemydodges[dodgeType] = {}
			self.enemydodges[dodgeType].count = 1
			self.enemydodges[dodgeType].colour = randomColour()						
		else
			self.enemydodges[dodgeType].count = self.enemydodges[dodgeType].count + 1			
		end
		
		self.enemydodges.Total.count = self.enemydodges.Total.count + 1
		self.damageDealtHits = self.damageDealtHits + 1
		self.meleeHitsDealt = self.meleeHitsDealt + 1
	end	
	
	local players = {}	
	local manualGroup = {}
	local me = ""

	local clrSep = "@D"
	local clrLbl = "@r"
	local clrVal = "@W"

	-- gonna get these two into window settings at some point
	local lineSpacing = 4
	local titleSeparatorWidth = 1

	local gag = (GetVariable("gag") or "y")
	local gagme = (GetVariable("gagme") or "n")
	local gagdodges = (GetVariable("gagdodges") or "n")
	local gagpups = (GetVariable("gagpups") or "y")
	local gaglevels = (GetVariable("gaglevels") or "y")
	local gagdeaths = (GetVariable("gagdeaths") or "y")
	local sortMode = (tonumber(GetVariable("sortMode") or "0") or 0)
	local filterAmount = (GetVariable("filterAmount") or "0")
	local pupFilterAmount = (GetVariable("pupFilterAmount") or "0")
	local pupThreshold = (GetVariable("pupThreshold") or "0")
	local throttle = (GetVariable("throttle") or "n")
	local pluginIsEnabled = false
	local scrollPosMain = 1
	local scrollPosDetail = 1
	local scrollCap = 100

	local roundDelimiter = (GetVariable("roundDelimiter") or "")
	local reportRooms = (GetVariable("reportRooms") or "n")
	local reportRounds = (GetVariable("reportRounds") or "n")
	local inCombat = false
	local roomStart = os.clock()
	local firstRoundOfCombat = false
	local lastRoundReport = os.clock()	
	local newRound = true
	local roundDamageDealt = 0
	local roundDamageReceived = 0
	local roundHealed = 0
	local roomStartHP = 0
	local roomDamageDealt = 0
	local roomDamageReceived = 0
	local roomHealed = 0
	local roomReports = {}
	local currentArea = "None"

	local watchLevel = {}

	local expTable = {}
	expTable.areas = {}
	expTable.total = 0
	expTable.time = 0

	local goldTable = {}
	goldTable.areas = {}
	goldTable.total = 0
	goldTable.time = 0

	local clanTable = {}
	clanTable.pupInfo = {}
	clanTable.lvlInfo = {}
	clanTable.deathInfo = {}
	clanTable.totalPup = 0
	clanTable.lastPup = 0
	clanTable.timePup = 0
	clanTable.totalLvl = 0
	clanTable.lastLvl = 0
	clanTable.timeLvl = 0
	clanTable.totalDeath = 0
	clanTable.lastDeath = 0
	clanTable.timeDeath = 0

	local playerWinOrientation = (GetVariable("playerWinOrientation") or "vertical")
	local rollingWindow = tonumber(GetVariable("rollingWindow") or "60")
	local changeData = {}
	local playerHP = 0
	local lastPlayerData = {		
		damageDealt = 0,
		damageReceived = 0,
		damageReceivedHits = 0,
		totalDodges = 0,
		dodgeableHitsReceived = 0,
		damageAggregates = { damtypes = {} },	
		expTotal = 0,
		goldTotal = 0,
		damageTime = 0,
		expTime = 0,
		goldTime = 0
	}

	local rollingPlayerData = {
		damageDealt = 0,
		damageReceived = 0,
		damageReceivedHits = 0,
		totalDodges = 0,
		dodgeableHitsReceived = 0,
		damageAggregates = { damtypes = {} },	
		expTotal = 0,
		goldTotal = 0,
		damageTime = 0,
		expTime = 0,
		goldTime = 0
	}

	local sortOptions = {
		[0] = "dmg",
		[1] = "dps",
		[2] = "dmgrec",
		[3] = "dpsrec",
		[4] = "dodges",
		[5] = "exp",
		[6] = "gold",
		[7] = "pups",
		[8] = "lvls",
		[9] = "deaths",
		[10] = "goals"
	}
	local sortModeSize = 11 --The # of entries in sortOptions.

	local uptimes = {
		dmg = 0,
		dmgrec = 0,
		dodges = 0,
		exp = 0,
		gold = 0,
		pups = 0,
		lvls = 0,
		deaths = 0,
		goals = 0
	}

	local colourMap = {
		[1] = "firebrick",
		[2] = "orangered",
		[3] = "darkorange",
		[4] = "goldenrod",
		[5] = "olive",
		[6] = "darkolivegreen",
		[7] = "forestgreen",
		[8] = "green",
		[9] = "seagreen",
		[10] = "mediumspringgreen",
		[11] = "darkturquoise",
		[12] = "mediumturquoise",		
		[13] = "darkslategray",
		[14] = "darkcyan",
		[15] = "deepskyblue",
		[16] = "steelblue",
		[17] = "dodgerblue",
		[18] = "lightslategray",
		[19] = "navy",
		[20] = "darkviolet",
		[21] = "mediumvioletred"
	}

	if GetVariable("colour_map") ~= nil then
		luastmt = "obj = " .. GetVariable("colour_map")
		assert (loadstring (luastmt or "")) ()		
		colourMap = obj			
	end

	local goalData = {
		lvl = { goal = 0, current = 0, colour = 0 },
		pup = { goal = 0, current = 0, colour = 0 },
		gold = { goal = 0, current = 0, colour = 0 },
		exp = { goal = 0, current = 0, colour = 0 }
	}

	if GetVariable("goal_data") ~= nil then
		luastmt = "obj = " .. GetVariable("goal_data")
		assert (loadstring (luastmt or "")) ()		
		goalData = obj

		goalData.lvl.current = 0
		goalData.pup.current = 0
		goalData.gold.current = 0
		goalData.exp.current = 0
	end
	
	local colours = {}

	local z_order_plugin = "462b665ecb569efbf261422f"
	local dragStart = nil	
	local window = {}
	local detailWindow = {}
	local playerWindow = {}

	function Help()
		ColourNote("orange", "black", GetPluginInfo (GetPluginID (), 3))
	end

	function OnPluginInstall()
		uptimes.dmg = os.clock()
		uptimes.dmgrec = os.clock()
		uptimes.dodges = os.clock()
		uptimes.exp = os.clock()
		uptimes.gold = os.clock()
		uptimes.pups = os.clock()
		uptimes.lvls = os.clock()
		uptimes.deaths = os.clock()
		uptimes.goals = os.clock()

		math.randomseed(os.time())
		colours.dodgeTotal = randomColour()
		colours.physicalDamage = randomColour()
		colours.magicDamage = randomColour()
		colours.meleeDamage = randomColour()
		colours.spellDamage = randomColour()

		colours.damTypes = {}
		colours.damTypes.bash = randomColour()
		colours.damTypes.pierce = randomColour()
		colours.damTypes.slash = randomColour()
		colours.damTypes.acid = randomColour()
		colours.damTypes.air = randomColour()
		colours.damTypes.cold = randomColour()
		colours.damTypes.disease = randomColour()
		colours.damTypes.earth = randomColour()
		colours.damTypes.electric = randomColour()
		colours.damTypes.energy = randomColour()
		colours.damTypes.fire = randomColour()
		colours.damTypes.holy = randomColour()
		colours.damTypes.light = randomColour()
		colours.damTypes.magic = randomColour()
		colours.damTypes.mental = randomColour()
		colours.damTypes.negative = randomColour()
		colours.damTypes.poison = randomColour()
		colours.damTypes.shadow = randomColour()
		colours.damTypes.sonic = randomColour()
		colours.damTypes.water = randomColour()
		colours.damTypes.mprog = randomColour()
		goalData["exp"].colour = randomColour()
		goalData["gold"].colour = randomColour()
		goalData["pup"].colour = randomColour()
		goalData["lvl"].colour = randomColour()

		InitializePlayer("You")
		CreateRoundTrigger()		
		SetGagTriggers()
		SetGagMeTriggers()
		SetGagDodgeTriggers()
		SetGagPupsTriggers()
		SetGagLevelsTriggers()
		SetGagDeathsTriggers()
		Help()
		Send_GMCP_Packet("request char")

		--Retrieve/initialize our 2 main windows.
		if (GetVariable("window") ~= nil) then	
			-- load saved variables if they exist
			luastmt = "obj = " .. GetVariable("window")
			assert (loadstring (luastmt or "")) ()		
			window = obj
		else
			window = SetWindowDefaults("window") -- load window defaults
		end					

		if (GetVariable("detailWindow") ~= nil) then	
			-- load saved variables if they exist
			luastmt = "obj = " .. GetVariable("detailWindow")
			assert (loadstring (luastmt or "")) ()		
			detailWindow = obj
		else
			detailWindow = SetWindowDefaults("detailWindow") -- load window defaults
		end

		if (GetVariable("playerWindow") ~= nil) then	
			-- load saved variables if they exist
			luastmt = "obj = " .. GetVariable("playerWindow")
			assert (loadstring (luastmt or "")) ()		
			playerWindow = obj
		else
			playerWindow = SetWindowDefaults("playerWindow") -- load window defaults
		end		

		InitializeWindow(window)
		InitializeWindow(detailWindow)
		InitializeWindow(playerWindow)

		AddTimer("on_second", 0, 0, 1, "", timer_flag.Enabled, "OnSecond")
	end		

	function OnPluginConnect()
		pluginIsEnabled = true
	end
	
	function OnPluginBroadcast(msg, id, name, text)
		if (id == '3e7dedbe37e44942dd46d264') then
		    if (text == "group") then
				if me == "" or me == nil and pluginIsEnabled then
					Send("protocol gmcp sendchar")
				else
		        	 	LoadGroup()
				end
			elseif (text == "room.info") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info") --- We just want the room.info section.
				luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
				assert (loadstring (luastmt or "")) ()
				if (gmcpdata ~= nil) then
					currentArea = gmcpdata.zone
				end
	      		elseif (text == "char.base") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
				luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
				assert (loadstring (luastmt or "")) ()
		
				if (gmcpdata ~= nil) then
					me = gmcpdata.name				
				end			
			elseif (text == "char.status") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")				 
				luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
				assert (loadstring (luastmt or "")) ()																						

				if gmcpdata.state == "8" then
					if not inCombat then						
						RoomStart()
					end					

					inCombat = true
				else
					if inCombat then
						if reportRounds == "y" then
							ReportRound(roundDamageDealt, roundDamageReceived, roundHealed, os.clock() - roomStart)
						end
						AddRoundToRoom()
						RoomEnd()					
					end

					inCombat = false
				end
			elseif (text == "char.vitals") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.vitals")				 
				luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
				assert (loadstring (luastmt or "")) ()		

				if gmcpdata ~= nil and gmcpdata ~= "" then
					playerHP = tonumber(gmcpdata.hp)
				end
	  		end
      		end
	end

	function ToggleManual(name, line, wildcards)
		manualGroup[wildcards[1]] = not manualGroup[wildcards[1]]

		LoadGroup()

		ColourNote("orange", "", "Manual group ", "cyan", "", 
			wildcards[1], manualGroup[wildcards[1]] and "limegreen" or "red", "", " " .. tostring(manualGroup[wildcards[1]]))
	end

	function RemFromGroup(name, line, wildcards)
		local name = wildcards[1]

		manualGroup[name] = false
		DeleteDamageTrigger(name)
		players[name] = nil

		LoadGroup()

		ColourNote("orange", "", "Removed from group ", "cyan", "", name)
	end

	function LoadGroup()
		local noLongerInGroup = {}
		for name, player in pairs(players) do
			noLongerInGroup[name] = true
		end

		local addedPlayer = false
		res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","group")
		if gmcparg == "" then gmcparg = "nil" end
     	luastmt = "full_group_data = " .. (gmcparg or "nil")     	
     	assert (loadstring (luastmt or "")) ()
     	if (full_group_data ~= nil and full_group_data.groupname ~= "" and full_group_data.members ~= nil) then	         
        	for i,v in ipairs(full_group_data.members) do
        		if players[v.name] == nil and v.name ~= me then 
	    			InitializePlayer(v.name)	            			
    				CreateDamageTrigger(v.name)
    				addedPlayer = true											
        		end

        		noLongerInGroup[v.name] = false
        	end
    	end

    	for player, track in pairs(manualGroup) do
    		if track and players[player] == nil and player ~= me then
				InitializePlayer(player)	            			
				CreateDamageTrigger(player)
				addedPlayer = true
    		end
    	end

    	-- remove triggers for those no longer in the group
    	for name, notInGroup in pairs(noLongerInGroup) do
			if notInGroup and not manualGroup[name] then DeleteDamageTrigger(name) end
    	end

    	if addedPlayer then
    		if window.show then
				Draw(window)
			end

			if detailWindow.show then
				Draw(detailWindow)
			end	
    	end
	end

	function OnPluginClose()
		DeleteWindow(window)
		DeleteWindow(detailWindow)
	end

	function randomColour()
		return colourMap[math.random(#colourMap)]
	end	

	function ShowColour()
		for i, colour in ipairs(colourMap) do
			ColourNote("white", "", string.sub(tostring(i).." ", 1, 2),
				"gray", "", " | ",
				"white", colour, colour)
		end
	end

	function AddColour(name, line, wildcards)
		table.insert(colourMap, wildcards[1])

		SetVariable("colour_map", serialize.save_simple(colourMap))

		ColourNote("orange", "", "Added colour: ",
			"white", wildcards[1], wildcards[1])
	end

	function RemoveColour(name, line, wildcards)
		local removedColour = table.remove(colourMap, tonumber(wildcards[1]))
		
		SetVariable("colour_map", serialize.save_simple(colourMap))

		ColourNote("orange", "", "Removed colour: ",
			"white", removedColour, removedColour)
	end

	-- window functions
	function DrawLineBar(win, line, colour, percent, startPos, leftOrRight)
		if percent ~= percent then percent = 0 end

		local startX = 0
		local endX = 0	
		local returnVal = 0	
		local winWidth = tonumber(WindowInfo(win.id, 3))
		if leftOrRight == "right" then			
			endX = 1 + math.floor(winWidth - 2) - (startPos or 0)
			startX = math.floor(endX * (1 - percent))
			returnVal = startX
		else			
			startX = (startPos or 1)
			endX = startX + math.floor(winWidth - 2) * percent			
			returnVal = endX
		end	

		WindowRectOp(win.id, miniwin.rect_fill, 
				startX, 
				titleSeparatorWidth + line * (win.fontSize + lineSpacing), 
				endX, 
				titleSeparatorWidth + (line + 1) * (win.fontSize + lineSpacing), 
				ColourNameToRGB(colour))

		return returnVal
	end

	function DrawTextLine(win, line, text, startPos, leftOrRight)
		local startX = 0
		local endX = 0		
		local returnVal = 0	
		local winWidth = tonumber(WindowInfo(win.id, 3))
		if leftOrRight == "right" then
			endX = 1 + math.floor(winWidth - 2) - (startPos or 0)
			startX = endX - WindowTextWidth(win.id, win.font, text, true) - 1	
			returnVal = startX	
		else			
			startX = 2 + (startPos or 0)
			endX = 0
			returnVal = endX
		end	

		WindowText(win.id, win.font, text, 
			startX, 
			titleSeparatorWidth + line * (win.fontSize + lineSpacing) + (lineSpacing / 2) - (win.fontSize / 4), 
			endX, 
			0, 
			ColourNameToRGB(window.fontColor), 
			true)			
	end

	function DrawTextLineExt(win, line, text, nColour, textOffset)
		WindowText(win.id, win.font, text, 
			2 + textOffset, 
			titleSeparatorWidth + line * (win.fontSize + lineSpacing) + (lineSpacing / 2) - (win.fontSize / 4), 
			0, 
			0, 
			ColourNameToRGB(nColour), 
			true)
	end

	function PlayerHotspot(win, line, player)
		WindowAddHotspot(win.id, player, 
			2, 
			titleSeparatorWidth + line * (win.fontSize + lineSpacing), 
			win.width-20, 
			titleSeparatorWidth + (line + 1) * (win.fontSize+lineSpacing), 
			"", "", "", "", "OpenDetailWindow", "Click for additional details of: " .. player, 1, 0)
	end

	function PlayerHotspotMinMax(win, line, player, min, max)
		WindowAddHotspot(win.id, player, 
			2, 
			titleSeparatorWidth + line * (win.fontSize + lineSpacing), 
			2 + (win.fontSize*3), 
			titleSeparatorWidth + (line + 1) * (win.fontSize+lineSpacing), 
			"", "", "", "", "", "(" .. player .. ") Min damage: " .. min .. ". Max damage: " .. max, 1, 0)
	end

	function ExecuteDrawMain() Draw(window) end
	function QueueDrawMain()
		if throttle == "y" then
			if IsTimer("draw_main") ~= error_code.eOK then
				AddTimer("draw_main", 0, 0, .1, "", timer_flag.Enabled + timer_flag.OneShot, "ExecuteDrawMain")
			end
		else
			ExecuteDrawMain()
		end
	end

	function ExecuteDrawDetail() Draw(detailWindow) end
	function QueueDrawDetail()
		if throttle == "y" then
			if IsTimer("draw_detail") ~= error_code.eOK then
				AddTimer("draw_detail", 0, 0, .1, "", timer_flag.Enabled + timer_flag.OneShot, "ExecuteDrawDetail")
			end
		else
			ExecuteDrawDetail()
		end
	end

	function ExecuteDrawPlayer() Draw(playerWindow) end
	function QueueDrawPlayer()
		if throttle == "y" then
			if IsTimer("draw_player") ~= error_code.eOK then
				AddTimer("draw_player", 0, 0, .1, "", timer_flag.Enabled + timer_flag.OneShot, "ExecuteDrawPlayer")
			end
		else
			ExecuteDrawPlayer()
		end
	end

	function Draw(win)
		-- miniwin background and outline
		WindowRectOp(win.id, miniwin.rect_fill , 0, 0, win.width, win.height, ColourNameToRGB(window.backgroundColor))	
		WindowRectOp(win.id, miniwin.rect_3d_rect , 0, 0, win.width, win.height, ColourNameToRGB(window.borderColor), ColourNameToRGB(window.borderColor))				
		
		-- resize bars
		WindowLine(win.id, win.width-3,  win.height-2, win.width-2, win.height-3, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-4,  win.height-2, win.width-2, win.height-4, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-6,  win.height-2, win.width-2, win.height-6, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-7,  win.height-2, win.width-2, win.height-7, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-9,  win.height-2, win.width-2, win.height-9, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-10, win.height-2, win.width-2, win.height-10, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-12, win.height-2, win.width-2, win.height-12, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-13, win.height-2, win.width-2, win.height-13, ColourNameToRGB(window.backgroundColor), 0, 1)	

		-- Where the magic happens. Draw all the things!
		local line = 0
		if win.id == window.id then
			local totalDMG = 0
			local totalDPS = 0
			local totalDMGReceived = 0
			local totalDPSReceived = 0

			--Reset hotspots in case anyone changed positions in the list.
			CreateHotSpots(win)

			-- Draw title bar [Loqui Data Tracker       <- <sort Mode> ->]
			WindowText(win.id, win.font, "Loqui Data Tracker", 2, line * (win.fontSize+lineSpacing), 0, 0, ColourNameToRGB(window.fontColor), true)
			local titleText = "<- " .. sortOptions[sortMode] .. " ->"
			local sortWidth = WindowTextWidth(win.id, win.font, titleText, true) + 4
			WindowText(win.id, win.font, titleText, win.width-sortWidth, line * (win.fontSize + lineSpacing), 0, 0, ColourNameToRGB(window.fontColor), true)

			line = line + 1
			WindowLine(win.id, 2, titleSeparatorWidth + line * (win.fontSize + lineSpacing), win.width-2, titleSeparatorWidth + line * (win.fontSize + lineSpacing), ColourNameToRGB(window.borderColor), 0, titleSeparatorWidth)

			for name, player in pairs(players) do					
				totalDMG = totalDMG + player.damageDealt
				totalDPS = totalDPS + player.damageDealtPerSecond	
				totalDMGReceived = totalDMGReceived + player.damageReceived			
				totalDPSReceived = totalDPSReceived + player.damageReceivedPerSecond
			end
		
			if sortOptions[sortMode] == "dmg" then					
				local tempCount = 0
				for name, player in spairs(players, function(t,a,b) return t[a].damageDealt > t[b].damageDealt end) do
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if player.time > 0 then
							DrawLineBar(win, line, player.colour, player.damageDealt/totalDMG)
						end
						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%)", tempCount, player.name, commas(player.damageDealt), commas(string.format("%5.1f", player.damageDealtPerSecond)), (player.damageDealt/totalDMG)*100)
						DrawTextLine(win, line, lineText)
						PlayerHotspot(win, line, player.name)
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "dps" then				
				local tempCount = 0
				for name, player in spairs(players, function(t,a,b) return t[a].damageDealtPerSecond > t[b].damageDealtPerSecond end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if player.time > 0 then
							DrawLineBar(win, line, player.colour, player.damageDealtPerSecond/totalDPS)
						end
						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%)", tempCount, player.name, commas(player.damageDealt), commas(string.format("%5.1f", player.damageDealtPerSecond)), (player.damageDealtPerSecond/totalDPS)*100)
						DrawTextLine(win, line, lineText)		
						PlayerHotspot(win, line, player.name)			
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "dmgrec" then
				local tempCount = 0
				for name, player in spairs(players, function(t,a,b) return t[a].damageReceived > t[b].damageReceived end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if player.time > 0 then
							DrawLineBar(win, line, player.colour, player.damageReceived/totalDMGReceived)
						end
						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%)", tempCount, player.name, commas(player.damageReceived), commas(string.format("%5.1f", player.damageReceivedPerSecond)), (player.damageReceived/totalDMGReceived)*100)
						DrawTextLine(win, line, lineText)		
						PlayerHotspot(win, line, player.name)			
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "dpsrec" then
				local tempCount = 0			
				for name, player in spairs(players, function(t,a,b) return t[a].damageReceivedPerSecond > t[b].damageReceivedPerSecond end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if player.time > 0 then
							DrawLineBar(win, line, player.colour, player.damageReceivedPerSecond/totalDPSReceived)
						end
						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%)", tempCount, player.name, commas(player.damageReceived), commas(string.format("%5.1f", player.damageReceivedPerSecond)), (player.damageReceivedPerSecond/totalDPSReceived)*100)
						DrawTextLine(win, line, lineText)		
						PlayerHotspot(win, line, player.name)			
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "dodges" then
				if players["You"].dodges.Total.count > 0 and players["You"].dodgeableHitsReceived > 0 then					
					local tempCount = 0
					local dataPos = -1
					-- hits
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						DrawLineBar(win, line, players["You"].colour, 1)
						local lineText = string.format("%2i. %-20s %11s (%3.1f%%, %3.1f%%)", 
							(line-1), "Melee Received", 
							commas(players["You"].dodgeableHitsReceived), 					
							commas((players["You"].dodgeableHitsReceived/players["You"].dodgeableHitsReceived)*100),
							commas((players["You"].dodgeableHitsReceived/players["You"].dodges.Total.count)*100))
						DrawTextLine(win, line, lineText)
						line = line + 1					
					end

					-- dodges	
					for key, value in spairs(players["You"].dodges, function(t,a,b) return t[a].count > t[b].count end) do
						tempCount = tempCount + 1
						dataPos = dataPos + 1
						if tempCount >= scrollPosMain then
							DrawLineBar(win, line, value.colour, value.count/players["You"].dodgeableHitsReceived)
							local lineText = string.format("%2i. %-20s %11s (%3.1f%%, %3.1f%%)", 
								dataPos, key, 
								commas(value.count), 						
								commas((value.count/players["You"].dodgeableHitsReceived)*100),
								commas((value.count/players["You"].dodges.Total.count)*100))
							DrawTextLine(win, line, lineText)
							line = line + 1
						end
					end			

					-- enemy stuff
					-- hits			
					local lastDodgedLine = line	
					line = line + 1
					dataPos = -1			
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						DrawLineBar(win, line, players["You"].colour, 1)
						local lineText = string.format("%2i. %-20s %11s (%3.1f%%, %3.1f%%)", 
							(line-1-lastDodgedLine), "Melee Dealt", 
							players["You"].meleeHitsDealt, 					
							(players["You"].meleeHitsDealt/players["You"].meleeHitsDealt)*100,
							(players["You"].meleeHitsDealt/players["You"].enemydodges.Total.count)*100)
						DrawTextLine(win, line, lineText)
						line = line + 1					
					end

					-- dodges
					for key, value in spairs(players["You"].enemydodges, function(t,a,b) return t[a].count > t[b].count end) do
						tempCount = tempCount + 1
						dataPos = dataPos + 1
						if tempCount >= scrollPosMain then
							DrawLineBar(win, line, value.colour, value.count/players["You"].meleeHitsDealt)
							local lineText = string.format("%2i. %-20s %11s (%3.1f%%, %3.1f%%)", 
								dataPos, key,
								value.count, 						
								(value.count/players["You"].meleeHitsDealt)*100,
								(value.count/players["You"].enemydodges.Total.count)*100)
							DrawTextLine(win, line, lineText)
							line = line + 1			
						end
					end
				end
			elseif sortOptions[sortMode] == "exp" then
				local tempCount = 0				
				for key, value in spairs(expTable.areas, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if value.time > 0 then
							DrawLineBar(win, line, value.colour, value.total/expTable.total)
						end

						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%)", tempCount, key, commas(value.total), commas(string.format("%5.1f", 1000/(value.total/value.time))), (value.total/expTable.total)*100)
						DrawTextLine(win, line, lineText)		
						PlayerHotspot(win, line, key)			
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "gold" then
				local tempCount = 0				
				for key, value in spairs(goldTable.areas, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if value.time > 0 then
							DrawLineBar(win, line, value.colour, value.total/goldTable.total)
						end

						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%)", tempCount, key, commas(value.total), commas(string.format("%5.1f", value.total/value.time)), (value.total/goldTable.total)*100)
						DrawTextLine(win, line, lineText)		
						PlayerHotspot(win, line, key)			
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "pups" then
				local tempCount = 0			
				for key, value in spairs(clanTable.pupInfo, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if value.total > 0 then
							DrawLineBar(win, line, value.colour, value.total/clanTable.totalPup)
						end

						local lineText = string.format("%2i. %-11s %6s (%7s, %5.1f%%) Last: %s", tempCount, key, commas(value.total), commas(string.format("%5.1f", (value.time/value.total))), (value.total/clanTable.totalPup)*100, GetTimeString((os.clock() - value.last)))
						DrawTextLine(win, line, lineText)		
						PlayerHotspot(win, line, key)
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "lvls" then
				local tempCount = 0
				for key, value in spairs(clanTable.lvlInfo, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if value.total > 0 then
							DrawLineBar(win, line, value.colour, value.total/clanTable.totalLvl)
						end

						local lineText = string.format("%2i. %-11s %6s (%7s, %5.1f%%) Last: %s", tempCount, key, commas(value.total), commas(string.format("%5.1f", (value.time/value.total))), (value.total/clanTable.totalLvl)*100, GetTimeString((os.clock() - value.last)))
						DrawTextLine(win, line, lineText)		
						PlayerHotspot(win, line, key)
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "deaths" then
				local tempCount = 0			
				for key, value in spairs(clanTable.deathInfo, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosMain then
						if value.total > 0 then
							DrawLineBar(win, line, value.colour, value.total/clanTable.totalDeath)
						end

						local lineText = string.format("%2i. %-11s %6s (%7s, %5.1f%%) Last: %s", tempCount, capFirstLetter(key), commas(value.total), commas(string.format("%5.1f", (value.time/value.total))), (value.total/clanTable.totalDeath)*100, GetTimeString((os.clock() - value.last)))
						DrawTextLine(win, line, lineText)
						PlayerHotspot(win, line, key)
						line = line + 1
					end
				end
			elseif sortOptions[sortMode] == "goals" then
				if tonumber(goalData["exp"].goal) > 0 then
					local lineText = ""
					if (tonumber(goalData["exp"].goal)-tonumber(goalData["exp"].current)) > 0 then
						DrawLineBar(win, line, goalData["exp"].colour, (tonumber(goalData["exp"].goal)-tonumber(goalData["exp"].current))/tonumber(goalData["exp"].goal))
						lineText = "Exp Goal : " .. commas((tonumber(goalData["exp"].goal)-tonumber(goalData["exp"].current))) .. " remaining."
					else
						lineText = "Exp Goal : Completed!"
					end
					DrawTextLine(win, line, lineText)		
					line = line + 1
				end
				if tonumber(goalData["gold"].goal) > 0 then
					local lineText = ""
					if (tonumber(goalData["gold"].goal)-tonumber(goalData["gold"].current)) > 0 then
						DrawLineBar(win, line, goalData["gold"].colour, (tonumber(goalData["gold"].goal)-tonumber(goalData["gold"].current))/tonumber(goalData["gold"].goal))
						lineText = "Gold Goal: " .. commas((tonumber(goalData["gold"].goal)-tonumber(goalData["gold"].current))) .. " remaining."
					else
						lineText = "Gold Goal: Completed!"
					end
					DrawTextLine(win, line, lineText)		
					line = line + 1
				end
				if tonumber(goalData["pup"].goal) > 0 then
					local lineText = ""
					if (tonumber(goalData["pup"].goal)-tonumber(goalData["pup"].current)) > 0 then
						DrawLineBar(win, line, goalData["pup"].colour, (tonumber(goalData["pup"].goal)-tonumber(goalData["pup"].current))/tonumber(goalData["pup"].goal))
						lineText = "Pup Goal : " .. commas((tonumber(goalData["pup"].goal)-tonumber(goalData["pup"].current))) .. " remaining."
					else
						lineText = "Pup Goal : Completed!"
					end
					DrawTextLine(win, line, lineText)		
					line = line + 1
				end
				if tonumber(goalData["lvl"].goal) > 0 then
					local lineText = ""
					if (tonumber(goalData["lvl"].goal)-tonumber(goalData["lvl"].current)) > 0 then
						DrawLineBar(win, line, goalData["lvl"].colour, (tonumber(goalData["lvl"].goal)-tonumber(goalData["lvl"].current))/tonumber(goalData["lvl"].goal))
						lineText = "Lvl Goal : " .. commas((tonumber(goalData["lvl"].goal)-tonumber(goalData["lvl"].current))) .. " remaining."
					else
						lineText = "Lvl Goal : Completed!"
					end
					DrawTextLine(win, line, lineText)		
					line = line + 1
				end
			end
		elseif win.id == detailWindow.id then
			-- Draw title bar [Loqui Data Tracker        x]
			WindowText(win.id, win.font, "Loqui Data Tracker(Details of: " .. capFirstLetter((win.player or "N/A")) .. ")", 2, line * (win.fontSize + lineSpacing), 0, 0, ColourNameToRGB(window.fontColor), true)
			WindowText(win.id, win.font, "X", win.width-(lineSpacing+win.fontSize), line * (win.fontSize+lineSpacing), 0, 0, ColourNameToRGB(window.fontColor), true)
			line = line + 1
			WindowLine(win.id, 2, titleSeparatorWidth + line * (win.fontSize + lineSpacing), win.width-2, titleSeparatorWidth + line * (win.fontSize + lineSpacing), ColourNameToRGB(window.borderColor), 0, titleSeparatorWidth)

			--Reset hotspots in case anyone changed positions in the list.
			CreateHotSpots(win)

			if win.player ~= nil and players[win.player] ~= nil then
				local player = players[win.player]			

				if sortOptions[sortMode] == "dmg" or sortOptions[sortMode] == "dps" then
					local tempCount = 0
					for name, attack in spairs(player.attacksDealt, function(t,a,b) return t[a].damage > t[b].damage end) do										
						tempCount = tempCount + 1
						if tempCount >= scrollPosDetail then
							if (attack.damage / player.damageDealt) * 100 > tonumber(filterAmount) then
								if attack.damage > 0 then
									DrawLineBar(win, line, attack.colour, attack.damage / player.damageDealt)
								end
	
								local lineText = string.format("%2i. [%4.4s%%] %-10.10s %11s %5shits(%5s/hit) %5scrits(%2.2f%%)  ", tempCount, commas((attack.damage/player.damageDealt)*100), name, commas(math.floor(attack.damage)), commas(math.floor(attack.hits)),  commas(math.floor(attack.damage/attack.hits)), commas(math.floor(attack.crits)), ((attack.crits/attack.hits)*100))
								DrawTextLine(win, line, lineText)
								PlayerHotspotMinMax(win, line, player.name .. "_" .. name, attack.min, attack.max)
								line = line + 1
							end	
						end
					end
				elseif sortOptions[sortMode] == "dmgrec" or sortOptions[sortMode] == "dpsrec" then
					-- grouped damage
					-- melee vs spell
					local startX = 1
					local endX = 1
					local tempCount = 0
					local meleePct = player.damageAggregates.melee/player.damageReceived
					local spellPct = player.damageAggregates.spell/player.damageReceived			
					local mprogPct = player.damageAggregates.mprog/player.damageReceived	
					local physicalPct = player.damageAggregates.physical/player.damageReceived	
					local magicPct = player.damageAggregates.magic/player.damageReceived			
					local mprogPct = player.damageAggregates.mprog/player.damageReceived	

					tempCount = tempCount + 1
					if tempCount >= scrollPosDetail then
						endX = DrawLineBar(win, line, colours.meleeDamage, meleePct, startX)
						DrawTextLine(win, line, string.format("%.1f", meleePct * 100) .. "% Melee", startX)
						startX = endX					

						endX = DrawLineBar(win, line, colours.spellDamage, spellPct, startX)
						DrawTextLine(win, line, string.format("%.1f", spellPct * 100) .. "% Spell", startX)
						startX = endX										

						endX = DrawLineBar(win, line, colours.damTypes.mprog, mprogPct, startX)
						DrawTextLine(win, line, string.format("%.1f", mprogPct * 100) .. "% MProg", startX)
						startX = endX					
						
						line = line + 1
					end

					startX = 1
					endX = 1
					-- physical vs magic
					tempCount = tempCount + 1
					if tempCount >= scrollPosDetail then
						endX = DrawLineBar(win, line, colours.physicalDamage, physicalPct, startX)
						DrawTextLine(win, line, string.format("%.1f", physicalPct * 100) .. "% Physical", startX)
						startX = endX										

						endX = DrawLineBar(win, line, colours.magicDamage, magicPct, startX)
						DrawTextLine(win, line, string.format("%.1f", magicPct * 100) .. "% Magic", startX)
						startX = endX	

						endX = DrawLineBar(win, line, colours.damTypes.mprog, mprogPct, startX)					
						startX = endX

						line = line + 1
					end

					startX = 1
					endX = 1
					-- damtypes								
					tempCount = tempCount + 1
					if tempCount >= scrollPosDetail then
						for damType, damage in spairs(player.damageAggregates.damtypes, function(t,a,b) return t[a] > t[b] end) do
							local damagePercent = damage/player.damageReceived
							if damagePercent ~= damagePercent then damagePercent = 0 end
	
							endX = DrawLineBar(win, line, colours.damTypes[damType], damagePercent, startX)
							DrawTextLine(win, line, damType, startX)					

							startX = endX
						end
						line = line + 1
					end

					if magicPct > physicalPct then
						tempCount = tempCount + 1
						if tempCount >= scrollPosDetail then
							local lineText = string.format("    %-20s %11s %5shits(%5s/hit)  %3.2f%%", "All Magical", commas(math.floor(player.damageAggregates.magic)), commas(math.floor(player.magicHitsReceived)), commas(math.floor(player.damageAggregates.magic/player.magicHitsReceived)), magicPct*100)
							DrawLineBar(win, line, colours.magicDamage, magicPct)
							DrawTextLine(win, line, lineText)
							line = line + 1
						end

						tempCount = tempCount + 1
						if tempCount >= scrollPosDetail then
							lineText = string.format("    %-20s %11s %5shits(%5s/hit)  %3.2f%%", "All Physical", commas(math.floor(player.damageAggregates.physical)), commas(math.floor(player.physicalHitsReceived)), commas(math.floor(player.damageAggregates.physical/player.physicalHitsReceived)), physicalPct*100)
							DrawLineBar(win, line, colours.physicalDamage, physicalPct)
							DrawTextLine(win, line, lineText)
							line = line + 1
						end
					else
						tempCount = tempCount + 1
						if tempCount >= scrollPosDetail then
							local lineText = string.format("    %-20s %11s %5shits(%5s/hit)  %3.2f%%", "All Physical", commas(math.floor(player.damageAggregates.physical)), commas(math.floor(player.physicalHitsReceived)), commas(math.floor(player.damageAggregates.physical/player.physicalHitsReceived)), physicalPct*100)
							DrawLineBar(win, line, colours.physicalDamage, physicalPct)
							DrawTextLine(win, line, lineText)
							line = line + 1
						end

						tempCount = tempCount + 1
						if tempCount >= scrollPosDetail then
							lineText = string.format("    %-20s %11s %5shits(%5s/hit)  %3.2f%%", "All Magical", commas(math.floor(player.damageAggregates.magic)), commas(math.floor(player.magicHitsReceived)), commas(math.floor(player.damageAggregates.magic/player.magicHitsReceived)), magicPct*100)
							DrawLineBar(win, line, colours.magicDamage, magicPct)
							DrawTextLine(win, line, lineText)
							line = line + 1
						end
					end
				
					-- individual damage
					for name, attack in spairs(player.attacksReceived, function(t,a,b) return t[a].damage > t[b].damage end) do										
						tempCount = tempCount + 1
						if tempCount >= scrollPosDetail then
							if (attack.damage / player.damageReceived) * 100 > tonumber(filterAmount) then
								if attack.damage > 0 then
									DrawLineBar(win, line, attack.colour, attack.damage / player.damageReceived)
								end

								local lineText = string.format("%2i. %-20s %11s %5shits(%5s/hit)  %3.2f%%", tempCount-5, name, commas(math.floor(attack.damage)), commas(math.floor(attack.hits)), commas(math.floor(attack.damage/attack.hits)), (attack.damage/player.damageReceived)*100)
								DrawTextLine(win, line, lineText)
								PlayerHotspotMinMax(win, line, player.name .. "_" .. name, attack.min, attack.max)
								line = line + 1
							end
						end
					end
				end

				if line == 1 then --No data was found
					DrawTextLine(win, line, "No data available.")
				end

				return								
			end

			if sortOptions[sortMode] == "pups" and win.player ~= nil and clanTable.pupInfo[win.player] ~= nil then
				local tempCount = 0
				for key, value in spairs(clanTable.pupInfo[win.player].puppers, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosDetail then
						if value.time/value.total >= tonumber(pupFilterAmount) then
							if value.total > 0 then
								DrawLineBar(win, line, value.colour, value.total/clanTable.pupInfo[win.player].total)
							end

							local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%) Last: %s", tempCount, key, commas(value.total), commas(string.format("%5.1f", (value.time/value.total))), (value.total/clanTable.pupInfo[win.player].total)*100, GetTimeString((os.clock() - value.last)))
							DrawTextLine(win, line, lineText)		
							line = line + 1
						end
					end
				end
				return
			end

			if sortOptions[sortMode] == "lvls" and win.player ~= nil and clanTable.lvlInfo[win.player] ~= nil then
				local tempCount = 0
				for key, value in spairs(clanTable.lvlInfo[win.player].levelers, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosDetail then
						if value.total > 0 then
							DrawLineBar(win, line, value.colour, value.total/clanTable.lvlInfo[win.player].total)
						end

						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%) Last: %s", tempCount, key, commas(value.total), commas(string.format("%5.1f", (value.time/value.total))), (value.total/clanTable.lvlInfo[win.player].total)*100, GetTimeString((os.clock() - value.last)))
						DrawTextLine(win, line, lineText)		
						line = line + 1
					end
				end
				return
			end

			if sortOptions[sortMode] == "deaths" and win.player ~= nil and clanTable.deathInfo[win.player] ~= nil then
				local tempCount = 0
				for key, value in spairs(clanTable.deathInfo[win.player].players, function(t,a,b) return t[a].total > t[b].total end) do						
					tempCount = tempCount + 1
					if tempCount >= scrollPosDetail then
						if value.total > 0 then
							DrawLineBar(win, line, value.colour, value.total/clanTable.deathInfo[win.player].total)
						end

						local lineText = string.format("%2i. %-15s %11s (%7s, %5.1f%%) Last: %s", tempCount, value.name, commas(value.total), commas(string.format("%5.1f", (value.time/value.total))), (value.total/clanTable.deathInfo[win.player].total)*100, GetTimeString((os.clock() - value.last)))
						DrawTextLine(win, line, lineText)		
						line = line + 1
					end
				end
				return
			end

			if sortOptions[sortMode] == "gold" and win.player ~= nil and goldTable.areas[win.player] ~= nil then
				--Time in area: 12 seconds.
				local textWidth = 0
				local lineText = "Time in area: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].time))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				lineText = "Time in area: " .. lineText
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				DrawTextLineExt(win, line, " seconds.", "darkcyan", textWidth)
				line = line + 1

				--Total Gold: 100
				local textWidth = 0
				local lineText = "Total Gold: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].total))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				line = line + 1

				--Gold per mob: 3242.23
				local textWidth = 0
				local lineText = "Gold per mob: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%.2f", ((goldTable.areas[win.player].mob+goldTable.areas[win.player].crumble-goldTable.areas[win.player].shared)/goldTable.areas[win.player].mobCount)))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				line = line + 1
				
				--Rates: 232.23/sec 2,432.32/hr 12,232.42/hr
				local soFarString = "Gold Rates: "
				lineText = "Gold Rates: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%.2f", (goldTable.areas[win.player].total/goldTable.areas[win.player].time)))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "/"
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "sec "
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%.2f", (goldTable.areas[win.player].total/goldTable.areas[win.player].time)*60))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "/"
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "min "
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%.2f", ((goldTable.areas[win.player].total/goldTable.areas[win.player].time)*60)*60))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "/"
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "hr"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				line = line + 2


				--Sources:
				lineText = "Source: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				line = line + 1

				--50 mobs | 25 crumbles | 10 shared
				soFarString = ""
				lineText = ""
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].mob))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " mobs"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].crumble))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " crumbles"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].shared))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " shared"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				line = line + 1

				--10 daily | 10 sac | 5 db
				soFarString = ""
				lineText = ""
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].dbkill))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " daily"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].sac))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " sac"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].db))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " db"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				line = line + 1

				--50 sell | 20 fence | 25 haggle
				soFarString = ""
				lineText = ""
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].sell))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " sell"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].fence))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " fence"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].haggle))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " haggle"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				line = line + 1

				--5 cp | 5 gq | 5 quest
				soFarString = ""
				lineText = ""
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].cp))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " cp"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].gq))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " gq"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].quest))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " quest"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				line = line + 1

				--5 tax
				soFarString = ""
				lineText = ""
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", goldTable.areas[win.player].tax))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " tax"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				return
			end

			if sortOptions[sortMode] == "exp" and win.player ~= nil and expTable.areas[win.player] ~= nil then
				local textWidth = 0
				local lineText = "Time in area: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", expTable.areas[win.player].time))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				lineText = "Time in area: " .. lineText
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				DrawTextLineExt(win, line, " seconds.", "darkcyan", textWidth)
				line = line + 1

				local soFarString = "Experience: "
				lineText = "Experience: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%i", expTable.areas[win.player].total))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " ("
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", expTable.areas[win.player].normal))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " normal"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", expTable.areas[win.player].rare))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " rare"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", expTable.areas[win.player].double))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " double"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " | "
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%i", expTable.areas[win.player].daily))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = " daily"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = ")"
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				line = line + 1

				soFarString = "Exp per mob: "
				lineText = "Exp per mob: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%.2f", (expTable.areas[win.player].normal/expTable.areas[win.player].mobs)))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				line = line + 1
				
				soFarString = "Exp Rates: "
				lineText = "Exp Rates: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%.2f", (expTable.areas[win.player].total/expTable.areas[win.player].time)))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "/"
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "sec "
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%.2f", (expTable.areas[win.player].total/expTable.areas[win.player].time)*60))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "/"
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "min "
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = commas(string.format("%.2f", ((expTable.areas[win.player].total/expTable.areas[win.player].time)*60)*60))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "/"
				DrawTextLineExt(win, line, lineText, "cyan", textWidth)
				soFarString = soFarString .. lineText
				textWidth = WindowTextWidth(win.id, win.font, soFarString, true)
				lineText = "hr"
				DrawTextLineExt(win, line, lineText, "darkcyan", textWidth)
				line = line + 1

				soFarString = "Time per 1k Exp: "
				lineText = "Time per 1k Exp: "
				DrawTextLineExt(win, line, lineText, "cyan", 0)
				textWidth = WindowTextWidth(win.id, win.font, lineText, true)
				lineText = commas(string.format("%.2f", 1000/(expTable.areas[win.player].total/expTable.areas[win.player].time)))
				DrawTextLineExt(win, line, lineText, "white", textWidth)
				
				return
			end
			DrawTextLine(win, line, "No data available.")
		elseif win.id == playerWindow.id then					
			-- calculating bar widths
			local metrics = {
				dps = {
					order = 1,	
					formatDiff = "%#.1f",
					overall = {
						color = ColourNameToRGB("lime")
					},
					rolling = {
						color = 0x306030
					}
				},
				dpsRec = {
					order = 2,	
					formatDiff = "%#.1f",				
					overall = {	
						color = ColourNameToRGB("red")						
					},
					rolling = {
						color = ColourNameToRGB("maroon")
					}
				},
				dodge = {
					order = 3,	
					formatDiff = "%#.1f",				
					overall = {	
						color = ColourNameToRGB("deepskyblue")
					},
					rolling = {
						color = 0x5E4934
					}
				},
				meleeVsSpell = {
					order = 4,
					formatDiff = "%#.1f",					
					overall = {
						color = ColourNameToRGB("orange")
					},
					rolling = {
						color = ColourNameToRGB("saddlebrown")
					}
				},
				physicalVsMagic = {
					order = 5,	
					formatDiff = "%#.1f",				
					overall = {
						color = ColourNameToRGB("mediumorchid")
					},
					rolling = {
						color = ColourNameToRGB("indigo")
					}
				},
				highestDamage = {
					order = 6,	
					formatDiff = "%#.1f",				
					overall = {
						color = ColourNameToRGB("cyan")
					},
					rolling = {
						color = 0xB98029
					}
				},
				exp = {
					order = 7,	
					formatDiff = "%d",				
					overall = {						
						color = ColourNameToRGB("magenta")
					},
					rolling = {
						color = ColourNameToRGB("darkmagenta")
					}
				},
				gold = {
					order = 9,	
					formatDiff = "%d",				
					overall = {
						color = ColourNameToRGB("yellow")
					},
					rolling = {
						color = ColourNameToRGB("olive")
					}
				}
			}

			FormatPlayerData(metrics, lastPlayerData, "overall")
			FormatPlayerData(metrics, rollingPlayerData, "rolling")		

			-- calculate the lengths of the text			
			local longestMetric = 0

			if playerWinOrientation == "vertical" then
				for metric, info in pairs(metrics) do
					metrics[metric].len = win.width - 8  -- to lazy to figure out where this 8 comes from :(

					metrics[metric].diff = fixNaN(metrics[metric].rolling.value - metrics[metric].overall.value)
				end
			else
				for metric, data in pairs(metrics) do
					metrics[metric].diff = fixNaN(metrics[metric].rolling.value - metrics[metric].overall.value)

					metrics[metric].len = WindowTextWidth(win.id, win.font, 
						string.rep(" ", 
							string.len(metrics[metric].rolling.title .. metrics[metric].rolling.text) + 
							string.len(" "..commas(string.gsub(string.format(metrics[metric].formatDiff, metrics[metric].diff), "-", "")))))				
				end		
			end			
					
			-- calculate the bar lengths
			for metric, data in pairs(metrics) do
				if metrics[metric].overall.value >= metrics[metric].rolling.value then
					metrics[metric].overall.pct = 1
					metrics[metric].rolling.pct = fixNaN(metrics[metric].rolling.value / metrics[metric].overall.value)					
				else
					metrics[metric].rolling.pct = 1
					metrics[metric].overall.pct = fixNaN(metrics[metric].overall.value / metrics[metric].rolling.value)					
				end				
			end								
			
			local lineHeight = 20		
			local xPadding = 3	
			local overallBarHeight = 4
			local rollingBarHeight = lineHeight - overallBarHeight
			local startX = 1
			local startY = 1			

			-- finally, draw everything
			for metric, data in spairs(metrics, function(t,a,b) return t[a].order < t[b].order end) do
				-- overall bar
				WindowRectOp(win.id, miniwin.rect_fill, startX, startY, startX + metrics[metric].overall.pct * (metrics[metric].len + 2 * xPadding), startY + overallBarHeight, metrics[metric].overall.color)
				
				-- rolling bar
				WindowRectOp(win.id, miniwin.rect_fill, startX, startY + overallBarHeight, startX + metrics[metric].rolling.pct * (metrics[metric].len + 2 * xPadding), startY + lineHeight, (metrics[metric].rolling.color or ColourNameToRGB("gray")))

				-- value | diff
				WindowText(win.id, win.font, 
					metrics[metric].rolling.title .. metrics[metric].rolling.text .. " ", 
					startX + xPadding, startY + overallBarHeight + 1, 
					startX + metrics[metric].len + xPadding, startY + lineHeight, 
					ColourNameToRGB("whitesmoke"), true)	

				local diffColor = "whitesmoke"
				if metrics[metric].diff < 0 then
					diffColor = "red"
				elseif metrics[metric].diff > 0 then
					diffColor = "lime"
				end

				local diffText = commas(string.gsub(string.format(metrics[metric].formatDiff , metrics[metric].diff), "-", ""))
				local diffTextLength = WindowTextWidth(win.id, win.font, diffText)
				WindowText(win.id, win.font, 
					diffText,
					(startX + metrics[metric].len + xPadding) - diffTextLength, startY + overallBarHeight + 1, 
					startX + metrics[metric].len + (2 * xPadding), startY + lineHeight, 
					ColourNameToRGB(diffColor), true)

				-- setup for next metric
				if playerWinOrientation == "vertical" then
					startY = startY + lineHeight					
					startX = 1
				else
					startY = 1					
					startX = startX + metrics[metric].len + 2 * xPadding 
				end		
			end
		end
	end	

	function FormatPlayerData(metrics, playerData, category)
		formattedData = {}

		metrics.dps[category].title = "DMG:"
		metrics.dps[category].value = playerData.damageDealt/playerData.damageTime		
		metrics.dps[category].text = commas(string.format("%#.1f", fixNaN(metrics.dps[category].value)))
		

		metrics.dpsRec[category].title = "REC:"	
		metrics.dpsRec[category].value = playerData.damageReceived/playerData.damageTime		
		metrics.dpsRec[category].text = commas(string.format("%#.1f", fixNaN(metrics.dpsRec[category].value)))
		
		
		metrics.dodge[category].title = "DOD:"
		metrics.dodge[category].value = fixNaN(playerData.totalDodges / playerData.dodgeableHitsReceived) * 100
		metrics.dodge[category].text = string.format("%3.1f%%", metrics.dodge[category].value)

		-- melee vs spell
		local meleeVsSpellStr = "MvS"
		if (playerData.damageAggregates.spell or 0) > (playerData.damageAggregates.melee or 0) then
			metrics.meleeVsSpell[category].title = "S "
			metrics.meleeVsSpell[category].value = fixNaN((playerData.damageAggregates.spell or 0) / playerData.damageReceived) * 100			
		else
			metrics.meleeVsSpell[category].title = "M "
			metrics.meleeVsSpell[category].value = fixNaN((playerData.damageAggregates.melee or 0) / playerData.damageReceived) * 100			
		end
		metrics.meleeVsSpell[category].text = string.format("%3.1f%%", metrics.meleeVsSpell[category].value)


		-- physical vs magic		
		if (playerData.damageAggregates.physical or 0) > (playerData.damageAggregates.magic or 0) then
			metrics.physicalVsMagic[category].title = "P "
			metrics.physicalVsMagic[category].value = fixNaN((playerData.damageAggregates.physical or 0) / playerData.damageReceived) * 100			
		else
			metrics.physicalVsMagic[category].title = "M "
			metrics.physicalVsMagic[category].value = fixNaN((playerData.damageAggregates.magic or 0) / playerData.damageReceived) * 100
			
		end
		metrics.physicalVsMagic[category].text = string.format("%3.1f%%", metrics.physicalVsMagic[category].value)

		-- highest damage type
		metrics.highestDamage[category].value = 0
		metrics.highestDamage[category].title = "AIR "
		for damType, damage in pairs(playerData.damageAggregates.damtypes) do
			if damage > metrics.highestDamage[category].value then
				metrics.highestDamage[category].title = string.upper(string.sub(damType, 1, 3)) .. " "
				metrics.highestDamage[category].value = damage
			end
		end		
		metrics.highestDamage[category].value = fixNaN(metrics.highestDamage[category].value / playerData.damageReceived) * 100
		metrics.highestDamage[category].text = string.format("%3.1f%%", metrics.highestDamage[category].value)

		-- exp
		metrics.exp[category].title = "XP:"
		metrics.exp[category].value = math.floor(fixNaN(playerData.expTotal/playerData.expTime))		
		metrics.exp[category].text = commas(metrics.exp[category].value) .."/s" 

		-- gold
		metrics.gold[category].title = "Gold:"
		metrics.gold[category].value = math.floor(fixNaN(playerData.goldTotal/(playerData.goldTime/60)))
		metrics.gold[category].text = commas(metrics.gold[category].value) .. "/m"			
	end

	function OpenDetailWindow(flags, hotspot_id)
		detailWindow.player = hotspot_id
		ShowWindow(detailWindow, "detailWindow")
	end

	function TypeToOpenDetailWindow(name, line, wildcards)
		if wildcards[1] ~= "" and wildcards[1] ~= nil then
			if type(wildcards[1]) == 'string' then
				detailWindow.player = string.gsub(wildcards[1], "^%s*", "")
			end
		end
		
		ColourNote("orange", "", "Now displaying details for " .. detailWindow.player .. ".")
		ShowWindow(detailWindow, "detailWindow")
	end
	
	function InitializeWindow(win)
		WindowCreate(win.id, win.left, win.top, win.width, win.height, miniwin.pos_center_all, miniwin.create_keep_hotspots, ColourNameToRGB(win.backgroundColor))
		WindowFont(win.id, win.font, win.fontFamily, win.fontSize, false, false, false, false, 1, 0)
		WindowPosition(win.id, win.left, win.top, miniwin.pos_stretch_to_view, miniwin.create_absolute_location)	

		CreateHotSpots(win)
		if (win.show) then
			WindowShow(win.id, win.show)				
			if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
				CallPlugin(z_order_plugin, "boostMe", win.id)
			end
			Draw(win)
		end	
	end
	
	function DeleteWindow(win)
		WindowDelete(win.id)
	end

	function ShowPlayerWindow()
		ShowWindow(playerWindow)
	end

	function HidePlayerWindow()
		HideWindow(playerWindow)
	end
	
	function AliasShowWindow(name, line, wildcards)
		if wildcards[1] == "a" then
			ShowWindow(window)
			ShowWindow(detailWindow)
			ShowWindow(playerWindow)
		elseif wildcards[1] == "m" then
			ShowWindow(window)
		elseif wildcards[1] == "d" then
			ShowWindow(detailWindow)
		elseif wildcards[1] == "p" then
			ShowWindow(playerWindow)
		end
	end

	function AliasHideWindow(name, line, wildcards)
		if wildcards[1] == "a" then
			HideWindow(window)
			HideWindow(detailWindow)
			HideWindow(playerWindow)
		elseif wildcards[1] == "m" then
			HideWindow(window)
		elseif wildcards[1] == "d" then
			HideWindow(detailWindow)
		elseif wildcards[1] == "p" then
			HideWindow(playerWindow)
		end
	end

	function ShowWindow(win)
		if win.id == detailWindow.id then
			detailWindow.show = true
		elseif win.id == playerWindow.id then
			playerWindow.show = true
		else --Default to main window
			window.show = true
			win = window --In case this was called from the alias, which doesn't supply win
		end
		WindowShow(win.id, true)
		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "boostMe", win.id)
		end
		Draw(win)
		SaveWindow(win)	
	end
	
	function HideWindow(win)
		if win.id == detailWindow.id then
			detailWindow.show = false
		elseif win.id == playerWindow.id then
			playerWindow.show = false
		else --Default to main window
			window.show = false
			win = window --In case this was called from the alias, which doesn't supply win
		end
		WindowShow(win.id, false)
		Draw(win)
		SaveWindow(win)
	end	
	
	function SaveWindow(win)
		if win.id == ("window_" .. GetPluginID()) then
			SetVariable("window", serialize.save_simple(window))
		elseif win.id == ("detailWindow_" .. GetPluginID()) then
			SetVariable("detailWindow", serialize.save_simple(detailWindow))
		elseif win.id == ("playerWindow_" .. GetPluginID()) then
			SetVariable("playerWindow", serialize.save_simple(playerWindow))
		end
	end	
	
	function SetWindowDefaults(name)
		local win = {
			id = name .. "_" .. GetPluginID(),
			top = 10,
			left = 10,
			width = 200,
			height = 50,
			show = true,
			font = "defaultFont",
			fontFamily = "Consolas",
			fontSize = 9,
			fontColor = "white",
			borderColor = "gray",
			backgroundColor = "black"
		}
		return win
	end

	function userReset() --Specifically for the alias "dmg win reset"
		window = SetWindowDefaults("window")
		ResetWindow(window, "window")
		window = SetWindowDefaults("detailWindow")
		ResetWindow(window, "detailWindow")
	end

	function ResetWindow(win, name)
		win = SetWindowDefaults(name)
		SaveWindow(win)	
		InitializeWindow(win)				
		Draw(win)
	end

	function SetPlayerWinOrientation(name, line, wildcards)
		playerWinOrientation = wildcards[1]
		SetVariable("playerWinOrientation", playerWinOrientation)
		ColourNote("orange", "", "Player window orientation set to: ", "cyan", "", playerWinOrientation)

		QueueDrawPlayer()
	end	

--Note: I do not like the way the below functions operate since I don't
--think I can pass a window to the dragmove/etc functions, so I have to
--muddle with the hotspot ID and differentiate within the functions and
--basically duplicate code. If you can think of a better way of doing
--this, by all means change them. Only alternative I can think of is to
--make custom functions for each window(dragmovemain, dragmovedetail,
--etc). If you prefer that way, also feel free to change it.

	function CreateHotSpots(win)
		WindowDeleteAllHotspots(win.id)		


		if win.id == window.id then --Title bar needs to be different for each miniwindow
			local sortTypeWidth = WindowTextWidth(win.id, win.font, sortOptions[sortMode], true)
			local arrowWidth = WindowTextWidth(win.id, win.font, "<- ", true)
			local spacing = 4


			WindowAddHotspot(win.id, win.id .. "DragTitle", 0, 0, win.width - (2 * arrowWidth + sortTypeWidth + spacing), win.fontSize, 
				"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
			WindowDragHandler(win.id, win.id .. "DragTitle", "dragmove", "dragrelease", 0)	

			WindowAddHotspot(win.id, win.id .. "leftArrow", win.width - (2 * arrowWidth + sortTypeWidth + spacing), 0, win.width - (arrowWidth + sortTypeWidth + spacing), lineSpacing + win.fontSize, 
				"", "", "", "", "PrevSort", "Click to change sorting mode.", 8, 0)
			WindowAddHotspot(win.id, win.id .. "rightArrow", win.width - (arrowWidth + spacing), 0, win.width - (spacing / 2), win.fontSize, 
				"", "", "", "", "NextSort", "Click to change sorting mode.", 8, 0)

		elseif win.id == detailWindow.id then
			WindowAddHotspot(win.id, win.id .. "DragTitle", 0, 0, win.width-(6+win.fontSize), lineSpacing + win.fontSize, 
				"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
			WindowDragHandler(win.id, win.id .. "DragTitle", "dragmove", "dragrelease", 0)	

			WindowAddHotspot(win.id, win.id .. "closeDetails", win.width-(6+win.fontSize), 0, win.width-2, win.fontSize, 
				"", "", "", "", "closeDetails", "Click to close the details window.", 1, 0)
		elseif win.id == playerWindow.id then			
			WindowAddHotspot(win.id, win.id .. "DragTitle", 0, 0, win.width-(6+win.fontSize), lineSpacing + win.fontSize, 
				"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
			WindowDragHandler(win.id, win.id .. "DragTitle", "dragmove", "dragrelease", 0)	
		end

		WindowAddHotspot(win.id, win.id .. "scrollBar", 0, win.fontSize, win.width, win.height, "", "", "", "", "", "", miniwin.arrow, 0)
		WindowScrollwheelHandler(win.id, win.id .. "scrollBar", "wheelMove")
		
		WindowAddHotspot(win.id, win.id .. "Resize", 
			win.width-13, win.height-13, win.width-2, win.height-2,
			"", "", "", "", "mouseup", "Drag to resize", miniwin.cursor_nw_se_arrow, 0)
		WindowDragHandler(win.id, win.id .. "Resize", "resizemove", "resizerelease", 0) 
	end
	function closeDetails(flags, hotspot_id)
		HideWindow(detailWindow)
	end
	-- Handlers

	function wheelMove (flags, hotspot_id)
		local thisWindow = GetWindowFromHotspotId(hotspot_id)
		if bit.band (flags, 0x100) ~= 0 then -- wheel scrolled down (towards you)
			if thisWindow.id == window.id then
				scrollPosMain = math.min(scrollPosMain + 1, scrollCap)
			else
				scrollPosDetail = math.min(scrollPosDetail + 1, scrollCap)
			end
	    	else -- wheel scrolled up (away from you)
			if thisWindow.id == window.id then
				scrollPosMain = math.max(scrollPosMain - 1, 0)
				
			else
				scrollPosDetail = math.max(scrollPosDetail - 1, 0)
			end
	    	end
		Draw(thisWindow)
		WindowShow(thisWindow.id, true)		
	end

	function dragmove(flags, hotspot_id)		
		local thisWindow = GetWindowFromHotspotId(hotspot_id)

		if (not dragStart) then
			dragStart = {
				x = WindowInfo(thisWindow.id, 14),
				y = WindowInfo(thisWindow.id, 15),
			}
		end		
		
		WindowPosition(thisWindow.id, 
						WindowInfo (thisWindow.id, 17) - dragStart.x, 
						WindowInfo (thisWindow.id, 18) - dragStart.y, 
						miniwin.pos_stretch_to_view, 
						miniwin.create_absolute_location)		
	end

	function dragrelease(flags, hotspot_id)		
		local thisWindow = GetWindowFromHotspotId(hotspot_id)
		
		thisWindow.left = WindowInfo(thisWindow.id, 10)
		thisWindow.top = WindowInfo(thisWindow.id, 11)
	
		dragStart = nil
	
		SaveWindow(thisWindow)		
	end
	
	function resizemove(flags, hotspot_id) 
		local thisWindow = GetWindowFromHotspotId(hotspot_id)
	
		thisWindow.width = WindowInfo(thisWindow.id, 17) - WindowInfo(thisWindow.id, 10)
		thisWindow.height = WindowInfo(thisWindow.id, 18) - WindowInfo(thisWindow.id, 11)
		
		WindowResize(thisWindow.id, thisWindow.width, thisWindow.height, ColourNameToRGB("gray"))
		WindowShow(thisWindow.id, true)		
	end -- dragmove

	function resizerelease(flags, hotspot_id)
		local thisWindow = GetWindowFromHotspotId(hotspot_id)
		
		SaveWindow(thisWindow)				
		CreateHotSpots(thisWindow)
		Draw(thisWindow)
	end -- dragrelease
	
	function mouseup(flags, hotspot_id)
		local thisWindow = GetWindowFromHotspotId(hotspot_id)
		
		if (bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0) then
			local result = WindowMenu(thisWindow.id, 
				WindowInfo(thisWindow.id, 14),
				WindowInfo(thisWindow.id, 15),
				"Bring to front|Send to back")		
		
			if (result ~= "" and IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
				if (result == "Send to back") then 
					CallPlugin(z_order_plugin, "dropMe", thisWindow.id)
				else
					CallPlugin(z_order_plugin, "boostMe", thisWindow.id)
				end
			end
		end		
	end

	function GetWindowFromHotspotId(hotspot_id)
		if string.find(hotspot_id, window.id) ~= nil then return window
		elseif string.find(hotspot_id, detailWindow.id) ~= nil then return detailWindow
		elseif string.find(hotspot_id, playerWindow.id) ~= nil then return playerWindow end

		return
	end

	function WatchLevel(name, line, wildcards)
		if watchLevel[wildcards[1]] == nil then watchLevel[wildcards[1]] = false end

		watchLevel[wildcards[1]] = not watchLevel[wildcards[1]]

		ColourTell("orange", "", "Watching levels for ", "cyan", "", wildcards[1], "orange", "", ": ")
		if watchLevel[wildcards[1]] then
			ColourNote("lime", "", "ON")
		else
			ColourNote("red", "", "OFF")
		end

		ColourNote("orange", "", "You are watching:")
		for player, status in pairs(watchLevel) do
			if status then
				ColourNote("cyan", "", "  " .. player)
			end
		end
	end

	function GagType(name, line, wildcards)
		local gType = wildcards[1]
		if gType == "me" or gType == "self" then
			GagMe()
		elseif gType == "others" then
			Gag()
		elseif gType == "dodges" then
			GagDodges()
		elseif gType == "pups" then
			GagPups()
		elseif gType == "levels" or gType == "lvls" then
			GagLevels()
		elseif gType == "deaths" then
			GagDeaths()
		elseif gType == "all" then
			GagMe()
			Gag()
			GagDodges()
			GagPups()
			GagLevels()
			GagDeaths()
		else
			ColourNote("orange", "", "\'" .. gType .. "\' is an invalid option. Available options are: me/self, others, dodges, pups, lvls, deaths and all.")
		end
	end

	function Gag()				
		if gag == "y" then 
			gag = "n"					
		else 
			gag = "y" 
		end

		SetGagTriggers()

		SetVariable("gag", gag)			
		ColourNote("orange", "", "[LDT] Tracking option for \'others\' set to: ", "cyan", "", gag)
	end

	function SetGagTriggers()
		for name, player in pairs(players) do			
			SetTriggerOption("damagedealt_" .. name, "omit_from_output", gag)
			SetTriggerOption("damagereceived_" .. name, "omit_from_output", gag)
		end
	end

	function GagDodges()				
		if gagdodges == "y" then 
			gagdodges = "n"					
		else 
			gagdodges = "y" 
		end

		SetGagDodgeTriggers()

		SetVariable("gagdodges", gagdodges)			
		ColourNote("orange", "", "[LDT] Tracking option for \'dodges\' set to: ", "cyan", "", gagdodges)
	end

	function SetGagDodgeTriggers()
		SetTriggerOption("dodgesParry", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesDodge", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesShieldBlock", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesTimeShift", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesHolyIntervention", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesCamouflage", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesMisdirect", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesHolyRift", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesBlink", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesInstinct", "omit_from_output", gagdodges)
		SetTriggerOption("dodgesLucky", "omit_from_output", gagdodges)
		SetTriggerOption("enemyDodge", "omit_from_output", gagdodges)
		SetTriggerOption("enemyParry", "omit_from_output", gagdodges)
		SetTriggerOption("enemyBlink", "omit_from_output", gagdodges)
		SetTriggerOption("enemyCamouflage", "omit_from_output", gagdodges)
		SetTriggerOption("enemyMisdirection", "omit_from_output", gagdodges)
		SetTriggerOption("enemyTimeShift", "omit_from_output", gagdodges)
		SetTriggerOption("enemyLucky", "omit_from_output", gagdodges)
		SetTriggerOption("enemyHolyRift", "omit_from_output", gagdodges)
		SetTriggerOption("enemyShieldBlock", "omit_from_output", gagdodges)
	end

	function GagMe()				
		if gagme == "y" then 
			gagme = "n"					
		else 
			gagme = "y" 
		end			

		SetGagMeTriggers()

		SetVariable("gagme", gagme)			
		ColourNote("orange", "", "[LDT] Tracking option for \'self\' set to: ", "cyan", "", gagme)
	end

	function SetGagMeTriggers()
		SetTriggerOption("mydamage_dealt", "omit_from_output", gagme)
		SetTriggerOption("mydamage_received", "omit_from_output", gagme)		
		SetTriggerOption("my_miss", "omit_from_output", gagme)
		SetTriggerOption("enemy_miss", "omit_from_output", gagme)
	end

	function GagPups()
		if gagpups == "y" then 
			gagpups = "n"					
		else 
			gagpups = "y" 
		end			

		SetGagPupsTriggers()

		SetVariable("gagpups", gagpups)			
		ColourNote("orange", "", "[LDT] Tracking option for \'pups\' set to: ", "cyan", "", gagpups)
	end

	function SetGagPupsTriggers()
		SetTriggerOption("pupInfoUnclanned", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoTwinlobe", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoWatchmen", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoChaos", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoSeekers", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoShadokil", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoEmerald", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoLight", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoDragon", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoBaal", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoHook", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoBard", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoCrusader", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoXunti", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoImperium", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoCrimson", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoRetribution", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoDruid", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoAmazon", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoPyre", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoTanelorn", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoDominion", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoMasaki", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoRhabdo", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoPerdition", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoCabal", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoLoqui", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoGaardian", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoTao", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoTouchstone", "omit_from_output", gagpups)
		SetTriggerOption("pupInfoBoot", "omit_from_output", gagpups)
	end

	function GagLevels()
		if gaglevels == "y" then 
			gaglevels = "n"					
		else 
			gaglevels = "y" 
		end			

		SetGagLevelsTriggers()

		SetVariable("gaglevels", gaglevels)
		ColourNote("orange", "", "[LDT] Tracking option for \'levels\' set to: ", "cyan", "", gaglevels)
	end

	function SetGagLevelsTriggers()
		SetTriggerOption("lvlInfoUnclanned", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoTwinlobe", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoWatchmen", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoChaos", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoSeekers", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoShadokil", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoEmerald", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoLight", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoDragon", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoBaal", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoHook", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoBard", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoCrusader", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoXunti", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoImperium", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoCrimson", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoRetribution", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoDruid", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoAmazon", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoPyre", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoTanelorn", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoDominion", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoMasaki", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoRhabdo", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoPerdition", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoCabal", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoLoqui", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoGaardian", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoTao", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoTouchstone", "omit_from_output", gaglevels)
		SetTriggerOption("lvlInfoBoot", "omit_from_output", gaglevels)
	end

	function GagDeaths()
		if gagdeaths == "y" then 
			gagdeaths = "n"					
		else 
			gagdeaths = "y" 
		end			

		SetGagDeathsTriggers()

		SetVariable("gagdeaths", gagdeaths)
		ColourNote("orange", "", "[LDT] Tracking option for \'deaths\' set to: ", "cyan", "", gagdeaths)
	end

	function SetGagDeathsTriggers()
		SetTriggerOption("deathInfoUnclanned", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoTwinlobe", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoWatchmen", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoChaos", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoSeekers", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoShadokil", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoEmerald", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoLight", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoDragon", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoBaal", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoHook", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoBard", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoCrusader", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoXunti", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoImperium", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoCrimson", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoRetribution", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoDruid", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoAmazon", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoPyre", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoTanelorn", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoDominion", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoMasaki", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoRhabdo", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoPerdition", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoCabal", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoLoqui", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoGaardian", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoTao", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoTouchstone", "omit_from_output", gagdeaths)
		SetTriggerOption("deathInfoBoot", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoBoot", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoDragon", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoTwinlobe", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoEmerald", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoWatchmen", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoLoqui", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoHook", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoRhabdo", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoXunti", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoDominion", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoDruid", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoBaal", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoCrimson", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoAmazon", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoPyre", "omit_from_output", gagdeaths)
		SetTriggerOption("suicideInfoPerdition", "omit_from_output", gagdeaths)
	end

	function Sort(name, line, wildcards)				
		newSort = -1
		if wildcards ~= nil and wildcards.type ~= nil and wildcards.type ~= '' then
			for i, mode in pairs(sortOptions) do
				if mode == wildcards.type then newSort = i end
			end
		end

		if newSort == -1 then
			NextSort()
		else
			SetSort(newSort)
		end		
	end

	function SetSort(sort)
		sortMode = sort
		SaveSort()
	end

	function NextSort()
		sortMode = (sortMode + 1) % sortModeSize
		scrollPosMain = 1
		SaveSort()
	end

	function PrevSort()
		if sortMode <= 0 then
			sortMode = sortModeSize-1
		else
			sortMode = sortMode - 1			
		end
		scrollPosMain = 1

		SaveSort()
	end

	function SaveSort()
		SetVariable("sortMode", sortMode)			
		ColourNote("orange", "", "Damage tracking sorting mode set to: ", "cyan", "", sortOptions[sortMode])
		Draw(window) --Refresh the window immediately
	end

	function CreateRoundTrigger()
		if roundDelimiter ~= "" then
			local triggerFlags = trigger_flag.Enabled + trigger_flag.KeepEvaluating + trigger_flag.RegularExpression		
			local match = "^(?:\\[(?<hits>\\d+)\\] )?(?:.* )?Your " .. roundDelimiter .. " (?:misses|decimates|devastates|rends|incinerates|lacerates|obliterates|massacres|disembowels|extirpates|eradicates|dismembers|mutilates|tickles|bruises|scratches|grazes|nicks|scars|hits|injures|wounds|mauls|maims|mangles|mars|LACERATES|DECIMATES|DEVASTATES|ERADICATES|OBLITERATES|EXTIRPATES|INCINERATES|MUTILATES|DISEMBOWELS|MASSACRES|DISMEMBERS|RENDS|blasts|demolishes|shreds|destroys|pulverizes|vaporizes|atomizes|asphyxiates|ravages|fissures|liquidates|evaporates|sunders|tears into|wastes|cremates|annihilates|implodes|exterminates|shatters|slaughters|ruptures|nukes|glaciates|meteorites|supernovas|damages|- BLASTS -|-= DEMOLISHES =-|\\*\\* SHREDS \\*\\*|\\*\\*\\*\\* DESTROYS \\*\\*\\*\\*|\\*\\*\\*\\*\\* PULVERIZES \\*\\*\\*\\*\\*|-=- VAPORIZES -=-|\\<-==-\\> ATOMIZES \\<-==-\\>|\\<-:-\\> ASPHYXIATES \\<-:-\\>|\\<-\\*-\\> RAVAGES \\<-\\*-\\>|\\<\\>\\*\\<\\> FISSURES \\<\\>\\*\\<\\>|\\<\\*\\>\\<\\*\\> LIQUIDATES \\<\\*\\>\\<\\*\\>|\\<\\*\\>\\<\\*\\>\\<\\*\\> EVAPORATES \\<\\*\\>\\<\\*\\>\\<\\*\\>|\\<-=-\\> SUNDERS \\<-=-\\>|\\<=-=\\>\\<=-=\\> TEARS INTO \\<=-=\\>\\<=-=\\>|\\<-\\>\\*\\<=\\> WASTES \\<=\\>\\*\\<-\\>|\\<-\\+-\\>\\<-\\*-\\> CREMATES \\<-\\*-\\>\\<-\\+-\\>|\\<\\*\\>\\<\\*\\>\\<\\*\\>\\<\\*\\> ANNIHILATES \\<\\*\\>\\<\\*\\>\\<\\*\\>\\<\\*\\>|\\<--\\*--\\>\\<--\\*--\\> IMPLODES \\<--\\*--\\>\\<--\\*--\\>|\\<-\\>\\<-=-\\>\\<-\\> EXTERMINATES \\<-\\>\\<-=-\\>\\<-\\>|\\<-==-\\>\\<-==-\\> SHATTERS \\<-==-\\>\\<-==-\\>|\\<\\*\\>\\<-:-\\>\\<\\*\\> SLAUGHTERS \\<\\*\\>\\<-:-\\>\\<\\*\\>|\\<-\\*-\\>\\<-\\>\\<-\\*-\\> RUPTURES \\<-\\*-\\>\\<-\\>\\<-\\*-\\>|\\<-\\*-\\>\\<\\*\\>\\<-\\*-\\> NUKES \\<-\\*-\\>\\<\\*\\>\\<-\\*-\\>|-\\<\\[=-\\+-=\\]\\<:::\\<\\>:::\\> GLACIATES \\<:::\\<\\>:::\\>\\[=-\\+-=\\]\\>-|\\<-=-\\>\\<-:-\\*-:-\\>\\<\\*--\\*\\> METEORITES \\<\\*--\\*\\>\\<-:-\\*-:-\\>\\<-=-\\>|\\<-:-\\>\\<-:-\\*-:-\\>\\<-\\*-\\> SUPERNOVAS \\<-\\*-\\>\\<-:-\\*-:-\\>\\<-:-\\>|does UNSPEAKABLE things to|does UNTHINKABLE things to|does UNIMAGINABLE things to|does UNBELIEVABLE things to) (?:.+). \\[(?<damage>\\d+)\\]$"
			
			AddTriggerEx("round_delimiter", match, "", triggerFlags,
					custom_colour.NoChange, 0, "", "Round", sendto.script, 100)
		end
	end

	function SetRoundDelimiter(name, line, wildcards)
		roundDelimiter = wildcards[1]
		SetVariable("roundDelimiter", roundDelimiter)
		ColourNote("orange", "", "Round delimiter set to: ", "cyan", "", roundDelimiter)
		CreateRoundTrigger()
	end

	function Round()
		if (os.clock() - lastRoundReport) > .25 then
			if reportRounds == "y" then
				ReportRound(roundDamageDealt, roundDamageReceived, roundHealed, os.clock() - roomStart)
			end
			
			AddRoundToRoom()

			lastRoundReport = os.clock()					
		end

		firstRoundOfCombat = false
	end		

	function AddRoundToRoom()
		roomDamageDealt = roomDamageDealt + roundDamageDealt
		roomDamageReceived = roomDamageReceived + roundDamageReceived
		roomHealed = roomHealed + roundHealed

		roundDamageDealt = 0
		roundDamageReceived = 0
		roundHealed = 0
	end

	function ReportRoundsToggle(name, line, wildcards)
		reportRounds = wildcards[1]
		SetVariable("reportRounds", reportRounds)			
		ColourNote("orange", "", "Reporting rounds: ", "cyan", "", reportRounds)
	end

	function ReportRound(dealt, received, healed, time)		
		ColourNote("red", "", "[ ",			
			"lime", "", commas(dealt),
			"dimgray", "", " | ",
			"red", "", commas(received),
			"dimgray", "", " | ",
			"yellow", "", commas(healed),			
			"dimgray", "", " | ",
			"white", "", string.format("%.2f", time),
			"red", "", " ]")		
	end

	function RoomStart()
		firstRoundOfCombat = true
		roomStart = os.clock()
		lastRoundReport = os.clock()
		roomStartHP = playerHP
	end

	function RoomEnd()			
		local vamp = roomDamageReceived - ((roomStartHP - playerHP) + roomHealed)

		table.insert(roomReports, { dealt = roomDamageDealt, received = roomDamageReceived, healed = roomHealed, vamp = vamp, time = os.clock() - roomStart })

		if reportRooms == "y" then
			ReportRoom(roomDamageDealt, roomDamageReceived, roomHealed, vamp, os.clock() - roomStart)
		end

		roomDamageDealt = 0
		roomDamageReceived = 0
		roomHealed = 0	
	end

	function ClearRooms()
		roomReports = {}
		ColourNote("orange", "", "Reporting rooms: ", "cyan", "", "cleared")
	end

	function ReportRoomsToggle(name, line, wildcards)
		reportRooms = wildcards[1]
		SetVariable("reportRooms", reportRooms)			
		ColourNote("orange", "", "Reporting rooms: ", "cyan", "", reportRooms)
	end

	function ReportRooms()
		for i, info in ipairs(roomReports) do
			ReportRoom(info.dealt, info.received, info.healed, info.vamp, info.time)
		end
	end

	function ReportDodges()
		local tempStr = "Your dodge stats: "
		for key, value in spairs(players["You"].dodges) do
			tempStr = tempStr .. key .. ": " .. value.count .. " "
		end
		print(tempStr)

		local tempStr = "Enemy dodge stats: "
		for key, value in spairs(players["You"].enemydodges) do
			tempStr = tempStr .. key .. ": " .. value.count .. " "
		end
		print(tempStr)
	end

	function ReportRoom(dealt, received, healed, vamp, time)
		ColourNote("red", "", "[ ",			
			"lime", "", commas(dealt),
			"dimgray", "", " | ",
			"red", "", commas(received),
			"dimgray", "", " | ",
			"yellow", "", commas(healed),	
			"dimgray", "", " | ",
			"dodgeblue", "", commas(vamp),	
			"dimgray", "", " | ",
			"white", "", string.format("%.2f", time),		
			"red", "", " ]")
	end

	function Filter(name, line, wildcards)
		if type(tonumber(wildcards[1])) == "number" then
			if tonumber(wildcards[1]) < 0 or tonumber(wildcards[1]) > 100 then
				ColourNote("orange", "", "Value supplied must be between 0 and 100.")
				return
			end
			SetVariable("filterAmount", math.floor(tonumber(wildcards[1])))
			filterAmount = math.floor(tonumber(wildcards[1]))
			if tonumber(filterAmount) == 0 then
				ColourNote("orange", "", "You will no longer filter any attacks.")
			else
				ColourNote("orange", "", "You will no longer see attacks that fall below " .. math.floor(tonumber(wildcards[1])) .. "% of damage dealt.")
			end
			if detailWindow.show == true then
				Draw(detailWindow) --Refresh the window
			end
		else
			ColourNote("orange", "", "Value supplied must be numerical.")
		end
	end

	function PupFilter(name, line, wildcards)
		if type(tonumber(wildcards[1])) == "number" then
			if tonumber(wildcards[1]) < 0 or tonumber(wildcards[1]) > 100 then
				ColourNote("orange", "", "Value supplied must be between 0 and 100.")
				return
			end
			SetVariable("pupFilterAmount", math.floor(tonumber(wildcards[1])))
			pupFilterAmount = math.floor(tonumber(wildcards[1]))
			if tonumber(pupFilterAmount) == 0 then
				ColourNote("orange", "", "You will no longer filter any pups.")
			else
				ColourNote("orange", "", "You will no longer see pups that fall below " .. math.floor(tonumber(wildcards[1])) .. "s average.")
			end
			if detailWindow.show == true then
				Draw(detailWindow) --Refresh the window
			end
		else
			ColourNote("orange", "", "Value supplied must be numerical.")
		end
	end

	function PupThreshold(name, line, wildcards)
		if type(tonumber(wildcards[1])) == "number" then
			if tonumber(wildcards[1]) < 0 or tonumber(wildcards[1]) > 10000 then
				ColourNote("orange", "", "Value supplied must be between 0 and 10000.")
				return
			end
			SetVariable("pupThreshold", math.floor(tonumber(wildcards[1])))
			pupThreshold = math.floor(tonumber(wildcards[1]))
			if tonumber(pupThreshold) == 0 then
				ColourNote("orange", "", "You will no longer filter long pup times.")
			else
				ColourNote("orange", "", "You will no longer record pups that take longer than " .. math.floor(tonumber(wildcards[1])) .. " seconds.")
			end
			if detailWindow.show == true then
				Draw(detailWindow) --Refresh the window
			end
		else
			ColourNote("orange", "", "Value supplied must be numerical.")
		end
	end
	
	function Throttle(hame, line, wildcards)
		throttle = wildcards[1]
		SetVariable("throttle", throttle)			
		ColourNote("orange", "", "Throttle minwin redraws: ", "cyan", "", throttle)
	end

	function CreateDamageTrigger(player)				
		local triggerFlags = trigger_flag.Enabled + trigger_flag.KeepEvaluating + trigger_flag.RegularExpression
		if gag == "y" then triggerFlags = triggerFlags + trigger_flag.OmitFromOutput end

		local match = "^(?<crit>\\*)?(?:\\[(?<hits>\\d+)\\] )?(?:.* )?(?<player>" .. player .. ")'s? (?<attack>[\\w\\s-]+) (?:decimates|devastates|rends|incinerates|lacerates|obliterates|massacres|disembowels|extirpates|eradicates|dismembers|mutilates|tickles|bruises|scratches|grazes|nicks|scars|hits|injures|wounds|mauls|maims|mangles|mars|LACERATES|DECIMATES|DEVASTATES|ERADICATES|OBLITERATES|EXTIRPATES|INCINERATES|MUTILATES|DISEMBOWELS|MASSACRES|DISMEMBERS|RENDS|blasts|demolishes|shreds|destroys|pulverizes|vaporizes|atomizes|asphyxiates|ravages|fissures|liquidates|evaporates|sunders|tears into|wastes|cremates|annihilates|implodes|exterminates|shatters|slaughters|ruptures|nukes|glaciates|meteorites|supernovas|damages|- BLASTS -|-= DEMOLISHES =-|\\*\\* SHREDS \\*\\*|\\*\\*\\*\\* DESTROYS \\*\\*\\*\\*|\\*\\*\\*\\*\\* PULVERIZES \\*\\*\\*\\*\\*|-=- VAPORIZES -=-|\\<-==-\\> ATOMIZES \\<-==-\\>|\\<-:-\\> ASPHYXIATES \\<-:-\\>|\\<-\\*-\\> RAVAGES \\<-\\*-\\>|\\<\\>\\*\\<\\> FISSURES \\<\\>\\*\\<\\>|\\<\\*\\>\\<\\*\\> LIQUIDATES \\<\\*\\>\\<\\*\\>|\\<\\*\\>\\<\\*\\>\\<\\*\\> EVAPORATES \\<\\*\\>\\<\\*\\>\\<\\*\\>|\\<-=-\\> SUNDERS \\<-=-\\>|\\<=-=\\>\\<=-=\\> TEARS INTO \\<=-=\\>\\<=-=\\>|\\<-\\>\\*\\<=\\> WASTES \\<=\\>\\*\\<-\\>|\\<-\\+-\\>\\<-\\*-\\> CREMATES \\<-\\*-\\>\\<-\\+-\\>|\\<\\*\\>\\<\\*\\>\\<\\*\\>\\<\\*\\> ANNIHILATES \\<\\*\\>\\<\\*\\>\\<\\*\\>\\<\\*\\>|\\<--\\*--\\>\\<--\\*--\\> IMPLODES \\<--\\*--\\>\\<--\\*--\\>|\\<-\\>\\<-=-\\>\\<-\\> EXTERMINATES \\<-\\>\\<-=-\\>\\<-\\>|\\<-==-\\>\\<-==-\\> SHATTERS \\<-==-\\>\\<-==-\\>|\\<\\*\\>\\<-:-\\>\\<\\*\\> SLAUGHTERS \\<\\*\\>\\<-:-\\>\\<\\*\\>|\\<-\\*-\\>\\<-\\>\\<-\\*-\\> RUPTURES \\<-\\*-\\>\\<-\\>\\<-\\*-\\>|\\<-\\*-\\>\\<\\*\\>\\<-\\*-\\> NUKES \\<-\\*-\\>\\<\\*\\>\\<-\\*-\\>|-\\<\\[=-\\+-=\\]\\<:::\\<\\>:::\\> GLACIATES \\<:::\\<\\>:::\\>\\[=-\\+-=\\]\\>-|\\<-=-\\>\\<-:-\\*-:-\\>\\<\\*--\\*\\> METEORITES \\<\\*--\\*\\>\\<-:-\\*-:-\\>\\<-=-\\>|\\<-:-\\>\\<-:-\\*-:-\\>\\<-\\*-\\> SUPERNOVAS \\<-\\*-\\>\\<-:-\\*-:-\\>\\<-:-\\>|does UNSPEAKABLE things to|does UNTHINKABLE things to|does UNIMAGINABLE things to|does UNBELIEVABLE things to) (?:.+). \\[(?<damage>\\d+)\\]\\*?$"
		DeleteTrigger("damagedealt_" .. player)
		AddTriggerEx("damagedealt_" .. player, match, "", triggerFlags,
				custom_colour.NoChange, 0, "", "DamageDealt", sendto.script, 100)

		match = "^(?<crit>\\*)?(?:\\[(?<hits>\\d+)\\] )?(?:.* )?(?:.*)'s? (?<attack>[\\w\\s-]+) (?:decimates|devastates|rends|incinerates|lacerates|obliterates|massacres|disembowels|extirpates|eradicates|dismembers|mutilates|tickles|bruises|scratches|grazes|nicks|scars|hits|injures|wounds|mauls|maims|mangles|mars|LACERATES|DECIMATES|DEVASTATES|ERADICATES|OBLITERATES|EXTIRPATES|INCINERATES|MUTILATES|DISEMBOWELS|MASSACRES|DISMEMBERS|RENDS|blasts|demolishes|shreds|destroys|pulverizes|vaporizes|atomizes|asphyxiates|ravages|fissures|liquidates|evaporates|sunders|tears into|wastes|cremates|annihilates|implodes|exterminates|shatters|slaughters|ruptures|nukes|glaciates|meteorites|supernovas|damages|- BLASTS -|-= DEMOLISHES =-|\\*\\* SHREDS \\*\\*|\\*\\*\\*\\* DESTROYS \\*\\*\\*\\*|\\*\\*\\*\\*\\* PULVERIZES \\*\\*\\*\\*\\*|-=- VAPORIZES -=-|\\<-==-\\> ATOMIZES \\<-==-\\>|\\<-:-\\> ASPHYXIATES \\<-:-\\>|\\<-\\*-\\> RAVAGES \\<-\\*-\\>|\\<\\>\\*\\<\\> FISSURES \\<\\>\\*\\<\\>|\\<\\*\\>\\<\\*\\> LIQUIDATES \\<\\*\\>\\<\\*\\>|\\<\\*\\>\\<\\*\\>\\<\\*\\> EVAPORATES \\<\\*\\>\\<\\*\\>\\<\\*\\>|\\<-=-\\> SUNDERS \\<-=-\\>|\\<=-=\\>\\<=-=\\> TEARS INTO \\<=-=\\>\\<=-=\\>|\\<-\\>\\*\\<=\\> WASTES \\<=\\>\\*\\<-\\>|\\<-\\+-\\>\\<-\\*-\\> CREMATES \\<-\\*-\\>\\<-\\+-\\>|\\<\\*\\>\\<\\*\\>\\<\\*\\>\\<\\*\\> ANNIHILATES \\<\\*\\>\\<\\*\\>\\<\\*\\>\\<\\*\\>|\\<--\\*--\\>\\<--\\*--\\> IMPLODES \\<--\\*--\\>\\<--\\*--\\>|\\<-\\>\\<-=-\\>\\<-\\> EXTERMINATES \\<-\\>\\<-=-\\>\\<-\\>|\\<-==-\\>\\<-==-\\> SHATTERS \\<-==-\\>\\<-==-\\>|\\<\\*\\>\\<-:-\\>\\<\\*\\> SLAUGHTERS \\<\\*\\>\\<-:-\\>\\<\\*\\>|\\<-\\*-\\>\\<-\\>\\<-\\*-\\> RUPTURES \\<-\\*-\\>\\<-\\>\\<-\\*-\\>|\\<-\\*-\\>\\<\\*\\>\\<-\\*-\\> NUKES \\<-\\*-\\>\\<\\*\\>\\<-\\*-\\>|-\\<\\[=-\\+-=\\]\\<:::\\<\\>:::\\> GLACIATES \\<:::\\<\\>:::\\>\\[=-\\+-=\\]\\>-|\\<-=-\\>\\<-:-\\*-:-\\>\\<\\*--\\*\\> METEORITES \\<\\*--\\*\\>\\<-:-\\*-:-\\>\\<-=-\\>|\\<-:-\\>\\<-:-\\*-:-\\>\\<-\\*-\\> SUPERNOVAS \\<-\\*-\\>\\<-:-\\*-:-\\>\\<-:-\\>|does UNSPEAKABLE things to|does UNTHINKABLE things to|does UNIMAGINABLE things to|does UNBELIEVABLE things to) (?:.* )?(?<player>" .. player .. "). \\[(?<damage>\\d+)\\]\\*?$"		
		DeleteTrigger("damagereceived_" .. player)
		AddTriggerEx("damagereceived_" .. player, match, "", triggerFlags,
				custom_colour.NoChange, 0, "", "DamageReceived", sendto.script, 100)
	end

	function DeleteDamageTrigger(player)
		DeleteTrigger("damagedealt_" .. player)
		DeleteTrigger("damagereceived_" .. player)
	end

	function InitializePlayer(name)				
		players[name] = Player:New(name, randomColour())	
	end

	function Healed(name, line, wildcards)		
		roundHealed = roundHealed + tonumber(wildcards[1])
	end

	function AddExp(name, line, wildcards)
		local luastmt = "tempAmount = " .. wildcards.amount
		assert (loadstring (luastmt or "")) ()

		if tonumber(goalData["exp"].goal) > 0 then
			goalData["exp"].current = goalData["exp"].current + tonumber(tempAmount)
		end

		if currentArea == nil or currentArea == "None" then return end --Don't have an area to add xp to, exit out
		if expTable.areas[currentArea] == nil then
			expTable.areas[currentArea] = {}
			expTable.areas[currentArea].normal = 0
			expTable.areas[currentArea].mobs = 0
			expTable.areas[currentArea].double = 0
			expTable.areas[currentArea].rare = 0
			expTable.areas[currentArea].daily = 0
			expTable.areas[currentArea].total = 0
			expTable.areas[currentArea].time = 0
			expTable.areas[currentArea].last = os.clock()
			expTable.areas[currentArea].colour = randomColour()
		end

		local now = os.clock()
		local timeSinceLast = now - expTable.areas[currentArea].last
		expTable.areas[currentArea].last = now

		if timeSinceLast < 60 then
			expTable.areas[currentArea].time = expTable.areas[currentArea].time + timeSinceLast
			expTable.time = expTable.time + timeSinceLast


			if name == "expNormal" then
				expTable.areas[currentArea].normal = expTable.areas[currentArea].normal + tonumber(tempAmount)
				expTable.areas[currentArea].mobs = expTable.areas[currentArea].mobs + 1
			elseif name == "expDouble" then
				expTable.areas[currentArea].double = expTable.areas[currentArea].double + tonumber(tempAmount)
			elseif name == "expRare" then
				expTable.areas[currentArea].rare = expTable.areas[currentArea].rare + tonumber(tempAmount)
			elseif name == "expDaily" then
				expTable.areas[currentArea].daily = expTable.areas[currentArea].daily + tonumber(tempAmount)
			end

			expTable.areas[currentArea].total = expTable.areas[currentArea].total + tonumber(tempAmount)
			expTable.total = expTable.total + tonumber(tempAmount)
		end
		if window.show then
			QueueDrawMain()
		end
		if detailWindow.show then
			QueueDrawDetail()
		end
		--if playerWindow.show then
		--	QueueDrawPlayer()
		--end		
	end

	function AddInfoPup(name, line, wildcards)
		if tonumber(goalData["pup"].goal) > 0 then
			if wildcards.name == me then
				goalData["pup"].current = goalData["pup"].current + 1
			end
		end
		
		local clanName = string.gsub(name, "pupInfo", "")
		local now = os.clock()

		if clanTable.pupInfo[clanName] == nil then --Populate base table if it doesn't exist
			clanTable.pupInfo[clanName] = { puppers = {}, last = os.clock(), lastPupper = "", total = 0, time = 0, colour = randomColour() }
		end

		if clanTable.pupInfo[clanName].puppers[wildcards.name] == nil then --Populate individual pupper info since it doesn't exist
			clanTable.pupInfo[clanName].puppers[wildcards.name] = { last = os.clock(), total = 0, time = 0, colour = randomColour() }
		end

		if tonumber(pupThreshold) == 0 or (os.clock() - clanTable.pupInfo[clanName].puppers[wildcards.name].last) <= tonumber(pupThreshold) then
			clanTable.timePup = clanTable.timePup + (os.clock() - clanTable.lastPup)
			clanTable.lastPup = os.clock()
			clanTable.totalPup = clanTable.totalPup + 1
			clanTable.pupInfo[clanName].lastPupper = wildcards.name
			clanTable.pupInfo[clanName].total = clanTable.pupInfo[clanName].total + 1
			clanTable.pupInfo[clanName].time = clanTable.pupInfo[clanName].time + (os.clock() - clanTable.pupInfo[clanName].last)
			clanTable.pupInfo[clanName].last = os.clock()
			clanTable.pupInfo[clanName].puppers[wildcards.name].time = clanTable.pupInfo[clanName].puppers[wildcards.name].time + (os.clock() - clanTable.pupInfo[clanName].puppers[wildcards.name].last)
			clanTable.pupInfo[clanName].puppers[wildcards.name].last = os.clock()
			clanTable.pupInfo[clanName].puppers[wildcards.name].total = clanTable.pupInfo[clanName].puppers[wildcards.name].total + 1
		else --Ignore first entry that took too long
			clanTable.pupInfo[clanName].puppers[wildcards.name].last = os.clock()
		end

		if window.show then
			QueueDrawMain()
		end
		if detailWindow.show then
			QueueDrawDetail()
		end
		SetTriggerOption("pupInfoBlankLine", "enabled", "y")
	end

	function AddInfoLevel(name, line, wildcards)
		if watchLevel[wildcards.name] then
			PlaySound (0, "C:/Windows/Media/Windows Notify.wav", false, 0, 0)
			CallPlugin("b555825a4a5700c35fa80781","storeFromOutside", clrVal .. wildcards.name .. clrLbl .. " has leveled")
		end
		
		if tonumber(goalData["lvl"].goal) > 0 then
			if wildcards.name == me then
				goalData["lvl"].current = goalData["lvl"].current + 1
			end
		end		

		local clanName = string.gsub(name, "lvlInfo", "")
		local now = os.clock()

		if clanTable.lvlInfo[clanName] == nil then --Populate base table if it doesn't exist
			clanTable.lvlInfo[clanName] = { levelers = {}, last = os.clock(), lastLeveler = "", total = 0, time = 0, colour = randomColour() }
		end

		if clanTable.lvlInfo[clanName].levelers[wildcards.name] == nil then --Populate individual leveler info since it doesn't exist
			clanTable.lvlInfo[clanName].levelers[wildcards.name] = { last = os.clock(), total = 0, time = 0, colour = randomColour() }
		end

		clanTable.timeLvl = clanTable.timeLvl + (os.clock() - clanTable.lastLvl)
		clanTable.lastLvl = os.clock()
		clanTable.totalLvl = clanTable.totalLvl + 1
		clanTable.lvlInfo[clanName].lastLeveler = wildcards.name
		clanTable.lvlInfo[clanName].total = clanTable.lvlInfo[clanName].total + 1
		clanTable.lvlInfo[clanName].time = clanTable.lvlInfo[clanName].time + (os.clock() - clanTable.lvlInfo[clanName].last)
		clanTable.lvlInfo[clanName].last = os.clock()
		clanTable.lvlInfo[clanName].levelers[wildcards.name].time = clanTable.lvlInfo[clanName].levelers[wildcards.name].time + (os.clock() - clanTable.lvlInfo[clanName].levelers[wildcards.name].last)
		clanTable.lvlInfo[clanName].levelers[wildcards.name].last = os.clock()
		clanTable.lvlInfo[clanName].levelers[wildcards.name].total = clanTable.lvlInfo[clanName].levelers[wildcards.name].total + 1

		if window.show then
			QueueDrawMain()
		end
		if detailWindow.show then
			QueueDrawDetail()
		end
		SetTriggerOption("pupInfoBlankLine", "enabled", "y")
	end

	function AddInfoDeath(name, line, wildcards)
		local clanName = string.lower(string.gsub(name, "deathInfo", ""))
		local rawPlayerName = string.gsub(wildcards.name, "HARDCORE ", "")
		local playerName = string.lower(rawPlayerName)
		local enemyName = "Unknown"
		local now = os.clock()

		if string.find(clanName, "suicideinfo") ~= nil then
			clanName = string.gsub(clanName, "suicideinfo", "")
			enemyName = "Suicide"
		else
			enemyName = wildcards.enemy
		end

		if enemyName == rawPlayerName then
			enemyName = "Suicide"
		end

		if clanTable.deathInfo[clanName] == nil then --Populate base table if it doesn't exist
			clanTable.deathInfo[clanName] = { players = {}, last = os.clock(), lastPlayer = "", total = 0, time = 0, colour = randomColour() }
		end

		if clanTable.deathInfo[clanName].players[playerName] == nil then --Populate individual player info since it doesn't exist
			clanTable.deathInfo[clanName].players[playerName] = { killers = {}, name = rawPlayerName, last = os.clock(), total = 0, time = 0, colour = randomColour() }
		end

		if clanTable.deathInfo[clanName].players[playerName].killers[enemyName] == nil then --Populate individual player info since it doesn't exist
			clanTable.deathInfo[clanName].players[playerName].killers[enemyName] = { last = os.clock(), total = 0 }
		end

		clanTable.timeDeath = clanTable.timeDeath + (os.clock() - clanTable.lastDeath)
		clanTable.lastDeath = os.clock()
		clanTable.totalDeath = clanTable.totalDeath + 1
		clanTable.deathInfo[clanName].lastPlayer = playerName
		clanTable.deathInfo[clanName].total = clanTable.deathInfo[clanName].total + 1
		clanTable.deathInfo[clanName].time = clanTable.deathInfo[clanName].time + (os.clock() - clanTable.deathInfo[clanName].last)
		clanTable.deathInfo[clanName].last = os.clock()
		clanTable.deathInfo[clanName].players[playerName].time = clanTable.deathInfo[clanName].players[playerName].time + (os.clock() - clanTable.deathInfo[clanName].players[playerName].last)
		clanTable.deathInfo[clanName].players[playerName].last = os.clock()
		clanTable.deathInfo[clanName].players[playerName].total = clanTable.deathInfo[clanName].players[playerName].total + 1
		clanTable.deathInfo[clanName].players[playerName].killers[enemyName].last = os.clock()
		clanTable.deathInfo[clanName].players[playerName].killers[enemyName].total = clanTable.deathInfo[clanName].players[playerName].killers[enemyName].total + 1

		if window.show then
			QueueDrawMain()
		end
		if detailWindow.show then
			QueueDrawDetail()
		end
		SetTriggerOption("pupInfoBlankLine", "enabled", "y")
	end

	function DisplayUptime(name, line, wildcards)
		ColourNote("orange", "", "--------------------------------------------------------------")
		ColourNote("orange", "", "You last reset damage data         : ", "cyan", "", GetTimeString((os.clock() - uptimes.dmg)))
		ColourNote("orange", "", "You last reset damage received data: ", "cyan", "", GetTimeString((os.clock() - uptimes.dmgrec)))
		ColourNote("orange", "", "You last reset dodge data          : ", "cyan", "", GetTimeString((os.clock() - uptimes.dodges)))
		ColourNote("orange", "", "You last reset exp data            : ", "cyan", "", GetTimeString((os.clock() - uptimes.exp)))
		ColourNote("orange", "", "You last reset gold data           : ", "cyan", "", GetTimeString((os.clock() - uptimes.gold)))
		ColourNote("orange", "", "You last reset pup data            : ", "cyan", "", GetTimeString((os.clock() - uptimes.pups)))
		ColourNote("orange", "", "You last reset level data          : ", "cyan", "", GetTimeString((os.clock() - uptimes.lvls)))
		ColourNote("orange", "", "You last reset death data          : ", "cyan", "", GetTimeString((os.clock() - uptimes.deaths)))
		ColourNote("orange", "", "You last reset goal data           : ", "cyan", "", GetTimeString((os.clock() - uptimes.goals)))
		ColourNote("orange", "", "--------------------------------------------------------------")
	end

	function DisplayDeaths(name, line, wildcards)
		local clanName = string.lower(wildcards[1])
		local playerName = string.lower(wildcards[2])

		if clanTable.deathInfo[clanName] == nil then
			ColourNote("orange", "", "The clan " .. clanName .. " can't be found.")
			return
		end

		if clanTable.deathInfo[clanName].players[playerName] == nil then
			ColourNote("orange", "", "The player " .. playerName .. " can't be found.")
			return
		end
		ColourNote("orange", "", "Death information for: ", "cyan", "", tostring(clanTable.deathInfo[clanName].players[playerName].name))
		ColourNote("orange", "", "Times killed: ", "cyan", "", tostring(clanTable.deathInfo[clanName].players[playerName].total), "orange", "", " Last killed: ", "cyan", "", GetTimeString((os.clock() - clanTable.deathInfo[clanName].players[playerName].last)))
		ColourNote("orange", "", "Killers:")
		ColourNote("orange", "", "--------------------------------------------------------------------")
		for key, value in spairs(clanTable.deathInfo[clanName].players[playerName].killers, function(t,a,b) return t[a].last > t[b].last end) do
			if value.total > 1 then
				ColourNote("orange", "", "Killer: ", "cyan", "", key, "orange", "", " Last killed: ", "cyan", "", GetTimeString((os.clock() - value.last)), "orange", "", " Times killed: ", "cyan", "", value.total)
			else
				ColourNote("orange", "", "Killer: ", "cyan", "", key, "orange", "", " Last killed: ", "cyan", "", GetTimeString((os.clock() - value.last)))
			end
		end
		ColourNote("orange", "", "--------------------------------------------------------------------")
	end

	function AddGold(name, line, wildcards)
		local cleanedAmount = string.gsub(wildcards.amount, ",", "")

		if tonumber(goalData["gold"].goal) > 0 then
			goalData["gold"].current = goalData["gold"].current + tonumber(cleanedAmount)
		end

		if currentArea == nil or currentArea == "None" then return end --Don't have an area to add gold to, exit out
		if goldTable.areas[currentArea] == nil then
			goldTable.areas[currentArea] = { mob = 0, mobCount = 0, crumble = 0, shared = 0, sac = 0, sell = 0, fence = 0, haggle = 0, cp = 0, gq = 0, db = 0, 
							 dbkill = 0, quest = 0, tax = 0, total = 0, time = 0, last = os.clock(), colour = randomColour() }
		end

		local now = os.clock()
		local timeSinceLast = now - goldTable.areas[currentArea].last
		goldTable.areas[currentArea].last = now

		if timeSinceLast < 60 then
			goldTable.areas[currentArea].time = goldTable.areas[currentArea].time + timeSinceLast
			goldTable.time = goldTable.time + timeSinceLast

			if name == "goldMob" then
				goldTable.areas[currentArea].mob = goldTable.areas[currentArea].mob + tonumber(cleanedAmount)
				goldTable.areas[currentArea].mobCount = goldTable.areas[currentArea].mobCount + 1
			elseif name == "goldCrumble" then
				goldTable.areas[currentArea].crumble = goldTable.areas[currentArea].crumble + tonumber(cleanedAmount)
			elseif name == "goldShared" then
				goldTable.areas[currentArea].mob = goldTable.areas[currentArea].mob + tonumber(cleanedAmount)
			elseif name == "goldSharing" then
				local tempTotal = string.gsub(wildcards.total, ",", "") 
				goldTable.areas[currentArea].shared = goldTable.areas[currentArea].shared + (tempTotal - tonumber(cleanedAmount))
				goldTable.areas[currentArea].total = goldTable.areas[currentArea].total - tonumber(tempTotal)
				goldTable.total = goldTable.total - tonumber(tempTotal)
				if tonumber(goalData["gold"].goal) > 0 then
					goalData["gold"].current = goalData["gold"].current - tonumber(tempTotal)
				end
			elseif name == "goldSac" then
				goldTable.areas[currentArea].sac = goldTable.areas[currentArea].sac + tonumber(cleanedAmount)
			elseif name == "goldSell" then
				goldTable.areas[currentArea].sell = goldTable.areas[currentArea].sell + tonumber(cleanedAmount)
			elseif name == "goldFence" then
				goldTable.areas[currentArea].fence = goldTable.areas[currentArea].fence + tonumber(cleanedAmount)
				goldTable.areas[currentArea].sell = goldTable.areas[currentArea].sell - tonumber(cleanedAmount)
				goldTable.areas[currentArea].total = goldTable.areas[currentArea].total - tonumber(cleanedAmount)
			elseif name == "goldHaggle" then
				goldTable.areas[currentArea].haggle = goldTable.areas[currentArea].haggle + tonumber(cleanedAmount)
				goldTable.areas[currentArea].sell = goldTable.areas[currentArea].sell - tonumber(cleanedAmount)
				goldTable.areas[currentArea].total = goldTable.areas[currentArea].total - tonumber(cleanedAmount)
			elseif name == "goldCP" then
				goldTable.areas[currentArea].cp = goldTable.areas[currentArea].cp + tonumber(cleanedAmount)
			elseif name == "goldGQ" then
				goldTable.areas[currentArea].gq = goldTable.areas[currentArea].gq + tonumber(cleanedAmount)
			elseif name == "goldDB" then
				goldTable.areas[currentArea].db = goldTable.areas[currentArea].db + tonumber(cleanedAmount)
			elseif name == "goldDailyKill" then
				goldTable.areas[currentArea].dbkill = goldTable.areas[currentArea].dbkill + tonumber(cleanedAmount)
				goldTable.areas[currentArea].mob = goldTable.areas[currentArea].mob - tonumber(cleanedAmount)
				goldTable.areas[currentArea].total = goldTable.areas[currentArea].total - tonumber(cleanedAmount)
			elseif name == "goldQuest" then
				goldTable.areas[currentArea].quest = goldTable.areas[currentArea].quest + tonumber(cleanedAmount)
			elseif name == "goldTax" then
				goldTable.areas[currentArea].tax = goldTable.areas[currentArea].tax + tonumber(cleanedAmount)
				goldTable.areas[currentArea].total = goldTable.areas[currentArea].total - tonumber(cleanedAmount)
			end

			goldTable.areas[currentArea].total = goldTable.areas[currentArea].total + tonumber(cleanedAmount)
			goldTable.total = goldTable.total + tonumber(cleanedAmount)
		end
		if window.show then
			QueueDrawMain()
		end
		if detailWindow.show then
			QueueDrawDetail()
		end
		--if playerWindow.show then
		--	QueueDrawPlayer()
		--end
	end

	function Dodged(dodgeType)
		players["You"]:Dodge(dodgeType)
	end

	function EnemyDodged(dodgeType)
		players["You"]:EnemyDodge(dodgeType)

		if window.show then
			QueueDrawMain()
		end
		if detailWindow.show then
			QueueDrawDetail()
		end
		--if playerWindow.show then
		--	QueueDrawPlayer()
		--end
	end

	function DamageReceived(name, line, wildcards)
		if wildcards.hits == nil or wildcards.hits == "" then wildcards.hits = "1" end		
		if wildcards.player == "you" then wildcards.player = "You" end
		if wildcards.attack == nil or wildcards.attack == "" then wildcards.attack = "mprog" end
		if wildcards.crit == nil or wildcards.crit == "" then
			wildcards.crit = "0"
		else
			wildcards.crit = "1"
		end

		if tonumber(wildcards.damage) == 0 then
			return --Ignore 0 damage hits.
		end	

		-- round damage received
		if wildcards.player == "You" then roundDamageReceived = roundDamageReceived + tonumber(wildcards.damage) end

		--players[wildcards.player]:AttackReceived(wildcards.attack, tonumber(wildcards.damage), tonumber(wildcards.hits))
		players[wildcards.player]:AttackReceived(wildcards.attack, tonumber(wildcards.damage), tonumber(wildcards.hits), tonumber(wildcards.crit))
	end

	function DamageDealt(name, line, wildcards)
		-- initialize hits cause Castiel breaks stuff
		if wildcards.hits == nil or wildcards.hits == "" then wildcards.hits = "1" end
		if wildcards.crit == nil or wildcards.crit == "" then
			wildcards.crit = "0"
		else
			wildcards.crit = "1"
		end

		if tonumber(wildcards.damage) == 0 or wildcards.attack == "group's combined attack" or wildcards.attack == "deadly ice bomb" or wildcards.attack == "flying ninja kick" or wildcards.attack == "combo-breaking uppercut" then
			return --Ignore 0 damage hits.
		end

		-- round damage dealt
		if wildcards.player == "You" then roundDamageDealt = roundDamageDealt + tonumber(wildcards.damage) end

		--players[wildcards.player]:AttackDealt(wildcards.attack, tonumber(wildcards.damage), tonumber(wildcards.hits))
		players[wildcards.player]:AttackDealt(wildcards.attack, tonumber(wildcards.damage), tonumber(wildcards.hits), tonumber(wildcards.crit))

		if window.show then
			QueueDrawMain()
		end
		if detailWindow.show then
			QueueDrawDetail()
		end
		--if playerWindow.show then
		--	QueueDrawPlayer()
		--end
	end

	function SetGoal(name, line, wildcards)
		ColourNote("orange", "", "Goal [" .. wildcards[1] .. "] set to " .. wildcards[2] .. ".")
		goalData[wildcards[1]].goal = wildcards[2]

		SetVariable("goal_data", serialize.save_simple(goalData))
	end

	function ResetGoal(name, line, wildcards)
		if wildcards[1] == "all" then
			--goalData["exp"].goal = 0
			goalData["exp"].current = 0
			--goalData["gold"].goal = 0
			goalData["gold"].current = 0
			--goalData["lvl"].goal = 0
			goalData["lvl"].current = 0
			--goalData["pup"].goal = 0
			goalData["pup"].current = 0
			uptimes.goals = os.clock()
			ColourNote("orange", "", "All goals reset")
		else
			--goalData[wildcards[1]].goal = 0
			goalData[wildcards[1]].current = 0
			ColourNote("orange", "", "Goal data reset for: " .. wildcards[1] .. ".")
		end
	end

	function ReportGoal(name, line, wildcards)
		if tonumber(goalData[wildcards[1]].goal) == 0 then
			ColourNote("orange", "", "You do not have an active " .. wildcards[1] .. " goal.")
			return
		end

		local tempString = wildcards[2] .. " @cCurrent Goal@C[@w" .. wildcards[1] .. "@C]@c: @W" .. commas(tonumber(goalData[wildcards[1]].current)) .. "@C/@W" .. commas(tonumber(goalData[wildcards[1]].goal))
		if tonumber(goalData[wildcards[1]].current) >= tonumber(goalData[wildcards[1]].goal) then
			tempString = tempString .. " @g(@GCompleted@g)@w"
		else
			tempString = tempString .. " @C(@cRemaining: @W" .. commas(tonumber(goalData[wildcards[1]].goal) - tonumber(goalData[wildcards[1]].current)) .. "@C)@w"
		end
		Send(tempString)
	end

	
	function SetRollingWindowDuration(name, line, wildcards)
		rollingWindow = tonumber(wildcards[1])
		SetVariable("rollingWindow", rollingWindow)
		ColourNote("orange", "", "Rolling window set to: ", "cyan", "", tostring(rollingWindow))	
	end

	function OnSecond()
		-- Calculate the change since the last second
		local changedPlayerData = {}
		changedPlayerData.damageDealt = players["You"].damageDealt - lastPlayerData.damageDealt
		changedPlayerData.damageReceived = players["You"].damageReceived - lastPlayerData.damageReceived
		changedPlayerData.damageReceivedHits = players["You"].damageReceivedHits - lastPlayerData.damageReceivedHits
		changedPlayerData.totalDodges = players["You"].dodges.Total.count - lastPlayerData.totalDodges
		changedPlayerData.dodgeableHitsReceived =  players["You"].dodgeableHitsReceived - lastPlayerData.dodgeableHitsReceived

		changedPlayerData.damageAggregates = { damtypes = {} }
		changedPlayerData.damageAggregates.melee = players["You"].damageAggregates.melee - (lastPlayerData.damageAggregates.melee or 0)
		changedPlayerData.damageAggregates.spell = players["You"].damageAggregates.spell - (lastPlayerData.damageAggregates.spell or 0)
		changedPlayerData.damageAggregates.physical = players["You"].damageAggregates.physical - (lastPlayerData.damageAggregates.physical or 0)
		changedPlayerData.damageAggregates.magic = players["You"].damageAggregates.magic - (lastPlayerData.damageAggregates.magic or 0)
		changedPlayerData.damageAggregates.unknown = players["You"].damageAggregates.unknown - (lastPlayerData.damageAggregates.unknown or 0)
		for damType, damage in pairs(players["You"].damageAggregates.damtypes) do		
			changedPlayerData.damageAggregates.damtypes[damType] = damage - (lastPlayerData.damageAggregates.damtypes[damType] or 0)						
		end

		changedPlayerData.expTotal = expTable.total - lastPlayerData.expTotal
		changedPlayerData.goldTotal = goldTable.total - lastPlayerData.goldTotal


		-- Add an entry to the change table
		table.insert(changeData, 1, changedPlayerData)


		-- add this change to the rolling total
		rollingPlayerData.damageDealt = rollingPlayerData.damageDealt + changedPlayerData.damageDealt
		rollingPlayerData.damageReceived = rollingPlayerData.damageReceived + changedPlayerData.damageReceived
		rollingPlayerData.damageReceivedHits = rollingPlayerData.damageReceivedHits + changedPlayerData.damageReceivedHits
		rollingPlayerData.totalDodges = rollingPlayerData.totalDodges + changedPlayerData.totalDodges
		rollingPlayerData.dodgeableHitsReceived = rollingPlayerData.dodgeableHitsReceived + changedPlayerData.dodgeableHitsReceived
		
		rollingPlayerData.damageAggregates.melee = (rollingPlayerData.damageAggregates.melee or 0) + changedPlayerData.damageAggregates.melee
		rollingPlayerData.damageAggregates.spell = (rollingPlayerData.damageAggregates.spell or 0) + changedPlayerData.damageAggregates.spell
		rollingPlayerData.damageAggregates.physical = (rollingPlayerData.damageAggregates.physical or 0) + changedPlayerData.damageAggregates.physical
		rollingPlayerData.damageAggregates.magic = (rollingPlayerData.damageAggregates.magic or 0) + changedPlayerData.damageAggregates.magic
		rollingPlayerData.damageAggregates.unknown = (rollingPlayerData.damageAggregates.unknown or 0) + changedPlayerData.damageAggregates.unknown
		for damType, damage in pairs(changedPlayerData.damageAggregates.damtypes) do		
			rollingPlayerData.damageAggregates.damtypes[damType] = (rollingPlayerData.damageAggregates.damtypes[damType] or 0) + damage
		end

		rollingPlayerData.expTotal = rollingPlayerData.expTotal + changedPlayerData.expTotal
		rollingPlayerData.goldTotal = rollingPlayerData.goldTotal + changedPlayerData.goldTotal


		-- remove 61st entry from the table
		oldChangedPlayerData = table.remove(changeData, rollingWindow + 1)
		

		-- subtract the last change
		if oldChangedPlayerData ~= nil then
			rollingPlayerData.damageDealt = rollingPlayerData.damageDealt - oldChangedPlayerData.damageDealt
			rollingPlayerData.damageReceived = rollingPlayerData.damageReceived - oldChangedPlayerData.damageReceived
			rollingPlayerData.damageReceivedHits = rollingPlayerData.damageReceivedHits - oldChangedPlayerData.damageReceivedHits
			rollingPlayerData.totalDodges = rollingPlayerData.totalDodges - oldChangedPlayerData.totalDodges
			rollingPlayerData.dodgeableHitsReceived = rollingPlayerData.dodgeableHitsReceived - oldChangedPlayerData.dodgeableHitsReceived

			rollingPlayerData.damageAggregates.melee = rollingPlayerData.damageAggregates.melee - oldChangedPlayerData.damageAggregates.melee
			rollingPlayerData.damageAggregates.spell = rollingPlayerData.damageAggregates.spell - oldChangedPlayerData.damageAggregates.spell
			rollingPlayerData.damageAggregates.physical = rollingPlayerData.damageAggregates.physical - oldChangedPlayerData.damageAggregates.physical
			rollingPlayerData.damageAggregates.magic = rollingPlayerData.damageAggregates.magic - oldChangedPlayerData.damageAggregates.magic
			rollingPlayerData.damageAggregates.unknown = rollingPlayerData.damageAggregates.unknown - oldChangedPlayerData.damageAggregates.unknown
			for damType, damage in pairs(oldChangedPlayerData.damageAggregates.damtypes) do		
				rollingPlayerData.damageAggregates.damtypes[damType] = rollingPlayerData.damageAggregates.damtypes[damType] - damage
			end

			rollingPlayerData.expTotal = rollingPlayerData.expTotal - oldChangedPlayerData.expTotal
			rollingPlayerData.goldTotal = rollingPlayerData.goldTotal - oldChangedPlayerData.goldTotal
		end

		rollingPlayerData.damageTime = #changeData
		rollingPlayerData.expTime = #changeData
		rollingPlayerData.goldTime = #changeData		


		-- save the data from this second
		lastPlayerData = {
			damageTime = players["You"].time,
			expTime = expTable.time,
			goldTime = goldTable.time
		}
		lastPlayerData.damageDealt = players["You"].damageDealt
		lastPlayerData.damageReceived = players["You"].damageReceived
		lastPlayerData.damageReceivedHits = players["You"].damageReceivedHits
		lastPlayerData.totalDodges = players["You"].dodges.Total.count
		lastPlayerData.dodgeableHitsReceived = players["You"].dodgeableHitsReceived

		lastPlayerData.damageAggregates = { damtypes = {} }		
		lastPlayerData.damageAggregates.melee = players["You"].damageAggregates.melee
		lastPlayerData.damageAggregates.spell = players["You"].damageAggregates.spell
		lastPlayerData.damageAggregates.physical = players["You"].damageAggregates.physical
		lastPlayerData.damageAggregates.magic = players["You"].damageAggregates.magic
		lastPlayerData.damageAggregates.unknown = players["You"].damageAggregates.unknown
		for damType, damage in pairs(players["You"].damageAggregates.damtypes) do		
			lastPlayerData.damageAggregates.damtypes[damType] = damage						
		end

		lastPlayerData.expTotal = expTable.total
		lastPlayerData.goldTotal = goldTable.total

		QueueDrawPlayer()
		--Note(serialize.save_simple(rollingPlayerData))
	end

	function Clear(name, line, wildcards)
		local cType = wildcards[2]

		if cType == "damage" or cType == "dmg" then
			clearDamage()
			ColourNote("orange", "", "[LDT] Tracking for damage has been reset.")
			uptimes.dmg = os.clock()
			uptimes.dmgrec = os.clock()
		elseif cType == "dodges" then
			players["You"].dodgeableHitsReceived = 0
			players["You"].dodges = {
				Total = {
					count = 0,
					colour = randomColour()
				}
			}
			uptimes.dodges = os.clock()
			ColourNote("orange", "", "[LDT] Tracking for dodges has been reset.")
		elseif cType == "exp" then
			expTable = {}
			expTable.areas = {}
			expTable.total = 0
			expTable.time = 0
			uptimes.exp = os.clock()
			ColourNote("orange", "", "[LDT] Tracking for experience has been reset.")
		elseif cType == "gold" then
			goldTable = {}
			goldTable.areas = {}
			goldTable.total = 0
			goldTable.time = 0
			uptimes.gold = os.clock()
			ColourNote("orange", "", "[LDT] Tracking for gold has been reset.")
		elseif cType == "pups" then
			clanTable.pupInfo = {}
			clanTable.totalPup = 0
			clanTable.timePup = 0
			clanTable.lastPup = os.clock()
			uptimes.pups = os.clock()
			ColourNote("orange", "", "[LDT] Tracking for pups has been reset.")
		elseif cType == "lvls" then
			clanTable.lvlInfo = {}
			clanTable.totalLvl = 0
			clanTable.timeLvl = 0
			clanTable.lastLvl = os.clock()
			uptimes.lvls = os.clock()
			ColourNote("orange", "", "[LDT] Tracking for levels has been reset.")
		elseif cType == "deaths" then
			clanTable.deathInfo = {}
			clanTable.totalDeath = 0
			clanTable.timeDeath = 0
			clanTable.lastDeath = os.clock()
			uptimes.deaths = os.clock()
			ColourNote("orange", "", "[LDT] Tracking for deaths has been reset.")
		elseif cType == "all" then
			clearDamage()
			expTable = {}
			expTable.areas = {}
			expTable.total = 0
			expTable.time = 0
			goldTable = {}
			goldTable.areas = {}
			goldTable.total = 0
			goldTable.time = 0
			clanTable.pupInfo = {}
			clanTable.totalPup = 0
			clanTable.timePup = 0
			clanTable.lastPup = os.clock()
			clanTable.lvlInfo = {}
			clanTable.totalLvl = 0
			clanTable.timeLvl = 0
			clanTable.lastLvl = os.clock()
			clanTable.deathInfo = {}
			clanTable.totalDeath = 0
			clanTable.timeDeath = 0
			clanTable.lastDeath = os.clock()
			uptimes.dmg = os.clock()
			uptimes.dmgrec = os.clock()
			uptimes.dodges = os.clock()
			uptimes.exp = os.clock()
			uptimes.gold = os.clock()
			uptimes.pups = os.clock()
			uptimes.lvls = os.clock()
			uptimes.deaths = os.clock()
			uptimes.goals = os.clock()
			ColourNote("orange", "", "[LDT] All tracking data has been reset.")
		else
			ColourNote("orange", "", "\'" .. cType .. "\' is an invalid option. Available options are: damage/dmg, dodges, exp, gold, pups, lvls and all.")
			return
		end
		Draw(window)
	end

	function clearDamage()
		for name, player in pairs(players) do
			DeleteDamageTrigger(name)
		end

		players = {}

		InitializePlayer("You")
		LoadGroup()
	end

	function ReportTotal(name, line, wildcards)
		local reportTbl = StartLabel("DAMAGE")

		local stats = players["You"]

		table.insert(reportTbl, { typ="val", val=commas(math.floor(stats.damageDealt)) })		
		table.insert(reportTbl, { typ="val", val="  "..commas(math.floor(stats.damageDealtPerSecond)) })
		table.insert(reportTbl, { typ="sep", val="/s" })		

		table.insert(reportTbl, EndLabel())

		ReportChannel(reportTbl, wildcards[1])
	end

	function ReportTypes(name, line, wildcards)
		local reportTbl = {}	

		for attackName, attack in spairs(players["You"].attacksDealt, function(t,a,b) return t[a].damage > t[b].damage end) do
			if (attack.damage / players["You"].damageDealt) * 100 > tonumber(filterAmount) then
				table.insert(reportTbl, { typ="sep", val="[" })
				table.insert(reportTbl, { typ="lbl", val=attackName })
				table.insert(reportTbl, { typ="sep", val="|" } )

				table.insert(reportTbl, { typ="val", val=commas(math.floor(attack.damage)) })
				table.insert(reportTbl, { typ="val", val="  "..commas(math.floor(attack.hits)) })
				table.insert(reportTbl, { typ="sep", val="hits  " })
				table.insert(reportTbl, { typ="val", val=commas(math.floor(attack.damage/attack.hits)) })
				table.insert(reportTbl, { typ="sep", val="/hit  " })
				table.insert(reportTbl, { typ="val", val=string.format("%.1f", (attack.damage/players["You"].damageDealt)*100) })
				table.insert(reportTbl, { typ="sep", val="%" })		

				table.insert(reportTbl, EndLabel())
				table.insert(reportTbl, { typ="sep", val="  " })
			end
		end

		table.remove(reportTbl, #reportTbl)

		ReportChannel(reportTbl, wildcards[1])
	end

	function StartLabel(label)
		return {
			{ typ="sep", val="[" },
			{ typ="lbl", val=label },
			{ typ="sep", val="|" }
		}
	end

	function EndLabel()
		return { typ="sep", val="]" }
	end

	function ReportChannel(reportTbl, channel)
		local reportStr = channel .. " "			
		
		for i, style in pairs(reportTbl) do
			local color = "@w"
			if style.typ == "sep" then color = clrSep 
			elseif style.typ == "lbl" then color = clrLbl 
			elseif style.typ == "val" then color = clrVal end
			
			reportStr = reportStr .. color .. style.val
		end
		
		SendNoEcho(reportStr)
	end

	function Show()
		for name, player in spairs(players, function(t,a,b) return t[a].damageDealt > t[b].damageDealt end) do
			OutputPlayer(name)			
		end		
	end

	function ShowPlayer(name, line, wildcards)
		for name, player in spairs(players, function(t,a,b) return t[a].damageDealt > t[b].damageDealt end) do
			if string.find(string.lower(name), string.lower(wildcards[1])) ~= nil then
				OutputPlayer(name)
				return
			end
		end		
		ColourNote("darkcyan", "", "The player " .. wildcards[1] .. " could not be found.")
	end

	function OutputPlayer(playerName)
		local player = players[playerName]

		ColourNote("white", "", "\n" .. playerName .. " - Dealt", 
			"gray", "", " | ",
			"orange", "", commas(math.floor(player.damageDealt)),			
			"gray", "", " | ",
			"orange", "", commas(math.floor(player.damageDealtPerSecond)),
			"gray", "", "/s")

		for attackName, attack in spairs(player.attacksDealt, function(t,a,b) return t[a].damage > t[b].damage end) do
			ColourNote("cyan", "", attackName ,
				"gray", "", " | ",
				"darkcyan", "", (Attack.damageTypeMap[(Attack.meleeDamageMap[attackName] or Attack.spellDamageMap[attackName])] or "unknown"),
				"gray", "", " | ",
				"darkcyan", "", (Attack.meleeDamageMap[attackName] or Attack.spellDamageMap[attackName] or "unknown"),
				"gray", "", " | ",
				"orange", "", commas(math.floor(attack.damage)),
				"gray", "", " | ",
				"orange", "", commas(math.floor(attack.hits)),
				"gray", "", "hits ",
				"orange", "", commas(math.floor(attack.damage / attack.hits)),
				"gray", "", "/hit ",
				"orange", "", string.format("%.1f", (attack.damage / player.damageDealt) * 100),
				"gray", "", "%")
		end

		ColourNote("white", "",  "\n" .. playerName .. " - Received", 
			"gray", "", " | ",
			"orange", "", commas(math.floor(player.damageReceived)),			
			"gray", "", " | ",
			"orange", "", commas(math.floor(player.damageReceivedPerSecond)),
			"gray", "", "/s")	

		ColourTell("gray", "", "[",
			"lightgray", "", "physical",
			"gray", "", "|",
			"orange", "", string.format("%.1f", (player.damageAggregates.physical / player.damageReceived) * 100),
		 	"gray", "", "%]")

		ColourTell("gray", "", "[",
			"lightgray", "", "magic",
			"gray", "", "|",
			"orange", "", string.format("%.1f", (player.damageAggregates.magic / player.damageReceived) * 100),
		 	"gray", "", "%]")

		ColourTell("gray", "", " -- [",
			"lightgray", "", "melee",
			"gray", "", "|",
			"orange", "", string.format("%.1f", (player.damageAggregates.melee / player.damageReceived) * 100),
		 	"gray", "", "%]")

		ColourNote("gray", "", "[",
			"lightgray", "", "spell",
			"gray", "", "|",
			"orange", "", string.format("%.1f", (player.damageAggregates.spell / player.damageReceived) * 100),
		 	"gray", "", "%]")

		local displayCount = -1
		for damageType, totalDamage in spairs(player.damageAggregates.damtypes, function(t,a,b) return t[a] > t[b] end) do
			displayCount = displayCount + 1

			if displayCount % 5 == 0 then
				displayCount = 0
				ColourNote("orange", "", "")
			end		

			ColourTell(
				"gray", "", "[",
				"lightgray", "", damageType,
				"gray", "", "|",
				"orange", "", string.format("%.1f", (totalDamage / player.damageReceived) * 100),
			 	"gray", "", "%] ")
		end
		ColourNote("orange", "", "\n")
		
		for attackName, attack in spairs(player.attacksReceived, function(t,a,b) return t[a].damage > t[b].damage end) do
			ColourNote("cyan", "", attackName ,
				"gray", "", " | ",
				"darkcyan", "", (Attack.damageTypeMap[(Attack.meleeDamageMap[attackName] or Attack.spellDamageMap[attackName])] or "unknown"),
				"gray", "", " | ",
				"darkcyan", "", (Attack.meleeDamageMap[attackName] or Attack.spellDamageMap[attackName] or "unknown"),
				"gray", "", " | ",
				"orange", "", commas(math.floor(attack.damage)),
				"gray", "", " | ",
				"orange", "", commas(math.floor(attack.hits)),
				"gray", "", "hits ",
				"orange", "", commas(math.floor(attack.damage / attack.hits)),
				"gray", "", "/hit ",
				"orange", "", string.format("%.1f", (attack.damage / player.damageReceived) * 100),
				"gray", "", "%")
		end		

		ColourNote("dimgray", "", "----------------------------------------------------------------------------------------------")
	end

	function GetTimeString(curTimer)
		local min = 0
		local sec = 0
		local hrs = 0
		local days = 0
		local x = ""

		local amount = (curTimer/86400)
		if amount >= 1.0 then
			days = math.floor(amount)
			x = x .. days .. "d "
		end

		amount = (curTimer%86400)/3600
		if amount >= 1.0 then
			hrs = math.floor(amount)
			x = x .. hrs .. "h "
		end

		amount = ((curTimer%86400)%3600)/60;
			if amount >= 1.0 then
			min = math.floor(amount)
			x = x .. min .. "m "
		end

		amount = (((curTimer%86400)%3600)%60)%60
--		if amount >= 1.0 then
			sec = math.floor(amount)
			x = x .. sec .. "s"
--		end

		if x == "" then
			x = "N/A"
			Note("GetTimeString errored. Values:" .. curTimer)
		end

		return x
	end

	function fixNaN(num)
		if num ~= num then num = 0 end
		return num
	end

	function spairs(t, order)
         -- collect the keys
         local keys = {}
         for k in pairs(t) do keys[#keys+1] = k end

         -- if order function given, sort by it by passing the table and keys a, b,
         -- otherwise just sort the keys 
         if order then
            table.sort(keys, function(a,b) return order(t, a, b) end)
         else
            table.sort(keys)
         end

         -- return the iterator function
         local i = 0
         return function()
            i = i + 1
            if keys[i] then
               return keys[i], t[keys[i]]
            end
         end
      end

      function capFirstLetter(str)
	 return str:sub(1,1):upper() .. str:sub(2)
      end
]]>
</script>

</muclient>